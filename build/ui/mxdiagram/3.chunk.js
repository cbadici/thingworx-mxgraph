(window["webpackJsonpmxdiagram"] = window["webpackJsonpmxdiagram"] || []).push([[3],{

/***/ "./node_modules/pako/index.js":
/*!************************************!*\
  !*** ./node_modules/pako/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Top level file is just a mixin of submodules & constants\n\n\nvar assign = __webpack_require__(/*! ./lib/utils/common */ \"./node_modules/pako/lib/utils/common.js\").assign;\n\nvar deflate = __webpack_require__(/*! ./lib/deflate */ \"./node_modules/pako/lib/deflate.js\");\n\nvar inflate = __webpack_require__(/*! ./lib/inflate */ \"./node_modules/pako/lib/inflate.js\");\n\nvar constants = __webpack_require__(/*! ./lib/zlib/constants */ \"./node_modules/pako/lib/zlib/constants.js\");\n\nvar pako = {};\nassign(pako, deflate, inflate, constants);\nmodule.exports = pako;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9pbmRleC5qcz9kN2FjIl0sIm5hbWVzIjpbImFzc2lnbiIsImRlZmxhdGUiLCJpbmZsYXRlIiwiY29uc3RhbnRzIiwicGFrbyIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUEsSUFBSUEsTUFBTSxHQUFNLG1CQUFPLENBQUMsbUVBQUQsQ0FBUCxDQUE4QkEsTUFBOUM7O0FBRUEsSUFBSUMsT0FBTyxHQUFLLG1CQUFPLENBQUMseURBQUQsQ0FBdkI7O0FBQ0EsSUFBSUMsT0FBTyxHQUFLLG1CQUFPLENBQUMseURBQUQsQ0FBdkI7O0FBQ0EsSUFBSUMsU0FBUyxHQUFHLG1CQUFPLENBQUMsdUVBQUQsQ0FBdkI7O0FBRUEsSUFBSUMsSUFBSSxHQUFHLEVBQVg7QUFFQUosTUFBTSxDQUFDSSxJQUFELEVBQU9ILE9BQVAsRUFBZ0JDLE9BQWhCLEVBQXlCQyxTQUF6QixDQUFOO0FBRUFFLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkYsSUFBakIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGFrby9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFRvcCBsZXZlbCBmaWxlIGlzIGp1c3QgYSBtaXhpbiBvZiBzdWJtb2R1bGVzICYgY29uc3RhbnRzXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gICAgPSByZXF1aXJlKCcuL2xpYi91dGlscy9jb21tb24nKS5hc3NpZ247XG5cbnZhciBkZWZsYXRlICAgPSByZXF1aXJlKCcuL2xpYi9kZWZsYXRlJyk7XG52YXIgaW5mbGF0ZSAgID0gcmVxdWlyZSgnLi9saWIvaW5mbGF0ZScpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vbGliL3psaWIvY29uc3RhbnRzJyk7XG5cbnZhciBwYWtvID0ge307XG5cbmFzc2lnbihwYWtvLCBkZWZsYXRlLCBpbmZsYXRlLCBjb25zdGFudHMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBha287XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/pako/index.js\n");

/***/ }),

/***/ "./node_modules/pako/lib/deflate.js":
/*!******************************************!*\
  !*** ./node_modules/pako/lib/deflate.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar zlib_deflate = __webpack_require__(/*! ./zlib/deflate */ \"./node_modules/pako/lib/zlib/deflate.js\");\n\nvar utils = __webpack_require__(/*! ./utils/common */ \"./node_modules/pako/lib/utils/common.js\");\n\nvar strings = __webpack_require__(/*! ./utils/strings */ \"./node_modules/pako/lib/utils/strings.js\");\n\nvar msg = __webpack_require__(/*! ./zlib/messages */ \"./node_modules/pako/lib/zlib/messages.js\");\n\nvar ZStream = __webpack_require__(/*! ./zlib/zstream */ \"./node_modules/pako/lib/zlib/zstream.js\");\n\nvar toString = Object.prototype.toString;\n/* Public constants ==========================================================*/\n\n/* ===========================================================================*/\n\nvar Z_NO_FLUSH = 0;\nvar Z_FINISH = 4;\nvar Z_OK = 0;\nvar Z_STREAM_END = 1;\nvar Z_SYNC_FLUSH = 2;\nvar Z_DEFAULT_COMPRESSION = -1;\nvar Z_DEFAULT_STRATEGY = 0;\nvar Z_DEFLATED = 8;\n/* ===========================================================================*/\n\n/**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/\n\n/* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overridden.\n **/\n\n/**\n * Deflate.result -> Uint8Array|Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you\n * push a chunk with explicit flush (call [[Deflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/\n\n/**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/\n\n/**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/\n\nfunction Deflate(options) {\n  if (!(this instanceof Deflate)) return new Deflate(options);\n  this.options = utils.assign({\n    level: Z_DEFAULT_COMPRESSION,\n    method: Z_DEFLATED,\n    chunkSize: 16384,\n    windowBits: 15,\n    memLevel: 8,\n    strategy: Z_DEFAULT_STRATEGY,\n    to: ''\n  }, options || {});\n  var opt = this.options;\n\n  if (opt.raw && opt.windowBits > 0) {\n    opt.windowBits = -opt.windowBits;\n  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {\n    opt.windowBits += 16;\n  }\n\n  this.err = 0; // error code, if happens (0 = Z_OK)\n\n  this.msg = ''; // error message\n\n  this.ended = false; // used to avoid multiple onEnd() calls\n\n  this.chunks = []; // chunks of compressed data\n\n  this.strm = new ZStream();\n  this.strm.avail_out = 0;\n  var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);\n\n  if (status !== Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  if (opt.header) {\n    zlib_deflate.deflateSetHeader(this.strm, opt.header);\n  }\n\n  if (opt.dictionary) {\n    var dict; // Convert data if needed\n\n    if (typeof opt.dictionary === 'string') {\n      // If we need to compress text, change encoding to utf8.\n      dict = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      dict = new Uint8Array(opt.dictionary);\n    } else {\n      dict = opt.dictionary;\n    }\n\n    status = zlib_deflate.deflateSetDictionary(this.strm, dict);\n\n    if (status !== Z_OK) {\n      throw new Error(msg[status]);\n    }\n\n    this._dict_set = true;\n  }\n}\n/**\n * Deflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the compression context.\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * array format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\n\n\nDeflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n\n  var status, _mode;\n\n  if (this.ended) {\n    return false;\n  }\n\n  _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH; // Convert data if needed\n\n  if (typeof data === 'string') {\n    // If we need to compress text, change encoding to utf8.\n    strm.input = strings.string2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    status = zlib_deflate.deflate(strm, _mode);\n    /* no bad return value */\n\n    if (status !== Z_STREAM_END && status !== Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n\n    if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {\n      if (this.options.to === 'string') {\n        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));\n      } else {\n        this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n      }\n    }\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END); // Finalize on the last chunk.\n\n\n  if (_mode === Z_FINISH) {\n    status = zlib_deflate.deflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === Z_OK;\n  } // callback interim results if Z_SYNC_FLUSH.\n\n\n  if (_mode === Z_SYNC_FLUSH) {\n    this.onEnd(Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\n\n\nDeflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\n\n\nDeflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK) {\n    if (this.options.to === 'string') {\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n/**\n * deflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/\n\n\nfunction deflate(input, options) {\n  var deflator = new Deflate(options);\n  deflator.push(input, true); // That will never happens, if you don't cheat with options :)\n\n  if (deflator.err) {\n    throw deflator.msg || msg[deflator.err];\n  }\n\n  return deflator.result;\n}\n/**\n * deflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\n\n\nfunction deflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return deflate(input, options);\n}\n/**\n * gzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/\n\n\nfunction gzip(input, options) {\n  options = options || {};\n  options.gzip = true;\n  return deflate(input, options);\n}\n\nexports.Deflate = Deflate;\nexports.deflate = deflate;\nexports.deflateRaw = deflateRaw;\nexports.gzip = gzip;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvZGVmbGF0ZS5qcz80MTI2Il0sIm5hbWVzIjpbInpsaWJfZGVmbGF0ZSIsInV0aWxzIiwic3RyaW5ncyIsIm1zZyIsIlpTdHJlYW0iLCJ0b1N0cmluZyIsIk9iamVjdCIsInByb3RvdHlwZSIsIlpfTk9fRkxVU0giLCJaX0ZJTklTSCIsIlpfT0siLCJaX1NUUkVBTV9FTkQiLCJaX1NZTkNfRkxVU0giLCJaX0RFRkFVTFRfQ09NUFJFU1NJT04iLCJaX0RFRkFVTFRfU1RSQVRFR1kiLCJaX0RFRkxBVEVEIiwiRGVmbGF0ZSIsIm9wdGlvbnMiLCJhc3NpZ24iLCJsZXZlbCIsIm1ldGhvZCIsImNodW5rU2l6ZSIsIndpbmRvd0JpdHMiLCJtZW1MZXZlbCIsInN0cmF0ZWd5IiwidG8iLCJvcHQiLCJyYXciLCJnemlwIiwiZXJyIiwiZW5kZWQiLCJjaHVua3MiLCJzdHJtIiwiYXZhaWxfb3V0Iiwic3RhdHVzIiwiZGVmbGF0ZUluaXQyIiwiRXJyb3IiLCJoZWFkZXIiLCJkZWZsYXRlU2V0SGVhZGVyIiwiZGljdGlvbmFyeSIsImRpY3QiLCJzdHJpbmcyYnVmIiwiY2FsbCIsIlVpbnQ4QXJyYXkiLCJkZWZsYXRlU2V0RGljdGlvbmFyeSIsIl9kaWN0X3NldCIsInB1c2giLCJkYXRhIiwibW9kZSIsIl9tb2RlIiwiaW5wdXQiLCJuZXh0X2luIiwiYXZhaWxfaW4iLCJsZW5ndGgiLCJvdXRwdXQiLCJCdWY4IiwibmV4dF9vdXQiLCJkZWZsYXRlIiwib25FbmQiLCJvbkRhdGEiLCJidWYyYmluc3RyaW5nIiwic2hyaW5rQnVmIiwiZGVmbGF0ZUVuZCIsImNodW5rIiwicmVzdWx0Iiwiam9pbiIsImZsYXR0ZW5DaHVua3MiLCJkZWZsYXRvciIsImRlZmxhdGVSYXciLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFHQSxJQUFJQSxZQUFZLEdBQUcsbUJBQU8sQ0FBQywrREFBRCxDQUExQjs7QUFDQSxJ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QUN0QyxHQUFWLENBQXpCO0FBQTBDOztBQUU5RCxTQUFPc0MsUUFBUSxDQUFDSCxNQUFoQjtBQUNEO0FBR0Q7Ozs7Ozs7Ozs7QUFRQSxTQUFTSSxVQUFULENBQW9CbEIsS0FBcEIsRUFBMkJqQyxPQUEzQixFQUFvQztBQUNsQ0EsU0FBTyxHQUFHQSxPQUFPLElBQUksRUFBckI7QUFDQUEsU0FBTyxDQUFDVSxHQUFSLEdBQWMsSUFBZDtBQUNBLFNBQU84QixPQUFPLENBQUNQLEtBQUQsRUFBUWpDLE9BQVIsQ0FBZDtBQUNEO0FBR0Q7Ozs7Ozs7Ozs7QUFRQSxTQUFTVyxJQUFULENBQWNzQixLQUFkLEVBQXFCakMsT0FBckIsRUFBOEI7QUFDNUJBLFNBQU8sR0FBR0EsT0FBTyxJQUFJLEVBQXJCO0FBQ0FBLFNBQU8sQ0FBQ1csSUFBUixHQUFlLElBQWY7QUFDQSxTQUFPNkIsT0FBTyxDQUFDUCxLQUFELEVBQVFqQyxPQUFSLENBQWQ7QUFDRDs7QUFHRG9ELE9BQU8sQ0FBQ3JELE9BQVIsR0FBa0JBLE9BQWxCO0FBQ0FxRCxPQUFPLENBQUNaLE9BQVIsR0FBa0JBLE9BQWxCO0FBQ0FZLE9BQU8sQ0FBQ0QsVUFBUixHQUFxQkEsVUFBckI7QUFDQUMsT0FBTyxDQUFDekMsSUFBUixHQUFlQSxJQUFmIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3Bha28vbGliL2RlZmxhdGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cblxudmFyIHpsaWJfZGVmbGF0ZSA9IHJlcXVpcmUoJy4vemxpYi9kZWZsYXRlJyk7XG52YXIgdXRpbHMgICAgICAgID0gcmVxdWlyZSgnLi91dGlscy9jb21tb24nKTtcbnZhciBzdHJpbmdzICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL3N0cmluZ3MnKTtcbnZhciBtc2cgICAgICAgICAgPSByZXF1aXJlKCcuL3psaWIvbWVzc2FnZXMnKTtcbnZhciBaU3RyZWFtICAgICAgPSByZXF1aXJlKCcuL3psaWIvenN0cmVhbScpO1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxudmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcblxudmFyIFpfT0sgICAgICAgICAgICA9IDA7XG52YXIgWl9TVFJFQU1fRU5EICAgID0gMTtcbnZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xuXG52YXIgWl9ERUZBVUxUX0NPTVBSRVNTSU9OID0gLTE7XG5cbnZhciBaX0RFRkFVTFRfU1RSQVRFR1kgICAgPSAwO1xuXG52YXIgWl9ERUZMQVRFRCAgPSA4O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qKlxuICogY2xhc3MgRGVmbGF0ZVxuICpcbiAqIEdlbmVyaWMgSlMtc3R5bGUgd3JhcHBlciBmb3IgemxpYiBjYWxscy4gSWYgeW91IGRvbid0IG5lZWRcbiAqIHN0cmVhbWluZyBiZWhhdmlvdXIgLSB1c2UgbW9yZSBzaW1wbGUgZnVuY3Rpb25zOiBbW2RlZmxhdGVdXSxcbiAqIFtbZGVmbGF0ZVJhd11dIGFuZCBbW2d6aXBdXS5cbiAqKi9cblxuLyogaW50ZXJuYWxcbiAqIERlZmxhdGUuY2h1bmtzIC0+IEFycmF5XG4gKlxuICogQ2h1bmtzIG9mIG91dHB1dCBkYXRhLCBpZiBbW0RlZmxhdGUjb25EYXRhXV0gbm90IG92ZXJyaWRkZW4uXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5yZXN1bHQgLT4gVWludDhBcnJheXxBcnJheVxuICpcbiAqIENvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0RlZmxhdGUjb25EYXRhXV1cbiAqIGFuZCBbW0RlZmxhdGUjb25FbmRdXSBoYW5kbGVycy4gRmlsbGVkIGFmdGVyIHlvdSBwdXNoIGxhc3QgY2h1bmtcbiAqIChjYWxsIFtbRGVmbGF0ZSNwdXNoXV0gd2l0aCBgWl9GSU5JU0hgIC8gYHRydWVgIHBhcmFtKSAgb3IgaWYgeW91XG4gKiBwdXNoIGEgY2h1bmsgd2l0aCBleHBsaWNpdCBmbHVzaCAoY2FsbCBbW0RlZmxhdGUjcHVzaF1dIHdpdGhcbiAqIGBaX1NZTkNfRkxVU0hgIHBhcmFtKS5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLmVyciAtPiBOdW1iZXJcbiAqXG4gKiBFcnJvciBjb2RlIGFmdGVyIGRlZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuXG4gKiBZb3Ugd2lsbCBub3QgbmVlZCBpdCBpbiByZWFsIGxpZmUsIGJlY2F1c2UgZGVmbGF0ZSBlcnJvcnNcbiAqIGFyZSBwb3NzaWJsZSBvbmx5IG9uIHdyb25nIG9wdGlvbnMgb3IgYmFkIGBvbkRhdGFgIC8gYG9uRW5kYFxuICogY3VzdG9tIGhhbmRsZXJzLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUubXNnIC0+IFN0cmluZ1xuICpcbiAqIEVycm9yIG1lc3NhZ2UsIGlmIFtbRGVmbGF0ZS5lcnJdXSAhPSAwXG4gKiovXG5cblxuLyoqXG4gKiBuZXcgRGVmbGF0ZShvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDcmVhdGVzIG5ldyBkZWZsYXRvciBpbnN0YW5jZSB3aXRoIHNwZWNpZmllZCBwYXJhbXMuIFRocm93cyBleGNlcHRpb25cbiAqIG9uIGJhZCBwYXJhbXMuIFN1cHBvcnRlZCBvcHRpb25zOlxuICpcbiAqIC0gYGxldmVsYFxuICogLSBgd2luZG93Qml0c2BcbiAqIC0gYG1lbUxldmVsYFxuICogLSBgc3RyYXRlZ3lgXG4gKiAtIGBkaWN0aW9uYXJ5YFxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIEFkZGl0aW9uYWwgb3B0aW9ucywgZm9yIGludGVybmFsIG5lZWRzOlxuICpcbiAqIC0gYGNodW5rU2l6ZWAgLSBzaXplIG9mIGdlbmVyYXRlZCBkYXRhIGNodW5rcyAoMTZLIGJ5IGRlZmF1bHQpXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIGRvIHJhdyBkZWZsYXRlXG4gKiAtIGBnemlwYCAoQm9vbGVhbikgLSBjcmVhdGUgZ3ppcCB3cmFwcGVyXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBcImJpbmFyeSBzdHJpbmdcIlxuICogICAgKGVhY2ggY2hhciBjb2RlIFswLi4yNTVdKVxuICogLSBgaGVhZGVyYCAoT2JqZWN0KSAtIGN1c3RvbSBoZWFkZXIgZm9yIGd6aXBcbiAqICAgLSBgdGV4dGAgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBjb21wcmVzc2VkIGRhdGEgYmVsaWV2ZWQgdG8gYmUgdGV4dFxuICogICAtIGB0aW1lYCAoTnVtYmVyKSAtIG1vZGlmaWNhdGlvbiB0aW1lLCB1bml4IHRpbWVzdGFtcFxuICogICAtIGBvc2AgKE51bWJlcikgLSBvcGVyYXRpb24gc3lzdGVtIGNvZGVcbiAqICAgLSBgZXh0cmFgIChBcnJheSkgLSBhcnJheSBvZiBieXRlcyB3aXRoIGV4dHJhIGRhdGEgKG1heCA2NTUzNilcbiAqICAgLSBgbmFtZWAgKFN0cmluZykgLSBmaWxlIG5hbWUgKGJpbmFyeSBzdHJpbmcpXG4gKiAgIC0gYGNvbW1lbnRgIChTdHJpbmcpIC0gY29tbWVudCAoYmluYXJ5IHN0cmluZylcbiAqICAgLSBgaGNyY2AgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBoZWFkZXIgY3JjIHNob3VsZCBiZSBhZGRlZFxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBjaHVuazEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgY2h1bmsyID0gVWludDhBcnJheShbMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTldKTtcbiAqXG4gKiB2YXIgZGVmbGF0ZSA9IG5ldyBwYWtvLkRlZmxhdGUoeyBsZXZlbDogM30pO1xuICpcbiAqIGRlZmxhdGUucHVzaChjaHVuazEsIGZhbHNlKTtcbiAqIGRlZmxhdGUucHVzaChjaHVuazIsIHRydWUpOyAgLy8gdHJ1ZSAtPiBsYXN0IGNodW5rXG4gKlxuICogaWYgKGRlZmxhdGUuZXJyKSB7IHRocm93IG5ldyBFcnJvcihkZWZsYXRlLmVycik7IH1cbiAqXG4gKiBjb25zb2xlLmxvZyhkZWZsYXRlLnJlc3VsdCk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIERlZmxhdGUob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGVmbGF0ZSkpIHJldHVybiBuZXcgRGVmbGF0ZShvcHRpb25zKTtcblxuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5hc3NpZ24oe1xuICAgIGxldmVsOiBaX0RFRkFVTFRfQ09NUFJFU1NJT04sXG4gICAgbWV0aG9kOiBaX0RFRkxBVEVELFxuICAgIGNodW5rU2l6ZTogMTYzODQsXG4gICAgd2luZG93Qml0czogMTUsXG4gICAgbWVtTGV2ZWw6IDgsXG4gICAgc3RyYXRlZ3k6IFpfREVGQVVMVF9TVFJBVEVHWSxcbiAgICB0bzogJydcbiAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgdmFyIG9wdCA9IHRoaXMub3B0aW9ucztcblxuICBpZiAob3B0LnJhdyAmJiAob3B0LndpbmRvd0JpdHMgPiAwKSkge1xuICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzO1xuICB9XG5cbiAgZWxzZSBpZiAob3B0Lmd6aXAgJiYgKG9wdC53aW5kb3dCaXRzID4gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgKz0gMTY7XG4gIH1cblxuICB0aGlzLmVyciAgICA9IDA7ICAgICAgLy8gZXJyb3IgY29kZSwgaWYgaGFwcGVucyAoMCA9IFpfT0spXG4gIHRoaXMubXNnICAgID0gJyc7ICAgICAvLyBlcnJvciBtZXNzYWdlXG4gIHRoaXMuZW5kZWQgID0gZmFsc2U7ICAvLyB1c2VkIHRvIGF2b2lkIG11bHRpcGxlIG9uRW5kKCkgY2FsbHNcbiAgdGhpcy5jaHVua3MgPSBbXTsgICAgIC8vIGNodW5rcyBvZiBjb21wcmVzc2VkIGRhdGFcblxuICB0aGlzLnN0cm0gPSBuZXcgWlN0cmVhbSgpO1xuICB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDtcblxuICB2YXIgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVJbml0MihcbiAgICB0aGlzLnN0cm0sXG4gICAgb3B0LmxldmVsLFxuICAgIG9wdC5tZXRob2QsXG4gICAgb3B0LndpbmRvd0JpdHMsXG4gICAgb3B0Lm1lbUxldmVsLFxuICAgIG9wdC5zdHJhdGVneVxuICApO1xuXG4gIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICB9XG5cbiAgaWYgKG9wdC5oZWFkZXIpIHtcbiAgICB6bGliX2RlZmxhdGUuZGVmbGF0ZVNldEhlYWRlcih0aGlzLnN0cm0sIG9wdC5oZWFkZXIpO1xuICB9XG5cbiAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7XG4gICAgdmFyIGRpY3Q7XG4gICAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2Ygb3B0LmRpY3Rpb25hcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LlxuICAgICAgZGljdCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKG9wdC5kaWN0aW9uYXJ5KSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgZGljdCA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGljdCA9IG9wdC5kaWN0aW9uYXJ5O1xuICAgIH1cblxuICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3QpO1xuXG4gICAgaWYgKHN0YXR1cyAhPT0gWl9PSykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kaWN0X3NldCA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWZsYXRlI3B1c2goZGF0YVssIG1vZGVdKSAtPiBCb29sZWFuXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YS4gU3RyaW5ncyB3aWxsIGJlXG4gKiAgIGNvbnZlcnRlZCB0byB1dGY4IGJ5dGUgc2VxdWVuY2UuXG4gKiAtIG1vZGUgKE51bWJlcnxCb29sZWFuKTogMC4uNiBmb3IgY29ycmVzcG9uZGluZyBaX05PX0ZMVVNILi5aX1RSRUUgbW9kZXMuXG4gKiAgIFNlZSBjb25zdGFudHMuIFNraXBwZWQgb3IgYGZhbHNlYCBtZWFucyBaX05PX0ZMVVNILCBgdHJ1ZWAgbWVhbnMgWl9GSU5JU0guXG4gKlxuICogU2VuZHMgaW5wdXQgZGF0YSB0byBkZWZsYXRlIHBpcGUsIGdlbmVyYXRpbmcgW1tEZWZsYXRlI29uRGF0YV1dIGNhbGxzIHdpdGhcbiAqIG5ldyBjb21wcmVzc2VkIGNodW5rcy4gUmV0dXJucyBgdHJ1ZWAgb24gc3VjY2Vzcy4gVGhlIGxhc3QgZGF0YSBibG9jayBtdXN0IGhhdmVcbiAqIG1vZGUgWl9GSU5JU0ggKG9yIGB0cnVlYCkuIFRoYXQgd2lsbCBmbHVzaCBpbnRlcm5hbCBwZW5kaW5nIGJ1ZmZlcnMgYW5kIGNhbGxcbiAqIFtbRGVmbGF0ZSNvbkVuZF1dLiBGb3IgaW50ZXJpbSBleHBsaWNpdCBmbHVzaGVzICh3aXRob3V0IGVuZGluZyB0aGUgc3RyZWFtKSB5b3VcbiAqIGNhbiB1c2UgbW9kZSBaX1NZTkNfRkxVU0gsIGtlZXBpbmcgdGhlIGNvbXByZXNzaW9uIGNvbnRleHQuXG4gKlxuICogT24gZmFpbCBjYWxsIFtbRGVmbGF0ZSNvbkVuZF1dIHdpdGggZXJyb3IgY29kZSBhbmQgcmV0dXJuIGZhbHNlLlxuICpcbiAqIFdlIHN0cm9uZ2x5IHJlY29tbWVuZCB0byB1c2UgYFVpbnQ4QXJyYXlgIG9uIGlucHV0IGZvciBiZXN0IHNwZWVkIChvdXRwdXRcbiAqIGFycmF5IGZvcm1hdCBpcyBkZXRlY3RlZCBhdXRvbWF0aWNhbGx5KS4gQWxzbywgZG9uJ3Qgc2tpcCBsYXN0IHBhcmFtIGFuZCBhbHdheXNcbiAqIHVzZSB0aGUgc2FtZSB0eXBlIGluIHlvdXIgY29kZSAoYm9vbGVhbiBvciBudW1iZXIpLiBUaGF0IHdpbGwgaW1wcm92ZSBKUyBzcGVlZC5cbiAqXG4gKiBGb3IgcmVndWxhciBgQXJyYXlgLXMgbWFrZSBzdXJlIGFsbCBlbGVtZW50cyBhcmUgWzAuLjI1NV0uXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHB1c2goY2h1bmssIGZhbHNlKTsgLy8gcHVzaCBvbmUgb2YgZGF0YSBjaHVua3NcbiAqIC4uLlxuICogcHVzaChjaHVuaywgdHJ1ZSk7ICAvLyBwdXNoIGxhc3QgY2h1bmtcbiAqIGBgYFxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBtb2RlKSB7XG4gIHZhciBzdHJtID0gdGhpcy5zdHJtO1xuICB2YXIgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgdmFyIHN0YXR1cywgX21vZGU7XG5cbiAgaWYgKHRoaXMuZW5kZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgX21vZGUgPSAobW9kZSA9PT0gfn5tb2RlKSA/IG1vZGUgOiAoKG1vZGUgPT09IHRydWUpID8gWl9GSU5JU0ggOiBaX05PX0ZMVVNIKTtcblxuICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LlxuICAgIHN0cm0uaW5wdXQgPSBzdHJpbmdzLnN0cmluZzJidWYoZGF0YSk7XG4gIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJtLmlucHV0ID0gZGF0YTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDtcblxuICBkbyB7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBzdHJtLm91dHB1dCA9IG5ldyB1dGlscy5CdWY4KGNodW5rU2l6ZSk7XG4gICAgICBzdHJtLm5leHRfb3V0ID0gMDtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplO1xuICAgIH1cbiAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZShzdHJtLCBfbW9kZSk7ICAgIC8qIG5vIGJhZCByZXR1cm4gdmFsdWUgKi9cblxuICAgIGlmIChzdGF0dXMgIT09IFpfU1RSRUFNX0VORCAmJiBzdGF0dXMgIT09IFpfT0spIHtcbiAgICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDAgfHwgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgKF9tb2RlID09PSBaX0ZJTklTSCB8fCBfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIKSkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMub25EYXRhKHN0cmluZ3MuYnVmMmJpbnN0cmluZyh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uRGF0YSh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gd2hpbGUgKChzdHJtLmF2YWlsX2luID4gMCB8fCBzdHJtLmF2YWlsX291dCA9PT0gMCkgJiYgc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQpO1xuXG4gIC8vIEZpbmFsaXplIG9uIHRoZSBsYXN0IGNodW5rLlxuICBpZiAoX21vZGUgPT09IFpfRklOSVNIKSB7XG4gICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgcmV0dXJuIHN0YXR1cyA9PT0gWl9PSztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGludGVyaW0gcmVzdWx0cyBpZiBaX1NZTkNfRkxVU0guXG4gIGlmIChfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIKSB7XG4gICAgdGhpcy5vbkVuZChaX09LKTtcbiAgICBzdHJtLmF2YWlsX291dCA9IDA7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBEZWZsYXRlI29uRGF0YShjaHVuaykgLT4gVm9pZFxuICogLSBjaHVuayAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBvdXRwdXQgZGF0YS4gVHlwZSBvZiBhcnJheSBkZXBlbmRzXG4gKiAgIG9uIGpzIGVuZ2luZSBzdXBwb3J0LiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLCBlYWNoIGNodW5rXG4gKiAgIHdpbGwgYmUgc3RyaW5nLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHN0b3JlcyBkYXRhIGJsb2NrcyBpbiBgY2h1bmtzW11gIHByb3BlcnR5IGFuZCBnbHVlXG4gKiB0aG9zZSBpbiBgb25FbmRgLiBPdmVycmlkZSB0aGlzIGhhbmRsZXIsIGlmIHlvdSBuZWVkIGFub3RoZXIgYmVoYXZpb3VyLlxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xufTtcblxuXG4vKipcbiAqIERlZmxhdGUjb25FbmQoc3RhdHVzKSAtPiBWb2lkXG4gKiAtIHN0YXR1cyAoTnVtYmVyKTogZGVmbGF0ZSBzdGF0dXMuIDAgKFpfT0spIG9uIHN1Y2Nlc3MsXG4gKiAgIG90aGVyIGlmIG5vdC5cbiAqXG4gKiBDYWxsZWQgb25jZSBhZnRlciB5b3UgdGVsbCBkZWZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpc1xuICogY29tcGxldGUgKFpfRklOSVNIKSBvciBzaG91bGQgYmUgZmx1c2hlZCAoWl9TWU5DX0ZMVVNIKVxuICogb3IgaWYgYW4gZXJyb3IgaGFwcGVuZWQuIEJ5IGRlZmF1bHQgLSBqb2luIGNvbGxlY3RlZCBjaHVua3MsXG4gKiBmcmVlIG1lbW9yeSBhbmQgZmlsbCBgcmVzdWx0c2AgLyBgZXJyYCBwcm9wZXJ0aWVzLlxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gIC8vIE9uIHN1Y2Nlc3MgLSBqb2luXG4gIGlmIChzdGF0dXMgPT09IFpfT0spIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXN1bHQgPSB1dGlscy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5jaHVua3MgPSBbXTtcbiAgdGhpcy5lcnIgPSBzdGF0dXM7XG4gIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbn07XG5cblxuLyoqXG4gKiBkZWZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDb21wcmVzcyBgZGF0YWAgd2l0aCBkZWZsYXRlIGFsZ29yaXRobSBhbmQgYG9wdGlvbnNgLlxuICpcbiAqIFN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAtIGxldmVsXG4gKiAtIHdpbmRvd0JpdHNcbiAqIC0gbWVtTGV2ZWxcbiAqIC0gc3RyYXRlZ3lcbiAqIC0gZGljdGlvbmFyeVxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIFN1Z2FyIChvcHRpb25zKTpcbiAqXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIHNheSB0aGF0IHdlIHdvcmsgd2l0aCByYXcgc3RyZWFtLCBpZiB5b3UgZG9uJ3Qgd2lzaCB0byBzcGVjaWZ5XG4gKiAgIG5lZ2F0aXZlIHdpbmRvd0JpdHMgaW1wbGljaXRseS5cbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIFwiYmluYXJ5IHN0cmluZ1wiXG4gKiAgICAoZWFjaCBjaGFyIGNvZGUgWzAuLjI1NV0pXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGRhdGEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pO1xuICpcbiAqIGNvbnNvbGUubG9nKHBha28uZGVmbGF0ZShkYXRhKSk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIGRlZmxhdG9yID0gbmV3IERlZmxhdGUob3B0aW9ucyk7XG5cbiAgZGVmbGF0b3IucHVzaChpbnB1dCwgdHJ1ZSk7XG5cbiAgLy8gVGhhdCB3aWxsIG5ldmVyIGhhcHBlbnMsIGlmIHlvdSBkb24ndCBjaGVhdCB3aXRoIG9wdGlvbnMgOilcbiAgaWYgKGRlZmxhdG9yLmVycikgeyB0aHJvdyBkZWZsYXRvci5tc2cgfHwgbXNnW2RlZmxhdG9yLmVycl07IH1cblxuICByZXR1cm4gZGVmbGF0b3IucmVzdWx0O1xufVxuXG5cbi8qKlxuICogZGVmbGF0ZVJhdyhkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGVzIHJhdyBkYXRhLCB3aXRob3V0IHdyYXBwZXJcbiAqIChoZWFkZXIgYW5kIGFkbGVyMzIgY3JjKS5cbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGVSYXcoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbi8qKlxuICogZ3ppcChkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgb2ZcbiAqIGRlZmxhdGUgb25lLlxuICoqL1xuZnVuY3Rpb24gZ3ppcChpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5nemlwID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbmV4cG9ydHMuRGVmbGF0ZSA9IERlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGUgPSBkZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlUmF3ID0gZGVmbGF0ZVJhdztcbmV4cG9ydHMuZ3ppcCA9IGd6aXA7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/pako/lib/deflate.js\n");

/***/ }),

/***/ "./node_modules/pako/lib/inflate.js":
/*!******************************************!*\
  !*** ./node_modules/pako/lib/inflate.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar zlib_inflate = __webpack_require__(/*! ./zlib/inflate */ \"./node_modules/pako/lib/zlib/inflate.js\");\n\nvar utils = __webpack_require__(/*! ./utils/common */ \"./node_modules/pako/lib/utils/common.js\");\n\nvar strings = __webpack_require__(/*! ./utils/strings */ \"./node_modules/pako/lib/utils/strings.js\");\n\nvar c = __webpack_require__(/*! ./zlib/constants */ \"./node_modules/pako/lib/zlib/constants.js\");\n\nvar msg = __webpack_require__(/*! ./zlib/messages */ \"./node_modules/pako/lib/zlib/messages.js\");\n\nvar ZStream = __webpack_require__(/*! ./zlib/zstream */ \"./node_modules/pako/lib/zlib/zstream.js\");\n\nvar GZheader = __webpack_require__(/*! ./zlib/gzheader */ \"./node_modules/pako/lib/zlib/gzheader.js\");\n\nvar toString = Object.prototype.toString;\n/**\n * class Inflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[inflate]]\n * and [[inflateRaw]].\n **/\n\n/* internal\n * inflate.chunks -> Array\n *\n * Chunks of output data, if [[Inflate#onData]] not overridden.\n **/\n\n/**\n * Inflate.result -> Uint8Array|Array|String\n *\n * Uncompressed result, generated by default [[Inflate#onData]]\n * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you\n * push a chunk with explicit flush (call [[Inflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Inflate.err -> Number\n *\n * Error code after inflate finished. 0 (Z_OK) on success.\n * Should be checked if broken data possible.\n **/\n\n/**\n * Inflate.msg -> String\n *\n * Error message, if [[Inflate.err]] != 0\n **/\n\n/**\n * new Inflate(options)\n * - options (Object): zlib inflate options.\n *\n * Creates new inflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `windowBits`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw inflate\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n * By default, when no options set, autodetect deflate/gzip data format via\n * wrapper header.\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var inflate = new pako.Inflate({ level: 3});\n *\n * inflate.push(chunk1, false);\n * inflate.push(chunk2, true);  // true -> last chunk\n *\n * if (inflate.err) { throw new Error(inflate.err); }\n *\n * console.log(inflate.result);\n * ```\n **/\n\nfunction Inflate(options) {\n  if (!(this instanceof Inflate)) return new Inflate(options);\n  this.options = utils.assign({\n    chunkSize: 16384,\n    windowBits: 0,\n    to: ''\n  }, options || {});\n  var opt = this.options; // Force window size for `raw` data, if not set directly,\n  // because we have no header for autodetect.\n\n  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {\n    opt.windowBits = -opt.windowBits;\n\n    if (opt.windowBits === 0) {\n      opt.windowBits = -15;\n    }\n  } // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate\n\n\n  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {\n    opt.windowBits += 32;\n  } // Gzip header has no info about windows size, we can do autodetect only\n  // for deflate. So, if window size not set, force it to max when gzip possible\n\n\n  if (opt.windowBits > 15 && opt.windowBits < 48) {\n    // bit 3 (16) -> gzipped data\n    // bit 4 (32) -> autodetect gzip/deflate\n    if ((opt.windowBits & 15) === 0) {\n      opt.windowBits |= 15;\n    }\n  }\n\n  this.err = 0; // error code, if happens (0 = Z_OK)\n\n  this.msg = ''; // error message\n\n  this.ended = false; // used to avoid multiple onEnd() calls\n\n  this.chunks = []; // chunks of compressed data\n\n  this.strm = new ZStream();\n  this.strm.avail_out = 0;\n  var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);\n\n  if (status !== c.Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  this.header = new GZheader();\n  zlib_inflate.inflateGetHeader(this.strm, this.header);\n}\n/**\n * Inflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n * new output chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the decompression context.\n *\n * On fail call [[Inflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\n\n\nInflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var dictionary = this.options.dictionary;\n\n  var status, _mode;\n\n  var next_out_utf8, tail, utf8str;\n  var dict; // Flag to properly process Z_BUF_ERROR on testing inflate call\n  // when we check that all output data was flushed.\n\n  var allowBufError = false;\n\n  if (this.ended) {\n    return false;\n  }\n\n  _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH; // Convert data if needed\n\n  if (typeof data === 'string') {\n    // Only binary strings can be decompressed on practice\n    strm.input = strings.binstring2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);\n    /* no bad return value */\n\n    if (status === c.Z_NEED_DICT && dictionary) {\n      // Convert data if needed\n      if (typeof dictionary === 'string') {\n        dict = strings.string2buf(dictionary);\n      } else if (toString.call(dictionary) === '[object ArrayBuffer]') {\n        dict = new Uint8Array(dictionary);\n      } else {\n        dict = dictionary;\n      }\n\n      status = zlib_inflate.inflateSetDictionary(this.strm, dict);\n    }\n\n    if (status === c.Z_BUF_ERROR && allowBufError === true) {\n      status = c.Z_OK;\n      allowBufError = false;\n    }\n\n    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n\n    if (strm.next_out) {\n      if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {\n        if (this.options.to === 'string') {\n          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n          tail = strm.next_out - next_out_utf8;\n          utf8str = strings.buf2string(strm.output, next_out_utf8); // move tail\n\n          strm.next_out = tail;\n          strm.avail_out = chunkSize - tail;\n\n          if (tail) {\n            utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);\n          }\n\n          this.onData(utf8str);\n        } else {\n          this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n        }\n      }\n    } // When no more input data, we should check that internal inflate buffers\n    // are flushed. The only way to do it when avail_out = 0 - run one more\n    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.\n    // Here we set flag to process this error properly.\n    //\n    // NOTE. Deflate does not return error in this case and does not needs such\n    // logic.\n\n\n    if (strm.avail_in === 0 && strm.avail_out === 0) {\n      allowBufError = true;\n    }\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);\n\n  if (status === c.Z_STREAM_END) {\n    _mode = c.Z_FINISH;\n  } // Finalize on the last chunk.\n\n\n  if (_mode === c.Z_FINISH) {\n    status = zlib_inflate.inflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === c.Z_OK;\n  } // callback interim results if Z_SYNC_FLUSH.\n\n\n  if (_mode === c.Z_SYNC_FLUSH) {\n    this.onEnd(c.Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n/**\n * Inflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\n\n\nInflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n/**\n * Inflate#onEnd(status) -> Void\n * - status (Number): inflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called either after you tell inflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\n\n\nInflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === c.Z_OK) {\n    if (this.options.to === 'string') {\n      // Glue & convert here, until we teach pako to send\n      // utf8 aligned strings to onData\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n/**\n * inflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Decompress `data` with inflate/ungzip and `options`. Autodetect\n * format via wrapper header by default. That's why we don't provide\n * separate `ungzip` method.\n *\n * Supported options are:\n *\n * - windowBits\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])\n *   , output;\n *\n * try {\n *   output = pako.inflate(input);\n * } catch (err)\n *   console.log(err);\n * }\n * ```\n **/\n\n\nfunction inflate(input, options) {\n  var inflator = new Inflate(options);\n  inflator.push(input, true); // That will never happens, if you don't cheat with options :)\n\n  if (inflator.err) {\n    throw inflator.msg || msg[inflator.err];\n  }\n\n  return inflator.result;\n}\n/**\n * inflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * The same as [[inflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\n\n\nfunction inflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return inflate(input, options);\n}\n/**\n * ungzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Just shortcut to [[inflate]], because it autodetects format\n * by header.content. Done for convenience.\n **/\n\n\nexports.Inflate = Inflate;\nexports.inflate = inflate;\nexports.inflateRaw = inflateRaw;\nexports.ungzip = inflate;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvaW5mbGF0ZS5qcz83MTdlIl0sIm5hbWVzIjpbInpsaWJfaW5mbGF0ZSIsInV0aWxzIiwic3RyaW5ncyIsImMiLCJtc2ciLCJaU3RyZWFtIiwiR1poZWFkZXIiLCJ0b1N0cmluZyIsIk9iamVjdCIsInByb3RvdHlwZSIsIkluZmxhdGUiLCJvcHRpb25zIiwiYXNzaWduIiwiY2h1bmtTaXplIiwid2luZG93Qml0cyIsInRvIiwib3B0IiwicmF3IiwiZXJyIiwiZW5kZWQiLCJjaHVua3MiLCJzdHJtIiwiYXZhaWxfb3V0Iiwic3RhdHVzIiwiaW5mbGF0ZUluaXQyIiwiWl9PSyIsIkVycm9yIiwiaGVhZGVyIiwiaW5mbGF0ZUdldEhlYWRlciIsInB1c2giLCJkYXRhIiwibW9kZSIsImRpY3Rpb25hcnkiLCJfbW9kZSIsIm5leHRfb3V0X3V0ZjgiLCJ0YWlsIiwidXRmOHN0ciIsImRpY3QiLCJhbGxvd0J1ZkVycm9yIiwiWl9GSU5JU0giLCJaX05PX0ZMVVNIIiwiaW5wdXQiLCJiaW5zdHJpbmcyYnVmIiwiY2FsbCIsIlVpbnQ4QXJyYXkiLCJuZXh0X2luIiwiYXZhaWxfaW4iLCJsZW5ndGgiLCJvdXRwdXQiLCJCdWY4IiwibmV4dF9vdXQiLCJpbmZsYXRlIiwiWl9ORUVEX0RJQ1QiLCJzdHJpbmcyYnVmIiwiaW5mbGF0ZVNldERpY3Rpb25hcnkiLCJaX0JVRl9FUlJPUiIsIlpfU1RSRUFNX0VORCIsIm9uRW5kIiwiWl9TWU5DX0ZMVVNIIiwidXRmOGJvcmRlciIsImJ1ZjJzdHJpbmciLCJhcnJheVNldCIsIm9uRGF0YSIsInNocmlua0J1ZiIsImluZmxhdGVFbmQiLCJjaHVuayIsInJlc3VsdCIsImpvaW4iLCJmbGF0dGVuQ2h1bmtzIiwiaW5mbGF0b3IiLCJpbmZsYXRlUmF3IiwiZXhwb3J0cyIsInVuZ3ppcCJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBR0EsSUFBSUEsWUFBWSxHQUFHLG1CQUFPLENB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LElBQVQsQ0FBY1ksS0FBZCxFQUFxQixJQUFyQixFQUgrQixDQUsvQjs7QUFDQSxNQUFJNEIsUUFBUSxDQUFDbkQsR0FBYixFQUFrQjtBQUFFLFVBQU1tRCxRQUFRLENBQUNqRSxHQUFULElBQWdCQSxHQUFHLENBQUNpRSxRQUFRLENBQUNuRCxHQUFWLENBQXpCO0FBQTBDOztBQUU5RCxTQUFPbUQsUUFBUSxDQUFDSCxNQUFoQjtBQUNEO0FBR0Q7Ozs7Ozs7Ozs7QUFRQSxTQUFTSSxVQUFULENBQW9CN0IsS0FBcEIsRUFBMkI5QixPQUEzQixFQUFvQztBQUNsQ0EsU0FBTyxHQUFHQSxPQUFPLElBQUksRUFBckI7QUFDQUEsU0FBTyxDQUFDTSxHQUFSLEdBQWMsSUFBZDtBQUNBLFNBQU9rQyxPQUFPLENBQUNWLEtBQUQsRUFBUTlCLE9BQVIsQ0FBZDtBQUNEO0FBR0Q7Ozs7Ozs7Ozs7QUFVQTRELE9BQU8sQ0FBQzdELE9BQVIsR0FBa0JBLE9BQWxCO0FBQ0E2RCxPQUFPLENBQUNwQixPQUFSLEdBQWtCQSxPQUFsQjtBQUNBb0IsT0FBTyxDQUFDRCxVQUFSLEdBQXFCQSxVQUFyQjtBQUNBQyxPQUFPLENBQUNDLE1BQVIsR0FBa0JyQixPQUFsQiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9wYWtvL2xpYi9pbmZsYXRlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB6bGliX2luZmxhdGUgPSByZXF1aXJlKCcuL3psaWIvaW5mbGF0ZScpO1xudmFyIHV0aWxzICAgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvY29tbW9uJyk7XG52YXIgc3RyaW5ncyAgICAgID0gcmVxdWlyZSgnLi91dGlscy9zdHJpbmdzJyk7XG52YXIgYyAgICAgICAgICAgID0gcmVxdWlyZSgnLi96bGliL2NvbnN0YW50cycpO1xudmFyIG1zZyAgICAgICAgICA9IHJlcXVpcmUoJy4vemxpYi9tZXNzYWdlcycpO1xudmFyIFpTdHJlYW0gICAgICA9IHJlcXVpcmUoJy4vemxpYi96c3RyZWFtJyk7XG52YXIgR1poZWFkZXIgICAgID0gcmVxdWlyZSgnLi96bGliL2d6aGVhZGVyJyk7XG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogY2xhc3MgSW5mbGF0ZVxuICpcbiAqIEdlbmVyaWMgSlMtc3R5bGUgd3JhcHBlciBmb3IgemxpYiBjYWxscy4gSWYgeW91IGRvbid0IG5lZWRcbiAqIHN0cmVhbWluZyBiZWhhdmlvdXIgLSB1c2UgbW9yZSBzaW1wbGUgZnVuY3Rpb25zOiBbW2luZmxhdGVdXVxuICogYW5kIFtbaW5mbGF0ZVJhd11dLlxuICoqL1xuXG4vKiBpbnRlcm5hbFxuICogaW5mbGF0ZS5jaHVua3MgLT4gQXJyYXlcbiAqXG4gKiBDaHVua3Mgb2Ygb3V0cHV0IGRhdGEsIGlmIFtbSW5mbGF0ZSNvbkRhdGFdXSBub3Qgb3ZlcnJpZGRlbi5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLnJlc3VsdCAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICpcbiAqIFVuY29tcHJlc3NlZCByZXN1bHQsIGdlbmVyYXRlZCBieSBkZWZhdWx0IFtbSW5mbGF0ZSNvbkRhdGFdXVxuICogYW5kIFtbSW5mbGF0ZSNvbkVuZF1dIGhhbmRsZXJzLiBGaWxsZWQgYWZ0ZXIgeW91IHB1c2ggbGFzdCBjaHVua1xuICogKGNhbGwgW1tJbmZsYXRlI3B1c2hdXSB3aXRoIGBaX0ZJTklTSGAgLyBgdHJ1ZWAgcGFyYW0pIG9yIGlmIHlvdVxuICogcHVzaCBhIGNodW5rIHdpdGggZXhwbGljaXQgZmx1c2ggKGNhbGwgW1tJbmZsYXRlI3B1c2hdXSB3aXRoXG4gKiBgWl9TWU5DX0ZMVVNIYCBwYXJhbSkuXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5lcnIgLT4gTnVtYmVyXG4gKlxuICogRXJyb3IgY29kZSBhZnRlciBpbmZsYXRlIGZpbmlzaGVkLiAwIChaX09LKSBvbiBzdWNjZXNzLlxuICogU2hvdWxkIGJlIGNoZWNrZWQgaWYgYnJva2VuIGRhdGEgcG9zc2libGUuXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5tc2cgLT4gU3RyaW5nXG4gKlxuICogRXJyb3IgbWVzc2FnZSwgaWYgW1tJbmZsYXRlLmVycl1dICE9IDBcbiAqKi9cblxuXG4vKipcbiAqIG5ldyBJbmZsYXRlKG9wdGlvbnMpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIENyZWF0ZXMgbmV3IGluZmxhdG9yIGluc3RhbmNlIHdpdGggc3BlY2lmaWVkIHBhcmFtcy4gVGhyb3dzIGV4Y2VwdGlvblxuICogb24gYmFkIHBhcmFtcy4gU3VwcG9ydGVkIG9wdGlvbnM6XG4gKlxuICogLSBgd2luZG93Qml0c2BcbiAqIC0gYGRpY3Rpb25hcnlgXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogQWRkaXRpb25hbCBvcHRpb25zLCBmb3IgaW50ZXJuYWwgbmVlZHM6XG4gKlxuICogLSBgY2h1bmtTaXplYCAtIHNpemUgb2YgZ2VuZXJhdGVkIGRhdGEgY2h1bmtzICgxNksgYnkgZGVmYXVsdClcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gZG8gcmF3IGluZmxhdGVcbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIGNvbnZlcnRlZFxuICogICBmcm9tIHV0ZjggdG8gdXRmMTYgKGphdmFzY3JpcHQpIHN0cmluZy4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCxcbiAqICAgY2h1bmsgbGVuZ3RoIGNhbiBkaWZmZXIgZnJvbSBgY2h1bmtTaXplYCwgZGVwZW5kaW5nIG9uIGNvbnRlbnQuXG4gKlxuICogQnkgZGVmYXVsdCwgd2hlbiBubyBvcHRpb25zIHNldCwgYXV0b2RldGVjdCBkZWZsYXRlL2d6aXAgZGF0YSBmb3JtYXQgdmlhXG4gKiB3cmFwcGVyIGhlYWRlci5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgY2h1bmsxID0gVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKVxuICogICAsIGNodW5rMiA9IFVpbnQ4QXJyYXkoWzEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5XSk7XG4gKlxuICogdmFyIGluZmxhdGUgPSBuZXcgcGFrby5JbmZsYXRlKHsgbGV2ZWw6IDN9KTtcbiAqXG4gKiBpbmZsYXRlLnB1c2goY2h1bmsxLCBmYWxzZSk7XG4gKiBpbmZsYXRlLnB1c2goY2h1bmsyLCB0cnVlKTsgIC8vIHRydWUgLT4gbGFzdCBjaHVua1xuICpcbiAqIGlmIChpbmZsYXRlLmVycikgeyB0aHJvdyBuZXcgRXJyb3IoaW5mbGF0ZS5lcnIpOyB9XG4gKlxuICogY29uc29sZS5sb2coaW5mbGF0ZS5yZXN1bHQpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBJbmZsYXRlKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEluZmxhdGUpKSByZXR1cm4gbmV3IEluZmxhdGUob3B0aW9ucyk7XG5cbiAgdGhpcy5vcHRpb25zID0gdXRpbHMuYXNzaWduKHtcbiAgICBjaHVua1NpemU6IDE2Mzg0LFxuICAgIHdpbmRvd0JpdHM6IDAsXG4gICAgdG86ICcnXG4gIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gIHZhciBvcHQgPSB0aGlzLm9wdGlvbnM7XG5cbiAgLy8gRm9yY2Ugd2luZG93IHNpemUgZm9yIGByYXdgIGRhdGEsIGlmIG5vdCBzZXQgZGlyZWN0bHksXG4gIC8vIGJlY2F1c2Ugd2UgaGF2ZSBubyBoZWFkZXIgZm9yIGF1dG9kZXRlY3QuXG4gIGlmIChvcHQucmF3ICYmIChvcHQud2luZG93Qml0cyA+PSAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikpIHtcbiAgICBvcHQud2luZG93Qml0cyA9IC1vcHQud2luZG93Qml0cztcbiAgICBpZiAob3B0LndpbmRvd0JpdHMgPT09IDApIHsgb3B0LndpbmRvd0JpdHMgPSAtMTU7IH1cbiAgfVxuXG4gIC8vIElmIGB3aW5kb3dCaXRzYCBub3QgZGVmaW5lZCAoYW5kIG1vZGUgbm90IHJhdykgLSBzZXQgYXV0b2RldGVjdCBmbGFnIGZvciBnemlwL2RlZmxhdGVcbiAgaWYgKChvcHQud2luZG93Qml0cyA+PSAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikgJiZcbiAgICAgICEob3B0aW9ucyAmJiBvcHRpb25zLndpbmRvd0JpdHMpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgKz0gMzI7XG4gIH1cblxuICAvLyBHemlwIGhlYWRlciBoYXMgbm8gaW5mbyBhYm91dCB3aW5kb3dzIHNpemUsIHdlIGNhbiBkbyBhdXRvZGV0ZWN0IG9ubHlcbiAgLy8gZm9yIGRlZmxhdGUuIFNvLCBpZiB3aW5kb3cgc2l6ZSBub3Qgc2V0LCBmb3JjZSBpdCB0byBtYXggd2hlbiBnemlwIHBvc3NpYmxlXG4gIGlmICgob3B0LndpbmRvd0JpdHMgPiAxNSkgJiYgKG9wdC53aW5kb3dCaXRzIDwgNDgpKSB7XG4gICAgLy8gYml0IDMgKDE2KSAtPiBnemlwcGVkIGRhdGFcbiAgICAvLyBiaXQgNCAoMzIpIC0+IGF1dG9kZXRlY3QgZ3ppcC9kZWZsYXRlXG4gICAgaWYgKChvcHQud2luZG93Qml0cyAmIDE1KSA9PT0gMCkge1xuICAgICAgb3B0LndpbmRvd0JpdHMgfD0gMTU7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5lcnIgICAgPSAwOyAgICAgIC8vIGVycm9yIGNvZGUsIGlmIGhhcHBlbnMgKDAgPSBaX09LKVxuICB0aGlzLm1zZyAgICA9ICcnOyAgICAgLy8gZXJyb3IgbWVzc2FnZVxuICB0aGlzLmVuZGVkICA9IGZhbHNlOyAgLy8gdXNlZCB0byBhdm9pZCBtdWx0aXBsZSBvbkVuZCgpIGNhbGxzXG4gIHRoaXMuY2h1bmtzID0gW107ICAgICAvLyBjaHVua3Mgb2YgY29tcHJlc3NlZCBkYXRhXG5cbiAgdGhpcy5zdHJtICAgPSBuZXcgWlN0cmVhbSgpO1xuICB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDtcblxuICB2YXIgc3RhdHVzICA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlSW5pdDIoXG4gICAgdGhpcy5zdHJtLFxuICAgIG9wdC53aW5kb3dCaXRzXG4gICk7XG5cbiAgaWYgKHN0YXR1cyAhPT0gYy5aX09LKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgfVxuXG4gIHRoaXMuaGVhZGVyID0gbmV3IEdaaGVhZGVyKCk7XG5cbiAgemxpYl9pbmZsYXRlLmluZmxhdGVHZXRIZWFkZXIodGhpcy5zdHJtLCB0aGlzLmhlYWRlcik7XG59XG5cbi8qKlxuICogSW5mbGF0ZSNwdXNoKGRhdGFbLCBtb2RlXSkgLT4gQm9vbGVhblxuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fEFycmF5QnVmZmVyfFN0cmluZyk6IGlucHV0IGRhdGFcbiAqIC0gbW9kZSAoTnVtYmVyfEJvb2xlYW4pOiAwLi42IGZvciBjb3JyZXNwb25kaW5nIFpfTk9fRkxVU0guLlpfVFJFRSBtb2Rlcy5cbiAqICAgU2VlIGNvbnN0YW50cy4gU2tpcHBlZCBvciBgZmFsc2VgIG1lYW5zIFpfTk9fRkxVU0gsIGB0cnVlYCBtZWFucyBaX0ZJTklTSC5cbiAqXG4gKiBTZW5kcyBpbnB1dCBkYXRhIHRvIGluZmxhdGUgcGlwZSwgZ2VuZXJhdGluZyBbW0luZmxhdGUjb25EYXRhXV0gY2FsbHMgd2l0aFxuICogbmV3IG91dHB1dCBjaHVua3MuIFJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3MuIFRoZSBsYXN0IGRhdGEgYmxvY2sgbXVzdCBoYXZlXG4gKiBtb2RlIFpfRklOSVNIIChvciBgdHJ1ZWApLiBUaGF0IHdpbGwgZmx1c2ggaW50ZXJuYWwgcGVuZGluZyBidWZmZXJzIGFuZCBjYWxsXG4gKiBbW0luZmxhdGUjb25FbmRdXS4gRm9yIGludGVyaW0gZXhwbGljaXQgZmx1c2hlcyAod2l0aG91dCBlbmRpbmcgdGhlIHN0cmVhbSkgeW91XG4gKiBjYW4gdXNlIG1vZGUgWl9TWU5DX0ZMVVNILCBrZWVwaW5nIHRoZSBkZWNvbXByZXNzaW9uIGNvbnRleHQuXG4gKlxuICogT24gZmFpbCBjYWxsIFtbSW5mbGF0ZSNvbkVuZF1dIHdpdGggZXJyb3IgY29kZSBhbmQgcmV0dXJuIGZhbHNlLlxuICpcbiAqIFdlIHN0cm9uZ2x5IHJlY29tbWVuZCB0byB1c2UgYFVpbnQ4QXJyYXlgIG9uIGlucHV0IGZvciBiZXN0IHNwZWVkIChvdXRwdXRcbiAqIGZvcm1hdCBpcyBkZXRlY3RlZCBhdXRvbWF0aWNhbGx5KS4gQWxzbywgZG9uJ3Qgc2tpcCBsYXN0IHBhcmFtIGFuZCBhbHdheXNcbiAqIHVzZSB0aGUgc2FtZSB0eXBlIGluIHlvdXIgY29kZSAoYm9vbGVhbiBvciBudW1iZXIpLiBUaGF0IHdpbGwgaW1wcm92ZSBKUyBzcGVlZC5cbiAqXG4gKiBGb3IgcmVndWxhciBgQXJyYXlgLXMgbWFrZSBzdXJlIGFsbCBlbGVtZW50cyBhcmUgWzAuLjI1NV0uXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHB1c2goY2h1bmssIGZhbHNlKTsgLy8gcHVzaCBvbmUgb2YgZGF0YSBjaHVua3NcbiAqIC4uLlxuICogcHVzaChjaHVuaywgdHJ1ZSk7ICAvLyBwdXNoIGxhc3QgY2h1bmtcbiAqIGBgYFxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBtb2RlKSB7XG4gIHZhciBzdHJtID0gdGhpcy5zdHJtO1xuICB2YXIgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgdmFyIGRpY3Rpb25hcnkgPSB0aGlzLm9wdGlvbnMuZGljdGlvbmFyeTtcbiAgdmFyIHN0YXR1cywgX21vZGU7XG4gIHZhciBuZXh0X291dF91dGY4LCB0YWlsLCB1dGY4c3RyO1xuICB2YXIgZGljdDtcblxuICAvLyBGbGFnIHRvIHByb3Blcmx5IHByb2Nlc3MgWl9CVUZfRVJST1Igb24gdGVzdGluZyBpbmZsYXRlIGNhbGxcbiAgLy8gd2hlbiB3ZSBjaGVjayB0aGF0IGFsbCBvdXRwdXQgZGF0YSB3YXMgZmx1c2hlZC5cbiAgdmFyIGFsbG93QnVmRXJyb3IgPSBmYWxzZTtcblxuICBpZiAodGhpcy5lbmRlZCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgX21vZGUgPSAobW9kZSA9PT0gfn5tb2RlKSA/IG1vZGUgOiAoKG1vZGUgPT09IHRydWUpID8gYy5aX0ZJTklTSCA6IGMuWl9OT19GTFVTSCk7XG5cbiAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gT25seSBiaW5hcnkgc3RyaW5ncyBjYW4gYmUgZGVjb21wcmVzc2VkIG9uIHByYWN0aWNlXG4gICAgc3RybS5pbnB1dCA9IHN0cmluZ3MuYmluc3RyaW5nMmJ1ZihkYXRhKTtcbiAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKGRhdGEpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgc3RybS5pbnB1dCA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHN0cm0uaW5wdXQgPSBkYXRhO1xuICB9XG5cbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5hdmFpbF9pbiA9IHN0cm0uaW5wdXQubGVuZ3RoO1xuXG4gIGRvIHtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHN0cm0ub3V0cHV0ID0gbmV3IHV0aWxzLkJ1ZjgoY2h1bmtTaXplKTtcbiAgICAgIHN0cm0ubmV4dF9vdXQgPSAwO1xuICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemU7XG4gICAgfVxuXG4gICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGUoc3RybSwgYy5aX05PX0ZMVVNIKTsgICAgLyogbm8gYmFkIHJldHVybiB2YWx1ZSAqL1xuXG4gICAgaWYgKHN0YXR1cyA9PT0gYy5aX05FRURfRElDVCAmJiBkaWN0aW9uYXJ5KSB7XG4gICAgICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gICAgICBpZiAodHlwZW9mIGRpY3Rpb25hcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRpY3QgPSBzdHJpbmdzLnN0cmluZzJidWYoZGljdGlvbmFyeSk7XG4gICAgICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwoZGljdGlvbmFyeSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICAgICAgZGljdCA9IG5ldyBVaW50OEFycmF5KGRpY3Rpb25hcnkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGljdCA9IGRpY3Rpb25hcnk7XG4gICAgICB9XG5cbiAgICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3QpO1xuXG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gYy5aX0JVRl9FUlJPUiAmJiBhbGxvd0J1ZkVycm9yID09PSB0cnVlKSB7XG4gICAgICBzdGF0dXMgPSBjLlpfT0s7XG4gICAgICBhbGxvd0J1ZkVycm9yID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyAhPT0gYy5aX1NUUkVBTV9FTkQgJiYgc3RhdHVzICE9PSBjLlpfT0spIHtcbiAgICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzdHJtLm5leHRfb3V0KSB7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDAgfHwgc3RhdHVzID09PSBjLlpfU1RSRUFNX0VORCB8fCAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiAoX21vZGUgPT09IGMuWl9GSU5JU0ggfHwgX21vZGUgPT09IGMuWl9TWU5DX0ZMVVNIKSkpIHtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgbmV4dF9vdXRfdXRmOCA9IHN0cmluZ3MudXRmOGJvcmRlcihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCk7XG5cbiAgICAgICAgICB0YWlsID0gc3RybS5uZXh0X291dCAtIG5leHRfb3V0X3V0Zjg7XG4gICAgICAgICAgdXRmOHN0ciA9IHN0cmluZ3MuYnVmMnN0cmluZyhzdHJtLm91dHB1dCwgbmV4dF9vdXRfdXRmOCk7XG5cbiAgICAgICAgICAvLyBtb3ZlIHRhaWxcbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gdGFpbDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZSAtIHRhaWw7XG4gICAgICAgICAgaWYgKHRhaWwpIHsgdXRpbHMuYXJyYXlTZXQoc3RybS5vdXRwdXQsIHN0cm0ub3V0cHV0LCBuZXh0X291dF91dGY4LCB0YWlsLCAwKTsgfVxuXG4gICAgICAgICAgdGhpcy5vbkRhdGEodXRmOHN0cik7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9uRGF0YSh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdoZW4gbm8gbW9yZSBpbnB1dCBkYXRhLCB3ZSBzaG91bGQgY2hlY2sgdGhhdCBpbnRlcm5hbCBpbmZsYXRlIGJ1ZmZlcnNcbiAgICAvLyBhcmUgZmx1c2hlZC4gVGhlIG9ubHkgd2F5IHRvIGRvIGl0IHdoZW4gYXZhaWxfb3V0ID0gMCAtIHJ1biBvbmUgbW9yZVxuICAgIC8vIGluZmxhdGUgcGFzcy4gQnV0IGlmIG91dHB1dCBkYXRhIG5vdCBleGlzdHMsIGluZmxhdGUgcmV0dXJuIFpfQlVGX0VSUk9SLlxuICAgIC8vIEhlcmUgd2Ugc2V0IGZsYWcgdG8gcHJvY2VzcyB0aGlzIGVycm9yIHByb3Blcmx5LlxuICAgIC8vXG4gICAgLy8gTk9URS4gRGVmbGF0ZSBkb2VzIG5vdCByZXR1cm4gZXJyb3IgaW4gdGhpcyBjYXNlIGFuZCBkb2VzIG5vdCBuZWVkcyBzdWNoXG4gICAgLy8gbG9naWMuXG4gICAgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIGFsbG93QnVmRXJyb3IgPSB0cnVlO1xuICAgIH1cblxuICB9IHdoaWxlICgoc3RybS5hdmFpbF9pbiA+IDAgfHwgc3RybS5hdmFpbF9vdXQgPT09IDApICYmIHN0YXR1cyAhPT0gYy5aX1NUUkVBTV9FTkQpO1xuXG4gIGlmIChzdGF0dXMgPT09IGMuWl9TVFJFQU1fRU5EKSB7XG4gICAgX21vZGUgPSBjLlpfRklOSVNIO1xuICB9XG5cbiAgLy8gRmluYWxpemUgb24gdGhlIGxhc3QgY2h1bmsuXG4gIGlmIChfbW9kZSA9PT0gYy5aX0ZJTklTSCkge1xuICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlRW5kKHRoaXMuc3RybSk7XG4gICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgIHJldHVybiBzdGF0dXMgPT09IGMuWl9PSztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGludGVyaW0gcmVzdWx0cyBpZiBaX1NZTkNfRkxVU0guXG4gIGlmIChfbW9kZSA9PT0gYy5aX1NZTkNfRkxVU0gpIHtcbiAgICB0aGlzLm9uRW5kKGMuWl9PSyk7XG4gICAgc3RybS5hdmFpbF9vdXQgPSAwO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogSW5mbGF0ZSNvbkRhdGEoY2h1bmspIC0+IFZvaWRcbiAqIC0gY2h1bmsgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogb3V0cHV0IGRhdGEuIFR5cGUgb2YgYXJyYXkgZGVwZW5kc1xuICogICBvbiBqcyBlbmdpbmUgc3VwcG9ydC4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCwgZWFjaCBjaHVua1xuICogICB3aWxsIGJlIHN0cmluZy5cbiAqXG4gKiBCeSBkZWZhdWx0LCBzdG9yZXMgZGF0YSBibG9ja3MgaW4gYGNodW5rc1tdYCBwcm9wZXJ0eSBhbmQgZ2x1ZVxuICogdGhvc2UgaW4gYG9uRW5kYC4gT3ZlcnJpZGUgdGhpcyBoYW5kbGVyLCBpZiB5b3UgbmVlZCBhbm90aGVyIGJlaGF2aW91ci5cbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbn07XG5cblxuLyoqXG4gKiBJbmZsYXRlI29uRW5kKHN0YXR1cykgLT4gVm9pZFxuICogLSBzdGF0dXMgKE51bWJlcik6IGluZmxhdGUgc3RhdHVzLiAwIChaX09LKSBvbiBzdWNjZXNzLFxuICogICBvdGhlciBpZiBub3QuXG4gKlxuICogQ2FsbGVkIGVpdGhlciBhZnRlciB5b3UgdGVsbCBpbmZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpc1xuICogY29tcGxldGUgKFpfRklOSVNIKSBvciBzaG91bGQgYmUgZmx1c2hlZCAoWl9TWU5DX0ZMVVNIKVxuICogb3IgaWYgYW4gZXJyb3IgaGFwcGVuZWQuIEJ5IGRlZmF1bHQgLSBqb2luIGNvbGxlY3RlZCBjaHVua3MsXG4gKiBmcmVlIG1lbW9yeSBhbmQgZmlsbCBgcmVzdWx0c2AgLyBgZXJyYCBwcm9wZXJ0aWVzLlxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gIC8vIE9uIHN1Y2Nlc3MgLSBqb2luXG4gIGlmIChzdGF0dXMgPT09IGMuWl9PSykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBHbHVlICYgY29udmVydCBoZXJlLCB1bnRpbCB3ZSB0ZWFjaCBwYWtvIHRvIHNlbmRcbiAgICAgIC8vIHV0ZjggYWxpZ25lZCBzdHJpbmdzIHRvIG9uRGF0YVxuICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXN1bHQgPSB1dGlscy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5jaHVua3MgPSBbXTtcbiAgdGhpcy5lcnIgPSBzdGF0dXM7XG4gIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbn07XG5cblxuLyoqXG4gKiBpbmZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIERlY29tcHJlc3MgYGRhdGFgIHdpdGggaW5mbGF0ZS91bmd6aXAgYW5kIGBvcHRpb25zYC4gQXV0b2RldGVjdFxuICogZm9ybWF0IHZpYSB3cmFwcGVyIGhlYWRlciBieSBkZWZhdWx0LiBUaGF0J3Mgd2h5IHdlIGRvbid0IHByb3ZpZGVcbiAqIHNlcGFyYXRlIGB1bmd6aXBgIG1ldGhvZC5cbiAqXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogLSB3aW5kb3dCaXRzXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogU3VnYXIgKG9wdGlvbnMpOlxuICpcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gc2F5IHRoYXQgd2Ugd29yayB3aXRoIHJhdyBzdHJlYW0sIGlmIHlvdSBkb24ndCB3aXNoIHRvIHNwZWNpZnlcbiAqICAgbmVnYXRpdmUgd2luZG93Qml0cyBpbXBsaWNpdGx5LlxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgY29udmVydGVkXG4gKiAgIGZyb20gdXRmOCB0byB1dGYxNiAoamF2YXNjcmlwdCkgc3RyaW5nLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBjaHVuayBsZW5ndGggY2FuIGRpZmZlciBmcm9tIGBjaHVua1NpemVgLCBkZXBlbmRpbmcgb24gY29udGVudC5cbiAqXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGlucHV0ID0gcGFrby5kZWZsYXRlKFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgb3V0cHV0O1xuICpcbiAqIHRyeSB7XG4gKiAgIG91dHB1dCA9IHBha28uaW5mbGF0ZShpbnB1dCk7XG4gKiB9IGNhdGNoIChlcnIpXG4gKiAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGluZmxhdGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIGluZmxhdG9yID0gbmV3IEluZmxhdGUob3B0aW9ucyk7XG5cbiAgaW5mbGF0b3IucHVzaChpbnB1dCwgdHJ1ZSk7XG5cbiAgLy8gVGhhdCB3aWxsIG5ldmVyIGhhcHBlbnMsIGlmIHlvdSBkb24ndCBjaGVhdCB3aXRoIG9wdGlvbnMgOilcbiAgaWYgKGluZmxhdG9yLmVycikgeyB0aHJvdyBpbmZsYXRvci5tc2cgfHwgbXNnW2luZmxhdG9yLmVycl07IH1cblxuICByZXR1cm4gaW5mbGF0b3IucmVzdWx0O1xufVxuXG5cbi8qKlxuICogaW5mbGF0ZVJhdyhkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2luZmxhdGVdXSwgYnV0IGNyZWF0ZXMgcmF3IGRhdGEsIHdpdGhvdXQgd3JhcHBlclxuICogKGhlYWRlciBhbmQgYWRsZXIzMiBjcmMpLlxuICoqL1xuZnVuY3Rpb24gaW5mbGF0ZVJhdyhpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICByZXR1cm4gaW5mbGF0ZShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuLyoqXG4gKiB1bmd6aXAoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogSnVzdCBzaG9ydGN1dCB0byBbW2luZmxhdGVdXSwgYmVjYXVzZSBpdCBhdXRvZGV0ZWN0cyBmb3JtYXRcbiAqIGJ5IGhlYWRlci5jb250ZW50LiBEb25lIGZvciBjb252ZW5pZW5jZS5cbiAqKi9cblxuXG5leHBvcnRzLkluZmxhdGUgPSBJbmZsYXRlO1xuZXhwb3J0cy5pbmZsYXRlID0gaW5mbGF0ZTtcbmV4cG9ydHMuaW5mbGF0ZVJhdyA9IGluZmxhdGVSYXc7XG5leHBvcnRzLnVuZ3ppcCAgPSBpbmZsYXRlO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/pako/lib/inflate.js\n");

/***/ }),

/***/ "./node_modules/pako/lib/utils/common.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/utils/common.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar TYPED_OK = typeof Uint8Array !== 'undefined' && typeof Uint16Array !== 'undefined' && typeof Int32Array !== 'undefined';\n\nfunction _has(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nexports.assign = function (obj\n/*from1, from2, from3, ...*/\n) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n\n  while (sources.length) {\n    var source = sources.shift();\n\n    if (!source) {\n      continue;\n    }\n\n    if (_typeof(source) !== 'object') {\n      throw new TypeError(source + 'must be non-object');\n    }\n\n    for (var p in source) {\n      if (_has(source, p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n\n  return obj;\n}; // reduce buffer size, avoiding mem copy\n\n\nexports.shrinkBuf = function (buf, size) {\n  if (buf.length === size) {\n    return buf;\n  }\n\n  if (buf.subarray) {\n    return buf.subarray(0, size);\n  }\n\n  buf.length = size;\n  return buf;\n};\n\nvar fnTyped = {\n  arraySet: function arraySet(dest, src, src_offs, len, dest_offs) {\n    if (src.subarray && dest.subarray) {\n      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n      return;\n    } // Fallback to ordinary array\n\n\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function flattenChunks(chunks) {\n    var i, l, len, pos, chunk, result; // calculate data length\n\n    len = 0;\n\n    for (i = 0, l = chunks.length; i < l; i++) {\n      len += chunks[i].length;\n    } // join chunks\n\n\n    result = new Uint8Array(len);\n    pos = 0;\n\n    for (i = 0, l = chunks.length; i < l; i++) {\n      chunk = chunks[i];\n      result.set(chunk, pos);\n      pos += chunk.length;\n    }\n\n    return result;\n  }\n};\nvar fnUntyped = {\n  arraySet: function arraySet(dest, src, src_offs, len, dest_offs) {\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function flattenChunks(chunks) {\n    return [].concat.apply([], chunks);\n  }\n}; // Enable/Disable typed arrays use, for testing\n//\n\nexports.setTyped = function (on) {\n  if (on) {\n    exports.Buf8 = Uint8Array;\n    exports.Buf16 = Uint16Array;\n    exports.Buf32 = Int32Array;\n    exports.assign(exports, fnTyped);\n  } else {\n    exports.Buf8 = Array;\n    exports.Buf16 = Array;\n    exports.Buf32 = Array;\n    exports.assign(exports, fnUntyped);\n  }\n};\n\nexports.setTyped(TYPED_OK);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvY29tbW9uLmpzP2JlN2YiXSwibmFtZXMiOlsiVFlQRURfT0siLCJVaW50OEFycmF5IiwiVWludDE2QXJyYXkiLCJJbnQzMkFycmF5IiwiX2hhcyIsIm9iaiIsImtleSIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImV4cG9ydHMiLCJhc3NpZ24iLCJzb3VyY2VzIiwiQXJyYXkiLCJzbGljZSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsInNoaWZ0IiwiVHlwZUVycm9yIiwicCIsInNocmlua0J1ZiIsImJ1ZiIsInNpemUiLCJzdWJhcnJheSIsImZuVHlwZWQiLCJhcnJheVNldCIsImRlc3QiLCJzcmMiLCJzcmNfb2ZmcyIsImxlbiIsImRlc3Rfb2ZmcyIsInNldCIsImkiLCJmbGF0dGVuQ2h1bmtzIiwiY2h1bmtzIiwibCIsInBvcyIsImNodW5rIiwicmVzdWx0IiwiZm5VbnR5cGVkIiwiY29uY2F0IiwiYXBwbHkiLCJzZXRUeXBlZCIsIm9uIiwiQnVmOCIsIkJ1ZjE2IiwiQnVmMzIiXSwibWFwcGluZ3MiOiJBQUFBOzs7O0FBR0EsSUFBSUEsUUFBUSxHQUFLLE9BQU9DLFVBQVAsS0FBc0IsV0FBdkIsSUFDQyxPQUFPQyxXQUFQLEtBQXVCLFdBRHhCLElBRUMsT0FBT0MsVUFBUCxLQUFzQixXQUZ2Qzs7QUFJQSxTQUFTQyxJQUFULENBQWNDLEdBQWQsRUFBbUJDLEdBQW5CLEVBQXdCO0FBQ3RCLFNBQU9DLE1BQU0sQ0FBQ0MsU0FBUCxDQUFpQkMsY0FBakIsQ0FBZ0NDLElBQWhDLENBQXFDTCxHQUFyQyxFQUEwQ0MsR0FBMUMsQ0FBUDtBQUNEOztBQUVESyxPQUFPLENBQUNDLE1BQVIsR0FBaUIsVUFBVVA7QUFBSTtBQUFkLEVBQTRDO0FBQzNELE1BQUlRLE9BQU8sR0FBR0MsS0FBSyxDQUFDTixTQUFOLENBQWdCTyxLQUFoQixDQUFz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QUNpQyxRQUFSLENBQWlCNUMsUUFBakIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvY29tbW9uLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBUWVBFRF9PSyA9ICAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgVWludDE2QXJyYXkgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgSW50MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcpO1xuXG5mdW5jdGlvbiBfaGFzKG9iaiwga2V5KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuXG5leHBvcnRzLmFzc2lnbiA9IGZ1bmN0aW9uIChvYmogLypmcm9tMSwgZnJvbTIsIGZyb20zLCAuLi4qLykge1xuICB2YXIgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHdoaWxlIChzb3VyY2VzLmxlbmd0aCkge1xuICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCk7XG4gICAgaWYgKCFzb3VyY2UpIHsgY29udGludWU7IH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzb3VyY2UgKyAnbXVzdCBiZSBub24tb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcCBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChfaGFzKHNvdXJjZSwgcCkpIHtcbiAgICAgICAgb2JqW3BdID0gc291cmNlW3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5cbi8vIHJlZHVjZSBidWZmZXIgc2l6ZSwgYXZvaWRpbmcgbWVtIGNvcHlcbmV4cG9ydHMuc2hyaW5rQnVmID0gZnVuY3Rpb24gKGJ1Ziwgc2l6ZSkge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gc2l6ZSkgeyByZXR1cm4gYnVmOyB9XG4gIGlmIChidWYuc3ViYXJyYXkpIHsgcmV0dXJuIGJ1Zi5zdWJhcnJheSgwLCBzaXplKTsgfVxuICBidWYubGVuZ3RoID0gc2l6ZTtcbiAgcmV0dXJuIGJ1Zjtcbn07XG5cblxudmFyIGZuVHlwZWQgPSB7XG4gIGFycmF5U2V0OiBmdW5jdGlvbiAoZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHtcbiAgICBpZiAoc3JjLnN1YmFycmF5ICYmIGRlc3Quc3ViYXJyYXkpIHtcbiAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNfb2Zmcywgc3JjX29mZnMgKyBsZW4pLCBkZXN0X29mZnMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBGYWxsYmFjayB0byBvcmRpbmFyeSBhcnJheVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RbZGVzdF9vZmZzICsgaV0gPSBzcmNbc3JjX29mZnMgKyBpXTtcbiAgICB9XG4gIH0sXG4gIC8vIEpvaW4gYXJyYXkgb2YgY2h1bmtzIHRvIHNpbmdsZSBhcnJheS5cbiAgZmxhdHRlbkNodW5rczogZnVuY3Rpb24gKGNodW5rcykge1xuICAgIHZhciBpLCBsLCBsZW4sIHBvcywgY2h1bmssIHJlc3VsdDtcblxuICAgIC8vIGNhbGN1bGF0ZSBkYXRhIGxlbmd0aFxuICAgIGxlbiA9IDA7XG4gICAgZm9yIChpID0gMCwgbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGxlbiArPSBjaHVua3NbaV0ubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIGpvaW4gY2h1bmtzXG4gICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICBwb3MgPSAwO1xuICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjaHVuayA9IGNodW5rc1tpXTtcbiAgICAgIHJlc3VsdC5zZXQoY2h1bmssIHBvcyk7XG4gICAgICBwb3MgKz0gY2h1bmsubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbnZhciBmblVudHlwZWQgPSB7XG4gIGFycmF5U2V0OiBmdW5jdGlvbiAoZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07XG4gICAgfVxuICB9LFxuICAvLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuXG4gIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uIChjaHVua3MpIHtcbiAgICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCBjaHVua3MpO1xuICB9XG59O1xuXG5cbi8vIEVuYWJsZS9EaXNhYmxlIHR5cGVkIGFycmF5cyB1c2UsIGZvciB0ZXN0aW5nXG4vL1xuZXhwb3J0cy5zZXRUeXBlZCA9IGZ1bmN0aW9uIChvbikge1xuICBpZiAob24pIHtcbiAgICBleHBvcnRzLkJ1ZjggID0gVWludDhBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjE2ID0gVWludDE2QXJyYXk7XG4gICAgZXhwb3J0cy5CdWYzMiA9IEludDMyQXJyYXk7XG4gICAgZXhwb3J0cy5hc3NpZ24oZXhwb3J0cywgZm5UeXBlZCk7XG4gIH0gZWxzZSB7XG4gICAgZXhwb3J0cy5CdWY4ICA9IEFycmF5O1xuICAgIGV4cG9ydHMuQnVmMTYgPSBBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjMyID0gQXJyYXk7XG4gICAgZXhwb3J0cy5hc3NpZ24oZXhwb3J0cywgZm5VbnR5cGVkKTtcbiAgfVxufTtcblxuZXhwb3J0cy5zZXRUeXBlZChUWVBFRF9PSyk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/pako/lib/utils/common.js\n");

/***/ }),

/***/ "./node_modules/pako/lib/utils/strings.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/utils/strings.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// String encode/decode helpers\n\n\nvar utils = __webpack_require__(/*! ./common */ \"./node_modules/pako/lib/utils/common.js\"); // Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safari\n//\n\n\nvar STR_APPLY_OK = true;\nvar STR_APPLY_UIA_OK = true;\n\ntry {\n  String.fromCharCode.apply(null, [0]);\n} catch (__) {\n  STR_APPLY_OK = false;\n}\n\ntry {\n  String.fromCharCode.apply(null, new Uint8Array(1));\n} catch (__) {\n  STR_APPLY_UIA_OK = false;\n} // Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\n\n\nvar _utf8len = new utils.Buf8(256);\n\nfor (var q = 0; q < 256; q++) {\n  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;\n}\n\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n// convert string to array (typed, when possible)\n\nexports.string2buf = function (str) {\n  var buf,\n      c,\n      c2,\n      m_pos,\n      i,\n      str_len = str.length,\n      buf_len = 0; // count binary size\n\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n\n    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n      c2 = str.charCodeAt(m_pos + 1);\n\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  } // allocate buffer\n\n\n  buf = new utils.Buf8(buf_len); // convert\n\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n\n    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n      c2 = str.charCodeAt(m_pos + 1);\n\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | c >>> 6;\n      buf[i++] = 0x80 | c & 0x3f;\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | c >>> 12;\n      buf[i++] = 0x80 | c >>> 6 & 0x3f;\n      buf[i++] = 0x80 | c & 0x3f;\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | c >>> 18;\n      buf[i++] = 0x80 | c >>> 12 & 0x3f;\n      buf[i++] = 0x80 | c >>> 6 & 0x3f;\n      buf[i++] = 0x80 | c & 0x3f;\n    }\n  }\n\n  return buf;\n}; // Helper (used in 2 places)\n\n\nfunction buf2binstring(buf, len) {\n  // use fallback for big arrays to avoid stack overflow\n  if (len < 65537) {\n    if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {\n      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));\n    }\n  }\n\n  var result = '';\n\n  for (var i = 0; i < len; i++) {\n    result += String.fromCharCode(buf[i]);\n  }\n\n  return result;\n} // Convert byte array to binary string\n\n\nexports.buf2binstring = function (buf) {\n  return buf2binstring(buf, buf.length);\n}; // Convert binary string (typed, when possible)\n\n\nexports.binstring2buf = function (str) {\n  var buf = new utils.Buf8(str.length);\n\n  for (var i = 0, len = buf.length; i < len; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n\n  return buf;\n}; // convert array to string\n\n\nexports.buf2string = function (buf, max) {\n  var i, out, c, c_len;\n  var len = max || buf.length; // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n\n  var utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    c = buf[i++]; // quick process ascii\n\n    if (c < 0x80) {\n      utf16buf[out++] = c;\n      continue;\n    }\n\n    c_len = _utf8len[c]; // skip 5 & 6 byte codes\n\n    if (c_len > 4) {\n      utf16buf[out++] = 0xfffd;\n      i += c_len - 1;\n      continue;\n    } // apply mask on first byte\n\n\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07; // join the rest\n\n    while (c_len > 1 && i < len) {\n      c = c << 6 | buf[i++] & 0x3f;\n      c_len--;\n    } // terminated by end of string?\n\n\n    if (c_len > 1) {\n      utf16buf[out++] = 0xfffd;\n      continue;\n    }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;\n      utf16buf[out++] = 0xdc00 | c & 0x3ff;\n    }\n  }\n\n  return buf2binstring(utf16buf, out);\n}; // Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\n\n\nexports.utf8border = function (buf, max) {\n  var pos;\n  max = max || buf.length;\n\n  if (max > buf.length) {\n    max = buf.length;\n  } // go back from last position, until start of sequence found\n\n\n  pos = max - 1;\n\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {\n    pos--;\n  } // Very small and broken sequence,\n  // return max, because we should return something anyway.\n\n\n  if (pos < 0) {\n    return max;\n  } // If we came to start of buffer - that means buffer is too small,\n  // return max too.\n\n\n  if (pos === 0) {\n    return max;\n  }\n\n  return pos + _utf8len[buf[pos]] > max ? pos : max;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvc3RyaW5ncy5qcz83YjI3Il0sIm5hbWVzIjpbInV0aWxzIiwiU1RSX0FQUExZX09LIiwiU1RSX0FQUExZX1VJQV9PSyIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImFwcGx5IiwiX18iLCJVaW50OEFycmF5IiwiX3V0ZjhsZW4iLCJCdWY4IiwicSIsImV4cG9ydHMiLCJzdHJpbmcyYnVmIiwic3RyIiwiYnVmIiwiYyIsImMyIiwibV9wb3MiLCJpIiwic3RyX2xlbiIsImxlbmd0aCIsImJ1Zl9sZW4iLCJjaGFyQ29kZUF0IiwiYnVmMmJpbnN0cmluZyIsImxlbiIsInN1YmFycmF5Iiwic2hyaW5rQnVmIiwicmVzdWx0IiwiYmluc3RyaW5nMmJ1ZiIsImJ1ZjJzdHJpbmciLCJtYXgiLCJvdXQiLCJjX2xlbiIsInV0ZjE2YnVmIiwiQXJyYXkiLCJ1dGY4Ym9yZGVyIiwicG9zIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUdBLElBQUlBLEtBQUssR0FBRyxtQkFBTyxDQUFDLHlEQUFELENBQW5CLEMsQ0FHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxJQUFJQyxZQUFZLEdBQUcsSUFBbkI7QUFDQSxJQUFJQyxnQkFBZ0IsR0FBRyxJQUF2Qjs7QUFFQSxJQUFJO0FBQUVDLFFBQU0sQ0FBQ0MsWUFBUCxDQUFvQkMsS0FBcEIsQ0FBMEIsSUFBMUIsRUFBZ0MsQ0FBRSxDQUFGLENBQWhDO0FBQXlDLENBQS9DLENBQWdELE9BQU9DLEVBQVAsRUFBVztBQUFFTCxjQUFZLEdBQUcsS0FBZjtBQUF1Qjs7QUFDcEYsSUFBSTtBQUFFRSxRQUFNLENBQUNDLFlBQVAsQ0FBb0JDLEtBQXBCLENBQTBCLElBQTFCLEVBQWdDLElBQUlFLFVBQUosQ0FBZSxDQUFmLENBQWhDO0FBQXFELENBQTNELENBQTRELE9BQU9ELEVBQVAsRUFBVztBQUFFSixrQkFBZ0IsR0FBRyxLQUFuQjtBQUEyQixDLENB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LENBQWQsR0FBMkJOLEdBQTVCLEdBQW1DTSxHQUFuQyxHQUF5Q04sR0FBaEQ7QUFDRCxDQW5CRCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9zdHJpbmdzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gU3RyaW5nIGVuY29kZS9kZWNvZGUgaGVscGVyc1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cblxuLy8gUXVpY2sgY2hlY2sgaWYgd2UgY2FuIHVzZSBmYXN0IGFycmF5IHRvIGJpbiBzdHJpbmcgY29udmVyc2lvblxuLy9cbi8vIC0gYXBwbHkoQXJyYXkpIGNhbiBmYWlsIG9uIEFuZHJvaWQgMi4yXG4vLyAtIGFwcGx5KFVpbnQ4QXJyYXkpIGNhbiBmYWlsIG9uIGlPUyA1LjEgU2FmYXJpXG4vL1xudmFyIFNUUl9BUFBMWV9PSyA9IHRydWU7XG52YXIgU1RSX0FQUExZX1VJQV9PSyA9IHRydWU7XG5cbnRyeSB7IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgWyAwIF0pOyB9IGNhdGNoIChfXykgeyBTVFJfQVBQTFlfT0sgPSBmYWxzZTsgfVxudHJ5IHsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSgxKSk7IH0gY2F0Y2ggKF9fKSB7IFNUUl9BUFBMWV9VSUFfT0sgPSBmYWxzZTsgfVxuXG5cbi8vIFRhYmxlIHdpdGggdXRmOCBsZW5ndGhzIChjYWxjdWxhdGVkIGJ5IGZpcnN0IGJ5dGUgb2Ygc2VxdWVuY2UpXG4vLyBOb3RlLCB0aGF0IDUgJiA2LWJ5dGUgdmFsdWVzIGFuZCBzb21lIDQtYnl0ZSB2YWx1ZXMgY2FuIG5vdCBiZSByZXByZXNlbnRlZCBpbiBKUyxcbi8vIGJlY2F1c2UgbWF4IHBvc3NpYmxlIGNvZGVwb2ludCBpcyAweDEwZmZmZlxudmFyIF91dGY4bGVuID0gbmV3IHV0aWxzLkJ1ZjgoMjU2KTtcbmZvciAodmFyIHEgPSAwOyBxIDwgMjU2OyBxKyspIHtcbiAgX3V0ZjhsZW5bcV0gPSAocSA+PSAyNTIgPyA2IDogcSA+PSAyNDggPyA1IDogcSA+PSAyNDAgPyA0IDogcSA+PSAyMjQgPyAzIDogcSA+PSAxOTIgPyAyIDogMSk7XG59XG5fdXRmOGxlblsyNTRdID0gX3V0ZjhsZW5bMjU0XSA9IDE7IC8vIEludmFsaWQgc2VxdWVuY2Ugc3RhcnRcblxuXG4vLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSAodHlwZWQsIHdoZW4gcG9zc2libGUpXG5leHBvcnRzLnN0cmluZzJidWYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBidWYsIGMsIGMyLCBtX3BvcywgaSwgc3RyX2xlbiA9IHN0ci5sZW5ndGgsIGJ1Zl9sZW4gPSAwO1xuXG4gIC8vIGNvdW50IGJpbmFyeSBzaXplXG4gIGZvciAobV9wb3MgPSAwOyBtX3BvcyA8IHN0cl9sZW47IG1fcG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MgKyAxIDwgc3RyX2xlbikpIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1fcG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGJ1Zl9sZW4gKz0gYyA8IDB4ODAgPyAxIDogYyA8IDB4ODAwID8gMiA6IGMgPCAweDEwMDAwID8gMyA6IDQ7XG4gIH1cblxuICAvLyBhbGxvY2F0ZSBidWZmZXJcbiAgYnVmID0gbmV3IHV0aWxzLkJ1ZjgoYnVmX2xlbik7XG5cbiAgLy8gY29udmVydFxuICBmb3IgKGkgPSAwLCBtX3BvcyA9IDA7IGkgPCBidWZfbGVuOyBtX3BvcysrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTtcbiAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zICsgMSA8IHN0cl9sZW4pKSB7XG4gICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zICsgMSk7XG4gICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICBtX3BvcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgIC8qIG9uZSBieXRlICovXG4gICAgICBidWZbaSsrXSA9IGM7XG4gICAgfSBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgIC8qIHR3byBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweEMwIHwgKGMgPj4+IDYpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9IGVsc2UgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICAvKiB0aHJlZSBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweEUwIHwgKGMgPj4+IDEyKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBmb3VyIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4ZjAgfCAoYyA+Pj4gMTgpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDEyICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmO1xufTtcblxuLy8gSGVscGVyICh1c2VkIGluIDIgcGxhY2VzKVxuZnVuY3Rpb24gYnVmMmJpbnN0cmluZyhidWYsIGxlbikge1xuICAvLyB1c2UgZmFsbGJhY2sgZm9yIGJpZyBhcnJheXMgdG8gYXZvaWQgc3RhY2sgb3ZlcmZsb3dcbiAgaWYgKGxlbiA8IDY1NTM3KSB7XG4gICAgaWYgKChidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX1VJQV9PSykgfHwgKCFidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX09LKSkge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdXRpbHMuc2hyaW5rQnVmKGJ1ZiwgbGVuKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbi8vIENvbnZlcnQgYnl0ZSBhcnJheSB0byBiaW5hcnkgc3RyaW5nXG5leHBvcnRzLmJ1ZjJiaW5zdHJpbmcgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIHJldHVybiBidWYyYmluc3RyaW5nKGJ1ZiwgYnVmLmxlbmd0aCk7XG59O1xuXG5cbi8vIENvbnZlcnQgYmluYXJ5IHN0cmluZyAodHlwZWQsIHdoZW4gcG9zc2libGUpXG5leHBvcnRzLmJpbnN0cmluZzJidWYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBidWYgPSBuZXcgdXRpbHMuQnVmOChzdHIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGJ1ZltpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBidWY7XG59O1xuXG5cbi8vIGNvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXG5leHBvcnRzLmJ1ZjJzdHJpbmcgPSBmdW5jdGlvbiAoYnVmLCBtYXgpIHtcbiAgdmFyIGksIG91dCwgYywgY19sZW47XG4gIHZhciBsZW4gPSBtYXggfHwgYnVmLmxlbmd0aDtcblxuICAvLyBSZXNlcnZlIG1heCBwb3NzaWJsZSBsZW5ndGggKDIgd29yZHMgcGVyIGNoYXIpXG4gIC8vIE5COiBieSB1bmtub3duIHJlYXNvbnMsIEFycmF5IGlzIHNpZ25pZmljYW50bHkgZmFzdGVyIGZvclxuICAvLyAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSB0aGFuIFVpbnQxNkFycmF5LlxuICB2YXIgdXRmMTZidWYgPSBuZXcgQXJyYXkobGVuICogMik7XG5cbiAgZm9yIChvdXQgPSAwLCBpID0gMDsgaSA8IGxlbjspIHtcbiAgICBjID0gYnVmW2krK107XG4gICAgLy8gcXVpY2sgcHJvY2VzcyBhc2NpaVxuICAgIGlmIChjIDwgMHg4MCkgeyB1dGYxNmJ1ZltvdXQrK10gPSBjOyBjb250aW51ZTsgfVxuXG4gICAgY19sZW4gPSBfdXRmOGxlbltjXTtcbiAgICAvLyBza2lwIDUgJiA2IGJ5dGUgY29kZXNcbiAgICBpZiAoY19sZW4gPiA0KSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgaSArPSBjX2xlbiAtIDE7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBhcHBseSBtYXNrIG9uIGZpcnN0IGJ5dGVcbiAgICBjICY9IGNfbGVuID09PSAyID8gMHgxZiA6IGNfbGVuID09PSAzID8gMHgwZiA6IDB4MDc7XG4gICAgLy8gam9pbiB0aGUgcmVzdFxuICAgIHdoaWxlIChjX2xlbiA+IDEgJiYgaSA8IGxlbikge1xuICAgICAgYyA9IChjIDw8IDYpIHwgKGJ1ZltpKytdICYgMHgzZik7XG4gICAgICBjX2xlbi0tO1xuICAgIH1cblxuICAgIC8vIHRlcm1pbmF0ZWQgYnkgZW5kIG9mIHN0cmluZz9cbiAgICBpZiAoY19sZW4gPiAxKSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgY29udGludWU7IH1cblxuICAgIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gYztcbiAgICB9IGVsc2Uge1xuICAgICAgYyAtPSAweDEwMDAwO1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkODAwIHwgKChjID4+IDEwKSAmIDB4M2ZmKTtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZGMwMCB8IChjICYgMHgzZmYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYyYmluc3RyaW5nKHV0ZjE2YnVmLCBvdXQpO1xufTtcblxuXG4vLyBDYWxjdWxhdGUgbWF4IHBvc3NpYmxlIHBvc2l0aW9uIGluIHV0ZjggYnVmZmVyLFxuLy8gdGhhdCB3aWxsIG5vdCBicmVhayBzZXF1ZW5jZS4gSWYgdGhhdCdzIG5vdCBwb3NzaWJsZVxuLy8gLSAodmVyeSBzbWFsbCBsaW1pdHMpIHJldHVybiBtYXggc2l6ZSBhcyBpcy5cbi8vXG4vLyBidWZbXSAtIHV0ZjggYnl0ZXMgYXJyYXlcbi8vIG1heCAgIC0gbGVuZ3RoIGxpbWl0IChtYW5kYXRvcnkpO1xuZXhwb3J0cy51dGY4Ym9yZGVyID0gZnVuY3Rpb24gKGJ1ZiwgbWF4KSB7XG4gIHZhciBwb3M7XG5cbiAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG4gIGlmIChtYXggPiBidWYubGVuZ3RoKSB7IG1heCA9IGJ1Zi5sZW5ndGg7IH1cblxuICAvLyBnbyBiYWNrIGZyb20gbGFzdCBwb3NpdGlvbiwgdW50aWwgc3RhcnQgb2Ygc2VxdWVuY2UgZm91bmRcbiAgcG9zID0gbWF4IC0gMTtcbiAgd2hpbGUgKHBvcyA+PSAwICYmIChidWZbcG9zXSAmIDB4QzApID09PSAweDgwKSB7IHBvcy0tOyB9XG5cbiAgLy8gVmVyeSBzbWFsbCBhbmQgYnJva2VuIHNlcXVlbmNlLFxuICAvLyByZXR1cm4gbWF4LCBiZWNhdXNlIHdlIHNob3VsZCByZXR1cm4gc29tZXRoaW5nIGFueXdheS5cbiAgaWYgKHBvcyA8IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gIC8vIElmIHdlIGNhbWUgdG8gc3RhcnQgb2YgYnVmZmVyIC0gdGhhdCBtZWFucyBidWZmZXIgaXMgdG9vIHNtYWxsLFxuICAvLyByZXR1cm4gbWF4IHRvby5cbiAgaWYgKHBvcyA9PT0gMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgcmV0dXJuIChwb3MgKyBfdXRmOGxlbltidWZbcG9zXV0gPiBtYXgpID8gcG9zIDogbWF4O1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/pako/lib/utils/strings.js\n");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/adler32.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/adler32.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(" // Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It isn't worth it to make additional optimizations as in original.\n// Small size is preferable.\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction adler32(adler, buf, len, pos) {\n  var s1 = adler & 0xffff | 0,\n      s2 = adler >>> 16 & 0xffff | 0,\n      n = 0;\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len;\n    len -= n;\n\n    do {\n      s1 = s1 + buf[pos++] | 0;\n      s2 = s2 + s1 | 0;\n    } while (--n);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return s1 | s2 << 16 | 0;\n}\n\nmodule.exports = adler32;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9hZGxlcjMyLmpzP2M4MzQiXSwibmFtZXMiOlsiYWRsZXIzMiIsImFkbGVyIiwiYnVmIiwibGVuIiwicG9zIiwiczEiLCJzMiIsIm4iLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQ0FFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBU0EsT0FBVCxDQUFpQkMsS0FBakIsRUFBd0JDLEdBQXhCLEVBQTZCQyxHQUE3QixFQUFrQ0MsR0FBbEMsRUFBdUM7QUFDckMsTUFBSUMsRUFBRSxHQUFJSixLQUFLLEdBQUcsTUFBVCxHQUFrQixDQUEzQjtBQUFBLE1BQ0lLLEVBQUUsR0FBS0wsS0FBSyxLQUFLLEVBQVgsR0FBaUIsTUFBbEIsR0FBMkIsQ0FEcEM7QUFBQSxNQUVJTSxDQUFDLEdBQUcsQ0FGUjs7QUFJQSxTQUFPSixHQUFHLEtBQUssQ0FBZixFQUFrQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQUksS0FBQyxHQUFHSixHQUFHLEdBQUcsSUFBTixHQUFhLElBQWIsR0FBb0JBLEdBQXhCO0FBQ0FBLE9BQUcsSUFBSUksQ0FBUDs7QUFFQSxPQUFHO0FBQ0RGLFFBQUUsR0FBSUEsRUFBRSxHQUFHSCxHQUFHLENBQUNFLEdBQUcsRUFBSixDQUFULEdBQW1CLENBQXhCO0FBQ0FFLFFBQUUsR0FBSUEsRUFBRSxHQUFHRCxFQUFOLEdBQVcsQ0FBaEI7QUFDRCxLQUhELFFBR1MsRUFBRUUsQ0FIWDs7QUFLQUYsTUFBRSxJQUFJLEtBQU47QUFDQUMsTUFBRSxJQUFJLEtBQU47QUFDRDs7QUFFRCxTQUFRRCxFQUFFLEdBQUlDLEVBQUUsSUFBSSxFQUFiLEdBQW1CLENBQTFCO0FBQ0Q7O0FBR0RFLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQlQsT0FBakIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9hZGxlcjMyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyBOb3RlOiBhZGxlcjMyIHRha2VzIDEyJSBmb3IgbGV2ZWwgMCBhbmQgMiUgZm9yIGxldmVsIDYuXG4vLyBJdCBpc24ndCB3b3J0aCBpdCB0byBtYWtlIGFkZGl0aW9uYWwgb3B0aW1pemF0aW9ucyBhcyBpbiBvcmlnaW5hbC5cbi8vIFNtYWxsIHNpemUgaXMgcHJlZmVyYWJsZS5cblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5mdW5jdGlvbiBhZGxlcjMyKGFkbGVyLCBidWYsIGxlbiwgcG9zKSB7XG4gIHZhciBzMSA9IChhZGxlciAmIDB4ZmZmZikgfDAsXG4gICAgICBzMiA9ICgoYWRsZXIgPj4+IDE2KSAmIDB4ZmZmZikgfDAsXG4gICAgICBuID0gMDtcblxuICB3aGlsZSAobGVuICE9PSAwKSB7XG4gICAgLy8gU2V0IGxpbWl0IH4gdHdpY2UgbGVzcyB0aGFuIDU1NTIsIHRvIGtlZXBcbiAgICAvLyBzMiBpbiAzMS1iaXRzLCBiZWNhdXNlIHdlIGZvcmNlIHNpZ25lZCBpbnRzLlxuICAgIC8vIGluIG90aGVyIGNhc2UgJT0gd2lsbCBmYWlsLlxuICAgIG4gPSBsZW4gPiAyMDAwID8gMjAwMCA6IGxlbjtcbiAgICBsZW4gLT0gbjtcblxuICAgIGRvIHtcbiAgICAgIHMxID0gKHMxICsgYnVmW3BvcysrXSkgfDA7XG4gICAgICBzMiA9IChzMiArIHMxKSB8MDtcbiAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgczEgJT0gNjU1MjE7XG4gICAgczIgJT0gNjU1MjE7XG4gIH1cblxuICByZXR1cm4gKHMxIHwgKHMyIDw8IDE2KSkgfDA7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBhZGxlcjMyO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/pako/lib/zlib/adler32.js\n");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/constants.js":
/*!*************************************************!*\
  !*** ./node_modules/pako/lib/zlib/constants.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(" // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n  /* Allowed flush values; see deflate() and inflate() below for details */\n  Z_NO_FLUSH: 0,\n  Z_PARTIAL_FLUSH: 1,\n  Z_SYNC_FLUSH: 2,\n  Z_FULL_FLUSH: 3,\n  Z_FINISH: 4,\n  Z_BLOCK: 5,\n  Z_TREES: 6,\n\n  /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */\n  Z_OK: 0,\n  Z_STREAM_END: 1,\n  Z_NEED_DICT: 2,\n  Z_ERRNO: -1,\n  Z_STREAM_ERROR: -2,\n  Z_DATA_ERROR: -3,\n  //Z_MEM_ERROR:     -4,\n  Z_BUF_ERROR: -5,\n  //Z_VERSION_ERROR: -6,\n\n  /* compression levels */\n  Z_NO_COMPRESSION: 0,\n  Z_BEST_SPEED: 1,\n  Z_BEST_COMPRESSION: 9,\n  Z_DEFAULT_COMPRESSION: -1,\n  Z_FILTERED: 1,\n  Z_HUFFMAN_ONLY: 2,\n  Z_RLE: 3,\n  Z_FIXED: 4,\n  Z_DEFAULT_STRATEGY: 0,\n\n  /* Possible values of the data_type field (though see inflate()) */\n  Z_BINARY: 0,\n  Z_TEXT: 1,\n  //Z_ASCII:                1, // = Z_TEXT (deprecated)\n  Z_UNKNOWN: 2,\n\n  /* The deflate compression method */\n  Z_DEFLATED: 8 //Z_NULL:                 null // Use -1 or null inline, depending on var type\n\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9jb25zdGFudHMuanM/MmNlYiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiWl9OT19GTFVTSCIsIlpfUEFSVElBTF9GTFVTSCIsIlpfU1lOQ19GTFVTSCIsIlpfRlVMTF9GTFVTSCIsIlpfRklOSVNIIiwiWl9CTE9DSyIsIlpfVFJFRVMiLCJaX09LIiwiWl9TVFJFQU1fRU5EIiwiWl9ORUVEX0RJQ1QiLCJaX0VSUk5PIiwiWl9TVFJFQU1fRVJST1IiLCJaX0RBVEFfRVJST1IiLCJaX0JVRl9FUlJPUiIsIlpfTk9fQ09NUFJFU1NJT04iLCJaX0JFU1RfU1BFRUQiLCJaX0JFU1RfQ09NUFJFU1NJT04iLCJaX0RFRkFVTFRfQ09NUFJFU1NJT04iLCJaX0ZJTFRFUkVEIiwiWl9IVUZGTUFOX09OTFkiLCJaX1JMRSIsIlpfRklYRUQiLCJaX0RFRkFVTFRfU1RSQVRFR1kiLCJaX0JJTkFSWSIsIlpfVEVYVCIsIlpfVU5LTk9XTiIsIlpfREVGTEFURUQiXSwibWFwcGluZ3MiOiJDQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQUEsTUFBTSxDQUFDQyxPQUFQLEdBQWlCO0FBRWY7QUFDQUMsWUFBVSxFQUFVLENBSEw7QUFJZkMsaUJBQWUsRUFBSyxDQUpMO0FBS2ZDLGNBQVksRUFBUSxDQUxMO0FBTWZDLGNBQVksRUFBUSxDQU5MO0FBT2ZDLFVBQVEsRUFBWSxDQVBMO0FBUWZDLFNBQU8sRUFBYSxDQVJMO0FBU2ZDLFNBQU8sRUFBYSxDQVRMOztBQVdmOzs7QUFHQUMsTUFBSSxFQUFnQixDQWRMO0FBZWZDLGNBQVksRUFBUSxDQWZMO0FBZ0JmQyxhQUFXLEVBQVMsQ0FoQkw7QUFpQmZDLFNBQU8sRUFBWSxDQUFDLENBakJMO0FBa0JmQyxnQkFBYyxFQUFLLENBQUMsQ0FsQkw7QUFtQmZDLGNBQVksRUFBTyxDQUFDLENBbkJMO0FBb0JmO0FBQ0FDLGFBQVcsRUFBUSxDQUFDLENBckJMO0FBc0JmOztBQUVBO0FBQ0FDLGtCQUFnQixFQUFVLENBekJYO0FBMEJmQyxjQUFZLEVBQWMsQ0ExQlg7QUEyQmZDLG9CQUFrQixFQUFRLENBM0JYO0FBNEJmQyx1QkFBcUIsRUFBSSxDQUFDLENBNUJYO0FBK0JmQyxZQUFVLEVBQWdCLENBL0JYO0FBZ0NmQyxnQkFBYyxFQUFZLENBaENYO0FBaUNmQyxPQUFLLEVBQXFCLENBakNYO0FBa0NmQyxTQUFPLEVBQW1CLENBbENYO0FBbUNmQyxvQkFBa0IsRUFBUSxDQW5DWDs7QUFxQ2Y7QUFDQUMsVUFBUSxFQUFrQixDQXRDWDtBQXVDZkMsUUFBTSxFQUFvQixDQXZDWDtBQXdDZjtBQUNBQyxXQUFTLEVBQWlCLENBekNYOztBQTJDZjtBQUNBQyxZQUFVLEVBQWdCLENBNUNYLENBNkNmOztBQTdDZSxDQUFqQiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NvbnN0YW50cy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG4gIFpfTk9fRkxVU0g6ICAgICAgICAgMCxcbiAgWl9QQVJUSUFMX0ZMVVNIOiAgICAxLFxuICBaX1NZTkNfRkxVU0g6ICAgICAgIDIsXG4gIFpfRlVMTF9GTFVTSDogICAgICAgMyxcbiAgWl9GSU5JU0g6ICAgICAgICAgICA0LFxuICBaX0JMT0NLOiAgICAgICAgICAgIDUsXG4gIFpfVFJFRVM6ICAgICAgICAgICAgNixcblxuICAvKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICAqL1xuICBaX09LOiAgICAgICAgICAgICAgIDAsXG4gIFpfU1RSRUFNX0VORDogICAgICAgMSxcbiAgWl9ORUVEX0RJQ1Q6ICAgICAgICAyLFxuICBaX0VSUk5POiAgICAgICAgICAgLTEsXG4gIFpfU1RSRUFNX0VSUk9SOiAgICAtMixcbiAgWl9EQVRBX0VSUk9SOiAgICAgIC0zLFxuICAvL1pfTUVNX0VSUk9SOiAgICAgLTQsXG4gIFpfQlVGX0VSUk9SOiAgICAgICAtNSxcbiAgLy9aX1ZFUlNJT05fRVJST1I6IC02LFxuXG4gIC8qIGNvbXByZXNzaW9uIGxldmVscyAqL1xuICBaX05PX0NPTVBSRVNTSU9OOiAgICAgICAgIDAsXG4gIFpfQkVTVF9TUEVFRDogICAgICAgICAgICAgMSxcbiAgWl9CRVNUX0NPTVBSRVNTSU9OOiAgICAgICA5LFxuICBaX0RFRkFVTFRfQ09NUFJFU1NJT046ICAgLTEsXG5cblxuICBaX0ZJTFRFUkVEOiAgICAgICAgICAgICAgIDEsXG4gIFpfSFVGRk1BTl9PTkxZOiAgICAgICAgICAgMixcbiAgWl9STEU6ICAgICAgICAgICAgICAgICAgICAzLFxuICBaX0ZJWEVEOiAgICAgICAgICAgICAgICAgIDQsXG4gIFpfREVGQVVMVF9TVFJBVEVHWTogICAgICAgMCxcblxuICAvKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG4gIFpfQklOQVJZOiAgICAgICAgICAgICAgICAgMCxcbiAgWl9URVhUOiAgICAgICAgICAgICAgICAgICAxLFxuICAvL1pfQVNDSUk6ICAgICAgICAgICAgICAgIDEsIC8vID0gWl9URVhUIChkZXByZWNhdGVkKVxuICBaX1VOS05PV046ICAgICAgICAgICAgICAgIDIsXG5cbiAgLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG4gIFpfREVGTEFURUQ6ICAgICAgICAgICAgICAgOFxuICAvL1pfTlVMTDogICAgICAgICAgICAgICAgIG51bGwgLy8gVXNlIC0xIG9yIG51bGwgaW5saW5lLCBkZXBlbmRpbmcgb24gdmFyIHR5cGVcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/pako/lib/zlib/constants.js\n");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/crc32.js":
/*!*********************************************!*\
  !*** ./node_modules/pako/lib/zlib/crc32.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(" // Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n// Use ordinary array, since untyped makes no boost here\n\nfunction makeTable() {\n  var c,\n      table = [];\n\n  for (var n = 0; n < 256; n++) {\n    c = n;\n\n    for (var k = 0; k < 8; k++) {\n      c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;\n    }\n\n    table[n] = c;\n  }\n\n  return table;\n} // Create table on load. Just 255 signed longs. Not a problem.\n\n\nvar crcTable = makeTable();\n\nfunction crc32(crc, buf, len, pos) {\n  var t = crcTable,\n      end = pos + len;\n  crc ^= -1;\n\n  for (var i = pos; i < end; i++) {\n    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return crc ^ -1; // >>> 0;\n}\n\nmodule.exports = crc32;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9jcmMzMi5qcz9lZWRhIl0sIm5hbWVzIjpbIm1ha2VUYWJsZSIsImMiLCJ0YWJsZSIsIm4iLCJrIiwiY3JjVGFibGUiLCJjcmMzMiIsImNyYyIsImJ1ZiIsImxlbiIsInBvcyIsInQiLCJlbmQiLCJpIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkNBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0EsU0FBU0EsU0FBVCxHQUFxQjtBQUNuQixNQUFJQyxDQUFKO0FBQUEsTUFBT0MsS0FBSyxHQUFHLEVBQWY7O0FBRUEsT0FBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLEdBQXBCLEVBQXlCQSxDQUFDLEVBQTFCLEVBQThCO0FBQzVCRixLQUFDLEdBQUdFLENBQUo7O0FBQ0EsU0FBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLENBQXBCLEVBQXVCQSxDQUFDLEVBQXhCLEVBQTRCO0FBQzFCSCxPQUFDLEdBQUtBLENBQUMsR0FBRyxDQUFMLEdBQVcsYUFBY0EsQ0FBQyxLQUFLLENBQS9CLEdBQXNDQSxDQUFDLEtBQUssQ0FBakQ7QUFDRDs7QUFDREMsU0FBSyxDQUFDQyxDQUFELENBQUwsR0FBV0YsQ0FBWDtBQUNEOztBQUVELFNBQU9DLEtBQVA7QUFDRCxDLENBRUQ7OztBQUNBLElBQUlHLFFBQVEsR0FBR0wsU0FBUyxFQUF4Qjs7QUFHQSxTQUFTTSxLQUFULENBQWVDLEdBQWYsRUFBb0JDLEdBQXBCLEVBQXlCQyxHQUF6QixFQUE4QkMsR0FBOUIsRUFBbUM7QUFDakMsTUFBSUMsQ0FBQyxHQUFHTixRQUFSO0FBQUEsTUFDSU8sR0FBRyxHQUFHRixHQUFHLEdBQUdELEdBRGhCO0FBR0FGLEtBQUcsSUFBSSxDQUFDLENBQVI7O0FBRUEsT0FBSyxJQUFJTSxDQUFDLEdBQUdILEdBQWIsRUFBa0JHLENBQUMsR0FBR0QsR0FBdEIsRUFBMkJDLENBQUMsRUFBNUIsRUFBZ0M7QUFDOUJOLE9BQUcsR0FBSUEsR0FBRyxLQUFLLENBQVQsR0FBY0ksQ0FBQyxDQUFDLENBQUNKLEdBQUcsR0FBR0MsR0FBRyxDQUFDSyxDQUFELENBQVYsSUFBaUIsSUFBbEIsQ0FBckI7QUFDRDs7QUFFRCxTQUFRTixHQUFHLEdBQUksQ0FBQyxDQUFoQixDQVZpQyxDQVVaO0FBQ3RCOztBQUdETyxNQUFNLENBQUNDLE9BQVAsR0FBaUJULEtBQWpCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY3JjMzIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIE5vdGU6IHdlIGNhbid0IGdldCBzaWduaWZpY2FudCBzcGVlZCBib29zdCBoZXJlLlxuLy8gU28gd3JpdGUgY29kZSB0byBtaW5pbWl6ZSBzaXplIC0gbm8gcHJlZ2VuZXJhdGVkIHRhYmxlc1xuLy8gYW5kIGFycmF5IHRvb2xzIGRlcGVuZGVuY2llcy5cblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG4vLyBVc2Ugb3JkaW5hcnkgYXJyYXksIHNpbmNlIHVudHlwZWQgbWFrZXMgbm8gYm9vc3QgaGVyZVxuZnVuY3Rpb24gbWFrZVRhYmxlKCkge1xuICB2YXIgYywgdGFibGUgPSBbXTtcblxuICBmb3IgKHZhciBuID0gMDsgbiA8IDI1NjsgbisrKSB7XG4gICAgYyA9IG47XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgIGMgPSAoKGMgJiAxKSA/ICgweEVEQjg4MzIwIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG4gICAgfVxuICAgIHRhYmxlW25dID0gYztcbiAgfVxuXG4gIHJldHVybiB0YWJsZTtcbn1cblxuLy8gQ3JlYXRlIHRhYmxlIG9uIGxvYWQuIEp1c3QgMjU1IHNpZ25lZCBsb25ncy4gTm90IGEgcHJvYmxlbS5cbnZhciBjcmNUYWJsZSA9IG1ha2VUYWJsZSgpO1xuXG5cbmZ1bmN0aW9uIGNyYzMyKGNyYywgYnVmLCBsZW4sIHBvcykge1xuICB2YXIgdCA9IGNyY1RhYmxlLFxuICAgICAgZW5kID0gcG9zICsgbGVuO1xuXG4gIGNyYyBePSAtMTtcblxuICBmb3IgKHZhciBpID0gcG9zOyBpIDwgZW5kOyBpKyspIHtcbiAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRbKGNyYyBeIGJ1ZltpXSkgJiAweEZGXTtcbiAgfVxuXG4gIHJldHVybiAoY3JjIF4gKC0xKSk7IC8vID4+PiAwO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gY3JjMzI7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/pako/lib/zlib/crc32.js\n");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/deflate.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/deflate.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(" // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils = __webpack_require__(/*! ../utils/common */ \"./node_modules/pako/lib/utils/common.js\");\n\nvar trees = __webpack_require__(/*! ./trees */ \"./node_modules/pako/lib/zlib/trees.js\");\n\nvar adler32 = __webpack_require__(/*! ./adler32 */ \"./node_modules/pako/lib/zlib/adler32.js\");\n\nvar crc32 = __webpack_require__(/*! ./crc32 */ \"./node_modules/pako/lib/zlib/crc32.js\");\n\nvar msg = __webpack_require__(/*! ./messages */ \"./node_modules/pako/lib/zlib/messages.js\");\n/* Public constants ==========================================================*/\n\n/* ===========================================================================*/\n\n/* Allowed flush values; see deflate() and inflate() below for details */\n\n\nvar Z_NO_FLUSH = 0;\nvar Z_PARTIAL_FLUSH = 1; //var Z_SYNC_FLUSH    = 2;\n\nvar Z_FULL_FLUSH = 3;\nvar Z_FINISH = 4;\nvar Z_BLOCK = 5; //var Z_TREES         = 6;\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\n\nvar Z_OK = 0;\nvar Z_STREAM_END = 1; //var Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\n\nvar Z_STREAM_ERROR = -2;\nvar Z_DATA_ERROR = -3; //var Z_MEM_ERROR     = -4;\n\nvar Z_BUF_ERROR = -5; //var Z_VERSION_ERROR = -6;\n\n/* compression levels */\n//var Z_NO_COMPRESSION      = 0;\n//var Z_BEST_SPEED          = 1;\n//var Z_BEST_COMPRESSION    = 9;\n\nvar Z_DEFAULT_COMPRESSION = -1;\nvar Z_FILTERED = 1;\nvar Z_HUFFMAN_ONLY = 2;\nvar Z_RLE = 3;\nvar Z_FIXED = 4;\nvar Z_DEFAULT_STRATEGY = 0;\n/* Possible values of the data_type field (though see inflate()) */\n//var Z_BINARY              = 0;\n//var Z_TEXT                = 1;\n//var Z_ASCII               = 1; // = Z_TEXT\n\nvar Z_UNKNOWN = 2;\n/* The deflate compression method */\n\nvar Z_DEFLATED = 8;\n/*============================================================================*/\n\nvar MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\n\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\n\nvar DEF_MEM_LEVEL = 8;\nvar LENGTH_CODES = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nvar LITERALS = 256;\n/* number of literal bytes 0..255 */\n\nvar L_CODES = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nvar D_CODES = 30;\n/* number of distance codes */\n\nvar BL_CODES = 19;\n/* number of codes used to transfer the bit lengths */\n\nvar HEAP_SIZE = 2 * L_CODES + 1;\n/* maximum heap size */\n\nvar MAX_BITS = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar MIN_MATCH = 3;\nvar MAX_MATCH = 258;\nvar MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;\nvar PRESET_DICT = 0x20;\nvar INIT_STATE = 42;\nvar EXTRA_STATE = 69;\nvar NAME_STATE = 73;\nvar COMMENT_STATE = 91;\nvar HCRC_STATE = 103;\nvar BUSY_STATE = 113;\nvar FINISH_STATE = 666;\nvar BS_NEED_MORE = 1;\n/* block not completed, need more input or more output */\n\nvar BS_BLOCK_DONE = 2;\n/* block flush performed */\n\nvar BS_FINISH_STARTED = 3;\n/* finish started, need only more output at next deflate */\n\nvar BS_FINISH_DONE = 4;\n/* finish done, accept no more input or output */\n\nvar OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nfunction err(strm, errorCode) {\n  strm.msg = msg[errorCode];\n  return errorCode;\n}\n\nfunction rank(f) {\n  return (f << 1) - (f > 4 ? 9 : 0);\n}\n\nfunction zero(buf) {\n  var len = buf.length;\n\n  while (--len >= 0) {\n    buf[len] = 0;\n  }\n}\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */\n\n\nfunction flush_pending(strm) {\n  var s = strm.state; //_tr_flush_bits(s);\n\n  var len = s.pending;\n\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n\n  if (len === 0) {\n    return;\n  }\n\n  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n  strm.next_out += len;\n  s.pending_out += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending -= len;\n\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n}\n\nfunction flush_block_only(s, last) {\n  trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);\n\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n}\n\nfunction put_byte(s, b) {\n  s.pending_buf[s.pending++] = b;\n}\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\n\n\nfunction putShortMSB(s, b) {\n  //  put_byte(s, (Byte)(b >> 8));\n  //  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = b >>> 8 & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n}\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\n\n\nfunction read_buf(strm, buf, start, size) {\n  var len = strm.avail_in;\n\n  if (len > size) {\n    len = size;\n  }\n\n  if (len === 0) {\n    return 0;\n  }\n\n  strm.avail_in -= len; // zmemcpy(buf, strm->next_in, len);\n\n  utils.arraySet(buf, strm.input, strm.next_in, len, start);\n\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32(strm.adler, buf, len, start);\n  } else if (strm.state.wrap === 2) {\n    strm.adler = crc32(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n  return len;\n}\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\n\n\nfunction longest_match(s, cur_match) {\n  var chain_length = s.max_chain_length;\n  /* max hash chain length */\n\n  var scan = s.strstart;\n  /* current string */\n\n  var match;\n  /* matched string */\n\n  var len;\n  /* length of current match */\n\n  var best_len = s.prev_length;\n  /* best match length so far */\n\n  var nice_match = s.nice_match;\n  /* stop if match long enough */\n\n  var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0\n  /*NIL*/\n  ;\n  var _win = s.window; // shortcut\n\n  var wmask = s.w_mask;\n  var prev = s.prev;\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  var strend = s.strstart + MAX_MATCH;\n  var scan_end1 = _win[scan + best_len - 1];\n  var scan_end = _win[scan + best_len];\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n\n\n  if (nice_match > s.lookahead) {\n    nice_match = s.lookahead;\n  } // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {\n      continue;\n    }\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n\n\n    scan += 2;\n    match++; // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend); // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n\n      if (len >= nice_match) {\n        break;\n      }\n\n      scan_end1 = _win[scan + best_len - 1];\n      scan_end = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n\n  return s.lookahead;\n}\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\n\n\nfunction fill_window(s) {\n  var _w_size = s.w_size;\n  var p, n, m, more, str; //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart; // JS ints have 32 bit, block below not needed\n\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n\n      s.block_start -= _w_size;\n      /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */\n\n      n = s.hash_size;\n      p = n;\n\n      do {\n        m = s.head[--p];\n        s.head[p] = m >= _w_size ? m - _w_size : 0;\n      } while (--n);\n\n      n = _w_size;\n      p = n;\n\n      do {\n        m = s.prev[--p];\n        s.prev[p] = m >= _w_size ? m - _w_size : 0;\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n      } while (--n);\n\n      more += _w_size;\n    }\n\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n\n\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n    /* Initialize the hash value now that we have some input: */\n\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n\n      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask; //#if MIN_MATCH != 3\n      //        Call update_hash() MIN_MATCH-3 more times\n      //#endif\n\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n  //  if (s.high_water < s.window_size) {\n  //    var curr = s.strstart + s.lookahead;\n  //    var init = 0;\n  //\n  //    if (s.high_water < curr) {\n  //      /* Previous high water mark below current data -- zero WIN_INIT\n  //       * bytes or up to end of window, whichever is less.\n  //       */\n  //      init = s.window_size - curr;\n  //      if (init > WIN_INIT)\n  //        init = WIN_INIT;\n  //      zmemzero(s->window + curr, (unsigned)init);\n  //      s->high_water = curr + init;\n  //    }\n  //    else if (s->high_water < (ulg)curr + WIN_INIT) {\n  //      /* High water mark at or above current data, but below current data\n  //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n  //       * to end of window, whichever is less.\n  //       */\n  //      init = (ulg)curr + WIN_INIT - s->high_water;\n  //      if (init > s->window_size - s->high_water)\n  //        init = s->window_size - s->high_water;\n  //      zmemzero(s->window + s->high_water, (unsigned)init);\n  //      s->high_water += init;\n  //    }\n  //  }\n  //\n  //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n  //    \"not enough room for search\");\n\n}\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\n\n\nfunction deflate_stored(s, flush) {\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */\n  var max_block_size = 0xffff;\n\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5;\n  }\n  /* Copy as much as possible from input to output: */\n\n\n  for (;;) {\n    /* Fill the window as much as possible: */\n    if (s.lookahead <= 1) {\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n      //  s->block_start >= (long)s->w_size, \"slide too late\");\n      //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n      //        s.block_start >= s.w_size)) {\n      //        throw  new Error(\"slide too late\");\n      //      }\n      fill_window(s);\n\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n\n    } //Assert(s->block_start >= 0L, \"block gone\");\n    //    if (s.block_start < 0) throw new Error(\"block gone\");\n\n\n    s.strstart += s.lookahead;\n    s.lookahead = 0;\n    /* Emit a stored block if pending_buf will be full: */\n\n    var max_start = s.block_start + max_block_size;\n\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\n      s.lookahead = s.strstart - max_start;\n      s.strstart = max_start;\n      /*** FLUSH_BLOCK(s, 0); ***/\n\n      flush_block_only(s, false);\n\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n    }\n    /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */\n\n\n    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n\n\n    return BS_FINISH_DONE;\n  }\n\n  if (s.strstart > s.block_start) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n\n  }\n\n  return BS_NEED_MORE;\n}\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\n\n\nfunction deflate_fast(s, flush) {\n  var hash_head;\n  /* head of the hash chain */\n\n  var bflush;\n  /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n        /* flush the current block */\n      }\n    }\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n\n\n    hash_head = 0\n    /*NIL*/\n    ;\n\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n\n\n    if (hash_head !== 0\n    /*NIL*/\n    && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n      s.lookahead -= s.match_length;\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n\n      if (s.match_length <= s.max_lazy_match\n      /*max_insert_length*/\n      && s.lookahead >= MIN_MATCH) {\n        s.match_length--;\n        /* string at strstart already in table */\n\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n\n          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n\n        s.strstart++;\n      } else {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n\n        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask; //#if MIN_MATCH != 3\n        //                Call UPDATE_HASH() MIN_MATCH-3 more times\n        //#endif\n\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n      s.lookahead--;\n      s.strstart++;\n    }\n\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n    }\n  }\n\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n\n\n    return BS_FINISH_DONE;\n  }\n\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n\n  }\n\n  return BS_BLOCK_DONE;\n}\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\n\n\nfunction deflate_slow(s, flush) {\n  var hash_head;\n  /* head of hash chain */\n\n  var bflush;\n  /* set if current block must be flushed */\n\n  var max_insert;\n  /* Process the input block. */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n\n    }\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n\n\n    hash_head = 0\n    /*NIL*/\n    ;\n\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n    /* Find the longest match, discarding those <= prev_length.\n     */\n\n\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0\n    /*NIL*/\n    && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD\n    /*MAX_DIST(s)*/\n    ) {\n        /* To simplify the code, we prevent matches with the string\n         * of window index 0 (in particular we have to avoid a match\n         * of the string with itself at the start of the input file).\n         */\n        s.match_length = longest_match(s, hash_head);\n        /* longest_match() sets match_start */\n\n        if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096\n        /*TOO_FAR*/\n        )) {\n          /* If prev_match is also MIN_MATCH, match_start is garbage\n           * but we will ignore the current match anyway.\n           */\n          s.match_length = MIN_MATCH - 1;\n        }\n      }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n\n\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n\n      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n\n      }\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n\n      s.strstart++;\n      s.lookahead--;\n\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  } //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n\n\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n    s.match_available = 0;\n  }\n\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n\n\n    return BS_FINISH_DONE;\n  }\n\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n\n  }\n\n  return BS_BLOCK_DONE;\n}\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\n\n\nfunction deflate_rle(s, flush) {\n  var bflush;\n  /* set if current block must be flushed */\n\n  var prev;\n  /* byte at distance one to match */\n\n  var scan, strend;\n  /* scan goes up to strend for length of run */\n\n  var _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n\n    }\n    /* See how many times the previous byte repeats */\n\n\n    s.match_length = 0;\n\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);\n\n        s.match_length = MAX_MATCH - (strend - scan);\n\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      } //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n\n    }\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n\n\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n      s.lookahead--;\n      s.strstart++;\n    }\n\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n\n\n    return BS_FINISH_DONE;\n  }\n\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n\n  }\n\n  return BS_BLOCK_DONE;\n}\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\n\n\nfunction deflate_huff(s, flush) {\n  var bflush;\n  /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH) {\n          return BS_NEED_MORE;\n        }\n\n        break;\n        /* flush the current block */\n      }\n    }\n    /* Output a literal byte */\n\n\n    s.match_length = 0; //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n\n\n    return BS_FINISH_DONE;\n  }\n\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n\n  }\n\n  return BS_BLOCK_DONE;\n}\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\n\n\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nvar configuration_table;\nconfiguration_table = [\n/*      good lazy nice chain */\nnew Config(0, 0, 0, 0, deflate_stored),\n/* 0 store only */\nnew Config(4, 4, 8, 4, deflate_fast),\n/* 1 max speed, no lazy matches */\nnew Config(4, 5, 16, 8, deflate_fast),\n/* 2 */\nnew Config(4, 6, 32, 32, deflate_fast),\n/* 3 */\nnew Config(4, 4, 16, 16, deflate_slow),\n/* 4 lazy matches */\nnew Config(8, 16, 32, 32, deflate_slow),\n/* 5 */\nnew Config(8, 16, 128, 128, deflate_slow),\n/* 6 */\nnew Config(8, 32, 128, 256, deflate_slow),\n/* 7 */\nnew Config(32, 128, 258, 1024, deflate_slow),\n/* 8 */\nnew Config(32, 258, 258, 4096, deflate_slow)\n/* 9 max compression */\n];\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\n\nfunction lm_init(s) {\n  s.window_size = 2 * s.w_size;\n  /*** CLEAR_HASH(s); ***/\n\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n}\n\nfunction DeflateState() {\n  this.strm = null;\n  /* pointer back to this zlib stream */\n\n  this.status = 0;\n  /* as the name implies */\n\n  this.pending_buf = null;\n  /* output still pending */\n\n  this.pending_buf_size = 0;\n  /* size of pending_buf */\n\n  this.pending_out = 0;\n  /* next pending byte to output to the stream */\n\n  this.pending = 0;\n  /* nb of bytes in the pending buffer */\n\n  this.wrap = 0;\n  /* bit 0 true for zlib, bit 1 true for gzip */\n\n  this.gzhead = null;\n  /* gzip header information to write */\n\n  this.gzindex = 0;\n  /* where in extra, name, or comment */\n\n  this.method = Z_DEFLATED;\n  /* can only be DEFLATED */\n\n  this.last_flush = -1;\n  /* value of flush param for previous deflate call */\n\n  this.w_size = 0;\n  /* LZ77 window size (32K by default) */\n\n  this.w_bits = 0;\n  /* log2(w_size)  (8..16) */\n\n  this.w_mask = 0;\n  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;\n  /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;\n  /* hash index of string to be inserted */\n\n  this.hash_size = 0;\n  /* number of elements in hash table */\n\n  this.hash_bits = 0;\n  /* log2(hash_size) */\n\n  this.hash_mask = 0;\n  /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;\n  /* length of best match */\n\n  this.prev_match = 0;\n  /* previous match */\n\n  this.match_available = 0;\n  /* set if previous match exists */\n\n  this.strstart = 0;\n  /* start of string to insert */\n\n  this.match_start = 0;\n  /* start of matching string */\n\n  this.lookahead = 0;\n  /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;\n  /* compression level (1..9) */\n\n  this.strategy = 0;\n  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0;\n  /* Stop searching when current match exceeds this */\n\n  /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n\n  this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);\n  this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);\n  this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n  this.l_desc = null;\n  /* desc. for literal tree */\n\n  this.d_desc = null;\n  /* desc. for distance tree */\n\n  this.bl_desc = null;\n  /* desc. for bit length tree */\n  //ush bl_count[MAX_BITS+1];\n\n  this.bl_count = new utils.Buf16(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n\n  this.heap = new utils.Buf16(2 * L_CODES + 1);\n  /* heap used to build the Huffman trees */\n\n  zero(this.heap);\n  this.heap_len = 0;\n  /* number of elements in the heap */\n\n  this.heap_max = 0;\n  /* element of largest frequency */\n\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.l_buf = 0;\n  /* buffer index for literals or lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.last_lit = 0;\n  /* running index in l_buf */\n\n  this.d_buf = 0;\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */\n\n  this.opt_len = 0;\n  /* bit length of current block with optimal trees */\n\n  this.static_len = 0;\n  /* bit length of current block with static trees */\n\n  this.matches = 0;\n  /* number of string matches in current block */\n\n  this.insert = 0;\n  /* bytes at end of window left to insert */\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\nfunction deflateResetKeep(strm) {\n  var s;\n\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n  s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n\n  s.status = s.wrap ? INIT_STATE : BUSY_STATE;\n  strm.adler = s.wrap === 2 ? 0 // crc32(0, Z_NULL, 0)\n  : 1; // adler32(0, Z_NULL, 0)\n\n  s.last_flush = Z_NO_FLUSH;\n\n  trees._tr_init(s);\n\n  return Z_OK;\n}\n\nfunction deflateReset(strm) {\n  var ret = deflateResetKeep(strm);\n\n  if (ret === Z_OK) {\n    lm_init(strm.state);\n  }\n\n  return ret;\n}\n\nfunction deflateSetHeader(strm, head) {\n  if (!strm || !strm.state) {\n    return Z_STREAM_ERROR;\n  }\n\n  if (strm.state.wrap !== 2) {\n    return Z_STREAM_ERROR;\n  }\n\n  strm.state.gzhead = head;\n  return Z_OK;\n}\n\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n  if (!strm) {\n    // === Z_NULL\n    return Z_STREAM_ERROR;\n  }\n\n  var wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION) {\n    level = 6;\n  }\n\n  if (windowBits < 0) {\n    /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  } else if (windowBits > 15) {\n    wrap = 2;\n    /* write gzip wrapper instead */\n\n    windowBits -= 16;\n  }\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n\n  var s = new DeflateState();\n  strm.state = s;\n  s.strm = strm;\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n  s.window = new utils.Buf8(s.w_size * 2);\n  s.head = new utils.Buf16(s.hash_size);\n  s.prev = new utils.Buf16(s.w_size); // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << memLevel + 6;\n  /* 16K elements by default */\n\n  s.pending_buf_size = s.lit_bufsize * 4; //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n  //s->pending_buf = (uchf *) overlay;\n\n  s.pending_buf = new utils.Buf8(s.pending_buf_size); // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n\n  s.d_buf = 1 * s.lit_bufsize; //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n\n  s.l_buf = (1 + 2) * s.lit_bufsize;\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n  return deflateReset(strm);\n}\n\nfunction deflateInit(strm, level) {\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n}\n\nfunction deflate(strm, flush) {\n  var old_flush, s;\n  var beg, val; // for gzip header write only\n\n  if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n\n  if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {\n    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);\n  }\n\n  s.strm = strm;\n  /* just in case */\n\n  old_flush = s.last_flush;\n  s.last_flush = flush;\n  /* Write the header */\n\n  if (s.status === INIT_STATE) {\n    if (s.wrap === 2) {\n      // GZIP header\n      strm.adler = 0; //crc32(0L, Z_NULL, 0);\n\n      put_byte(s, 31);\n      put_byte(s, 139);\n      put_byte(s, 8);\n\n      if (!s.gzhead) {\n        // s->gzhead == Z_NULL\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n        put_byte(s, OS_CODE);\n        s.status = BUSY_STATE;\n      } else {\n        put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));\n        put_byte(s, s.gzhead.time & 0xff);\n        put_byte(s, s.gzhead.time >> 8 & 0xff);\n        put_byte(s, s.gzhead.time >> 16 & 0xff);\n        put_byte(s, s.gzhead.time >> 24 & 0xff);\n        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n        put_byte(s, s.gzhead.os & 0xff);\n\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff);\n          put_byte(s, s.gzhead.extra.length >> 8 & 0xff);\n        }\n\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n        }\n\n        s.gzindex = 0;\n        s.status = EXTRA_STATE;\n      }\n    } else // DEFLATE header\n      {\n        var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;\n        var level_flags = -1;\n\n        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n          level_flags = 0;\n        } else if (s.level < 6) {\n          level_flags = 1;\n        } else if (s.level === 6) {\n          level_flags = 2;\n        } else {\n          level_flags = 3;\n        }\n\n        header |= level_flags << 6;\n\n        if (s.strstart !== 0) {\n          header |= PRESET_DICT;\n        }\n\n        header += 31 - header % 31;\n        s.status = BUSY_STATE;\n        putShortMSB(s, header);\n        /* Save the adler32 of the preset dictionary: */\n\n        if (s.strstart !== 0) {\n          putShortMSB(s, strm.adler >>> 16);\n          putShortMSB(s, strm.adler & 0xffff);\n        }\n\n        strm.adler = 1; // adler32(0L, Z_NULL, 0);\n      }\n  } //#ifdef GZIP\n\n\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra\n    /* != Z_NULL*/\n    ) {\n        beg = s.pending;\n        /* start of bytes to update crc */\n\n        while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n          if (s.pending === s.pending_buf_size) {\n            if (s.gzhead.hcrc && s.pending > beg) {\n              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n            }\n\n            flush_pending(strm);\n            beg = s.pending;\n\n            if (s.pending === s.pending_buf_size) {\n              break;\n            }\n          }\n\n          put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n          s.gzindex++;\n        }\n\n        if (s.gzhead.hcrc && s.pending > beg) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n        }\n\n        if (s.gzindex === s.gzhead.extra.length) {\n          s.gzindex = 0;\n          s.status = NAME_STATE;\n        }\n      } else {\n      s.status = NAME_STATE;\n    }\n  }\n\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name\n    /* != Z_NULL*/\n    ) {\n        beg = s.pending;\n        /* start of bytes to update crc */\n        //int val;\n\n        do {\n          if (s.pending === s.pending_buf_size) {\n            if (s.gzhead.hcrc && s.pending > beg) {\n              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n            }\n\n            flush_pending(strm);\n            beg = s.pending;\n\n            if (s.pending === s.pending_buf_size) {\n              val = 1;\n              break;\n            }\n          } // JS specific: little magic to add zero terminator to end of string\n\n\n          if (s.gzindex < s.gzhead.name.length) {\n            val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n          } else {\n            val = 0;\n          }\n\n          put_byte(s, val);\n        } while (val !== 0);\n\n        if (s.gzhead.hcrc && s.pending > beg) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n        }\n\n        if (val === 0) {\n          s.gzindex = 0;\n          s.status = COMMENT_STATE;\n        }\n      } else {\n      s.status = COMMENT_STATE;\n    }\n  }\n\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment\n    /* != Z_NULL*/\n    ) {\n        beg = s.pending;\n        /* start of bytes to update crc */\n        //int val;\n\n        do {\n          if (s.pending === s.pending_buf_size) {\n            if (s.gzhead.hcrc && s.pending > beg) {\n              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n            }\n\n            flush_pending(strm);\n            beg = s.pending;\n\n            if (s.pending === s.pending_buf_size) {\n              val = 1;\n              break;\n            }\n          } // JS specific: little magic to add zero terminator to end of string\n\n\n          if (s.gzindex < s.gzhead.comment.length) {\n            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n          } else {\n            val = 0;\n          }\n\n          put_byte(s, val);\n        } while (val !== 0);\n\n        if (s.gzhead.hcrc && s.pending > beg) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n        }\n\n        if (val === 0) {\n          s.status = HCRC_STATE;\n        }\n      } else {\n      s.status = HCRC_STATE;\n    }\n  }\n\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n      }\n\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, strm.adler >> 8 & 0xff);\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\n\n        s.status = BUSY_STATE;\n      }\n    } else {\n      s.status = BUSY_STATE;\n    }\n  } //#endif\n\n  /* Flush as much pending output as possible */\n\n\n  if (s.pending !== 0) {\n    flush_pending(strm);\n\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK;\n    }\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {\n    return err(strm, Z_BUF_ERROR);\n  }\n  /* User must not provide more input after the first FINISH: */\n\n\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR);\n  }\n  /* Start a new block or continue the current one.\n   */\n\n\n  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {\n    var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n\n      return Z_OK;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        trees._tr_align(s);\n      } else if (flush !== Z_BLOCK) {\n        /* FULL_FLUSH or SYNC_FLUSH */\n        trees._tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n\n\n        if (flush === Z_FULL_FLUSH) {\n          /*** CLEAR_HASH(s); ***/\n\n          /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n\n      flush_pending(strm);\n\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR at next call, see above */\n\n        return Z_OK;\n      }\n    }\n  } //Assert(strm->avail_out > 0, \"bug2\");\n  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n\n  if (flush !== Z_FINISH) {\n    return Z_OK;\n  }\n\n  if (s.wrap <= 0) {\n    return Z_STREAM_END;\n  }\n  /* Write the trailer */\n\n\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, strm.adler >> 8 & 0xff);\n    put_byte(s, strm.adler >> 16 & 0xff);\n    put_byte(s, strm.adler >> 24 & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, strm.total_in >> 8 & 0xff);\n    put_byte(s, strm.total_in >> 16 & 0xff);\n    put_byte(s, strm.total_in >> 24 & 0xff);\n  } else {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n\n  if (s.wrap > 0) {\n    s.wrap = -s.wrap;\n  }\n  /* write the trailer only once! */\n\n\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n}\n\nfunction deflateEnd(strm) {\n  var status;\n\n  if (!strm\n  /*== Z_NULL*/\n  || !strm.state\n  /*== Z_NULL*/\n  ) {\n      return Z_STREAM_ERROR;\n    }\n\n  status = strm.state.status;\n\n  if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.state = null;\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n}\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\n\n\nfunction deflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n  var s;\n  var str, n;\n  var wrap;\n  var avail;\n  var next;\n  var input;\n  var tmpDict;\n\n  if (!strm\n  /*== Z_NULL*/\n  || !strm.state\n  /*== Z_NULL*/\n  ) {\n      return Z_STREAM_ERROR;\n    }\n\n  s = strm.state;\n  wrap = s.wrap;\n\n  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {\n    return Z_STREAM_ERROR;\n  }\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n\n\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;\n  /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {\n      /* already empty otherwise */\n\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n\n\n    tmpDict = new utils.Buf8(s.w_size);\n    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n\n\n  avail = strm.avail_in;\n  next = strm.next_in;\n  input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n\n  while (s.lookahead >= MIN_MATCH) {\n    str = s.strstart;\n    n = s.lookahead - (MIN_MATCH - 1);\n\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK;\n}\n\nexports.deflateInit = deflateInit;\nexports.deflateInit2 = deflateInit2;\nexports.deflateReset = deflateReset;\nexports.deflateResetKeep = deflateResetKeep;\nexports.deflateSetHeader = deflateSetHeader;\nexports.deflate = deflate;\nexports.deflateEnd = deflateEnd;\nexports.deflateSetDictionary = deflateSetDictionary;\nexports.deflateInfo = 'pako deflate (from Nodeca project)';\n/* Not implemented\nexports.deflateBound = deflateBound;\nexports.deflateCopy = deflateCopy;\nexports.deflateParams = deflateParams;\nexports.deflatePending = deflatePending;\nexports.deflatePrime = deflatePrime;\nexports.deflateTune = deflateTune;\n*///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9kZWZsYXRlLmpzP2ExNzciXSwibmFtZXMiOlsidXRpbHMiLCJ0cmVlcyIsImFkbGVyMzIiLCJjcmMzMiIsIm1zZyIsIlpfTk9fRkxVU0giLCJaX1BBUlRJQUxfRkxVU0giLCJaX0ZVTExfRkxVU0giLCJaX0ZJTklTSCIsIlpfQkxPQ0siLCJaX09LIiwiWl9TVFJFQU1fRU5EIiwiWl9TVFJFQU1fRVJST1IiLCJaX0RBVEFfRVJST1IiLCJaX0JVRl9FUlJPUiIsIlpfREVGQVVMVF9DT01QUkVTU0lPTiIsIlpfRklMVEVSRUQiLCJaX0hVRkZNQU5fT05MWSIsIlpfUkxFIiwiWl9GSVhFRCIsIlpfREVGQVVMVF9TVFJBVEVHWSIsIlpfVU5LTk9XTiIsIlpfREVGTEFURUQiLCJNQVhfTUVNX0xFVkVMIiwiTUFYX1dCSVRTIiwiREVGX01FTV9MRVZFTCIsIkxFTkdUSF9DT0RFUyIsIkxJVEVSQUxTIiwiTF9DT0RFUyIsIkRfQ09ERVMiLCJCTF9DT0RFUyIsIkhFQVBfU0laRSIsIk1BWF9CSVRTIiwiTUlOX01BVENIIiwiTUFYX01BVENIIiwiTUlOX0xPT0tBSEVBRCIsIlBSRVNFVF9ESUNUIiwiSU5JVF9TVEFURSIsIkVYVFJBX1NUQVRFIiwiTkFNRV9TVEFURSIsIkNPTU1FTlRfU1RBVEUiLCJIQ1JDX1NUQVRFIiwiQlVTWV9TVEFURSIsIkZJTklTSF9TVEFURSIsIkJTX05FRURfTU9SRSIsIkJTX0JMT0NLX0RPTkUiLCJCU19GSU5JU0hfU1RBUlRFRCIsIkJTX0ZJTklTSF9ET05FIiwiT1NfQ09ERSIsImVyciIsInN0cm0iLCJlcnJvckNvZGUiLCJyYW5rIiwiZiIsInplcm8iLCJidWYiLCJsZW4iLCJsZW5ndGgiLCJmbHVzaF9wZW5kaW5nIiwicyIsInN0YXRlIiwicGVuZGluZyIsImF2YWlsX291dCIsImFycmF5U2V0Iiwib3V0cHV0IiwicGVuZGluZ19idWYiLCJwZW5kaW5nX291dCIsIm5leHRfb3V0IiwidG90YWxfb3V0IiwiZmx1c2hfYmxvY2tfb25seSIsImxhc3QiLCJfdHJfZmx1c2hfYmxvY2siLCJibG9ja19zdGFydCIsInN0cnN0YXJ0IiwicHV0X2J5dGUiLCJiIiwicHV0U2hvcnRNU0IiLCJyZWFkX2J1ZiIsInN0YXJ0Iiwic2l6ZSIsImF2YWlsX2luIiwiaW5wdXQiLCJuZXh0X2luIiwid3JhcCIsImFkbGVyIiwidG90YWxfaW4iLCJsb25nZXN0X21hdGNoIiwiY3VyX21hdGNoIiwiY2hhaW5fbGVuZ3RoIiwibWF4X2NoYWluX2xlbmd0aCIsInNjYW4iLCJtYXRjaCIsImJlc3RfbGVuIiwicHJldl9sZW5ndGgiLCJuaWNlX21hdGNoIiwibGltaXQiLCJ3X3NpemUiLCJfd2luIiwid2luZG93Iiwid21hc2siLCJ3X21hc2siLCJwcmV2Iiwic3RyZW5kIiwic2Nhbl9lbmQxIiwic2Nhbl9lbmQiLCJnb29kX21hdGNoIiwibG9va2FoZWFkIiwibWF0Y2hfc3RhcnQiLCJmaWxsX3dpbmRvdyIsIl93X3NpemUiLCJwIiwibiIsIm0iLCJtb3JlIiwic3RyIiwid2luZG93X3NpemUiLCJoYXNoX3NpemUiLCJoZWFkIiwiaW5zZXJ0IiwiaW5zX2giLCJoYXNoX3NoaWZ0IiwiaGFzaF9tYXNrIiwiZGVmbGF0ZV9zdG9yZWQiLCJmbHVzaCIsIm1heF9ibG9ja19zaXplIiwicGVuZGluZ19idWZfc2l6ZSIsIm1heF9zdGFydCIsImRlZmxhdGVfZmFzdCIsImhhc2hfaGVhZCIsImJmbHVzaCIsIm1hdGNoX2xlbmd0aCIsIl90cl90YWxseSIsIm1heF9sYXp5X21hdGNoIiwibGFzdF9saXQiLCJkZWZsYXRlX3Nsb3ciLCJtYXhfaW5zZXJ0IiwicHJldl9tYXRjaCIsInN0cmF0ZWd5IiwibWF0Y2hfYXZhaWxhYmxlIiwiZGVmbGF0ZV9ybGUiLCJkZWZsYXRlX2h1ZmYiLCJDb25maWciLCJnb29kX2xlbmd0aCIsIm1heF9sYXp5IiwibmljZV9sZW5ndGgiLCJtYXhfY2hhaW4iLCJmdW5jIiwiY29uZmlndXJhdGlvbl90YWJsZSIsImxtX2luaXQiLCJsZXZlbCIsIkRlZmxhdGVTdGF0ZSIsInN0YXR1cyIsImd6aGVhZCIsImd6aW5kZXgiLCJtZXRob2QiLCJsYXN0X2ZsdXNoIiwid19iaXRzIiwiaGFzaF9iaXRzIiwiZHluX2x0cmVlIiwiQnVmMTYiLCJkeW5fZHRyZWUiLCJibF90cmVlIiwibF9kZXNjIiwiZF9kZXNjIiwiYmxfZGVzYyIsImJsX2NvdW50IiwiaGVhcCIsImhlYXBfbGVuIiwiaGVhcF9tYXgiLCJkZXB0aCIsImxfYnVmIiwibGl0X2J1ZnNpemUiLCJkX2J1ZiIsIm9wdF9sZW4iLCJzdGF0aWNfbGVuIiwibWF0Y2hlcyIsImJpX2J1ZiIsImJpX3ZhbGlkIiwiZGVmbGF0ZVJlc2V0S2VlcCIsImRhdGFfdHlwZSIsIl90cl9pbml0IiwiZGVmbGF0ZVJlc2V0IiwicmV0IiwiZGVmbGF0ZVNldEhlYWRlciIsImRlZmxhdGVJbml0MiIsIndpbmRvd0JpdHMiLCJtZW1MZXZlbCIsIkJ1ZjgiLCJkZWZsYXRlSW5pdCIsImRlZmxhdGUiLCJvbGRfZmx1c2giLCJiZWciLCJ2YWwiLCJ0ZXh0IiwiaGNyYyIsImV4dHJhIiwibmFtZSIsImNvbW1lbnQiLCJ0aW1lIiwib3MiLCJoZWFkZXIiLCJsZXZlbF9mbGFncyIsImNoYXJDb2RlQXQiLCJic3RhdGUiLCJfdHJfYWxpZ24iLCJfdHJfc3RvcmVkX2Jsb2NrIiwiZGVmbGF0ZUVuZCIsImRlZmxhdGVTZXREaWN0aW9uYXJ5IiwiZGljdGlvbmFyeSIsImRpY3RMZW5ndGgiLCJhdmFpbCIsIm5leHQiLCJ0bXBEaWN0IiwiZXhwb3J0cyIsImRlZmxhdGVJbmZvIl0sIm1hcHBpbmdzIjoiQ0FFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSUEsS0FBSyxHQUFLLG1CQUFPLENBQUMsZ0VBQUQsQ0FBckI7O0FBQ0EsSUFBSUMs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QVIsR0FBMkJBLGdCQUEzQjtBQUNBOEIsT0FBTyxDQUFDeEIsT0FBUixHQUFrQkEsT0FBbEI7QUFDQXdCLE9BQU8sQ0FBQ1AsVUFBUixHQUFxQkEsVUFBckI7QUFDQU8sT0FBTyxDQUFDTixvQkFBUixHQUErQkEsb0JBQS9CO0FBQ0FNLE9BQU8sQ0FBQ0MsV0FBUixHQUFzQixvQ0FBdEI7QUFFQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2RlZmxhdGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIHV0aWxzICAgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcbnZhciB0cmVlcyAgID0gcmVxdWlyZSgnLi90cmVlcycpO1xudmFyIGFkbGVyMzIgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcbnZhciBjcmMzMiAgID0gcmVxdWlyZSgnLi9jcmMzMicpO1xudmFyIG1zZyAgICAgPSByZXF1aXJlKCcuL21lc3NhZ2VzJyk7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbnZhciBaX05PX0ZMVVNIICAgICAgPSAwO1xudmFyIFpfUEFSVElBTF9GTFVTSCA9IDE7XG4vL3ZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xudmFyIFpfRlVMTF9GTFVTSCAgICA9IDM7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcbnZhciBaX0JMT0NLICAgICAgICAgPSA1O1xuLy92YXIgWl9UUkVFUyAgICAgICAgID0gNjtcblxuXG4vKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gKi9cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG4vL3ZhciBaX05FRURfRElDVCAgICAgPSAyO1xuLy92YXIgWl9FUlJOTyAgICAgICAgID0gLTE7XG52YXIgWl9TVFJFQU1fRVJST1IgID0gLTI7XG52YXIgWl9EQVRBX0VSUk9SICAgID0gLTM7XG4vL3ZhciBaX01FTV9FUlJPUiAgICAgPSAtNDtcbnZhciBaX0JVRl9FUlJPUiAgICAgPSAtNTtcbi8vdmFyIFpfVkVSU0lPTl9FUlJPUiA9IC02O1xuXG5cbi8qIGNvbXByZXNzaW9uIGxldmVscyAqL1xuLy92YXIgWl9OT19DT01QUkVTU0lPTiAgICAgID0gMDtcbi8vdmFyIFpfQkVTVF9TUEVFRCAgICAgICAgICA9IDE7XG4vL3ZhciBaX0JFU1RfQ09NUFJFU1NJT04gICAgPSA5O1xudmFyIFpfREVGQVVMVF9DT01QUkVTU0lPTiA9IC0xO1xuXG5cbnZhciBaX0ZJTFRFUkVEICAgICAgICAgICAgPSAxO1xudmFyIFpfSFVGRk1BTl9PTkxZICAgICAgICA9IDI7XG52YXIgWl9STEUgICAgICAgICAgICAgICAgID0gMztcbnZhciBaX0ZJWEVEICAgICAgICAgICAgICAgPSA0O1xudmFyIFpfREVGQVVMVF9TVFJBVEVHWSAgICA9IDA7XG5cbi8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbi8vdmFyIFpfQklOQVJZICAgICAgICAgICAgICA9IDA7XG4vL3ZhciBaX1RFWFQgICAgICAgICAgICAgICAgPSAxO1xuLy92YXIgWl9BU0NJSSAgICAgICAgICAgICAgID0gMTsgLy8gPSBaX1RFWFRcbnZhciBaX1VOS05PV04gICAgICAgICAgICAgPSAyO1xuXG5cbi8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xudmFyIFpfREVGTEFURUQgID0gODtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG52YXIgTUFYX01FTV9MRVZFTCA9IDk7XG4vKiBNYXhpbXVtIHZhbHVlIGZvciBtZW1MZXZlbCBpbiBkZWZsYXRlSW5pdDIgKi9cbnZhciBNQVhfV0JJVFMgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xudmFyIERFRl9NRU1fTEVWRUwgPSA4O1xuXG5cbnZhciBMRU5HVEhfQ09ERVMgID0gMjk7XG4vKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGVzLCBub3QgY291bnRpbmcgdGhlIHNwZWNpYWwgRU5EX0JMT0NLIGNvZGUgKi9cbnZhciBMSVRFUkFMUyAgICAgID0gMjU2O1xuLyogbnVtYmVyIG9mIGxpdGVyYWwgYnl0ZXMgMC4uMjU1ICovXG52YXIgTF9DT0RFUyAgICAgICA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUztcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xudmFyIERfQ09ERVMgICAgICAgPSAzMDtcbi8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlcyAqL1xudmFyIEJMX0NPREVTICAgICAgPSAxOTtcbi8qIG51bWJlciBvZiBjb2RlcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSBiaXQgbGVuZ3RocyAqL1xudmFyIEhFQVBfU0laRSAgICAgPSAyICogTF9DT0RFUyArIDE7XG4vKiBtYXhpbXVtIGhlYXAgc2l6ZSAqL1xudmFyIE1BWF9CSVRTICA9IDE1O1xuLyogQWxsIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQklUUyBiaXRzICovXG5cbnZhciBNSU5fTUFUQ0ggPSAzO1xudmFyIE1BWF9NQVRDSCA9IDI1ODtcbnZhciBNSU5fTE9PS0FIRUFEID0gKE1BWF9NQVRDSCArIE1JTl9NQVRDSCArIDEpO1xuXG52YXIgUFJFU0VUX0RJQ1QgPSAweDIwO1xuXG52YXIgSU5JVF9TVEFURSA9IDQyO1xudmFyIEVYVFJBX1NUQVRFID0gNjk7XG52YXIgTkFNRV9TVEFURSA9IDczO1xudmFyIENPTU1FTlRfU1RBVEUgPSA5MTtcbnZhciBIQ1JDX1NUQVRFID0gMTAzO1xudmFyIEJVU1lfU1RBVEUgPSAxMTM7XG52YXIgRklOSVNIX1NUQVRFID0gNjY2O1xuXG52YXIgQlNfTkVFRF9NT1JFICAgICAgPSAxOyAvKiBibG9jayBub3QgY29tcGxldGVkLCBuZWVkIG1vcmUgaW5wdXQgb3IgbW9yZSBvdXRwdXQgKi9cbnZhciBCU19CTE9DS19ET05FICAgICA9IDI7IC8qIGJsb2NrIGZsdXNoIHBlcmZvcm1lZCAqL1xudmFyIEJTX0ZJTklTSF9TVEFSVEVEID0gMzsgLyogZmluaXNoIHN0YXJ0ZWQsIG5lZWQgb25seSBtb3JlIG91dHB1dCBhdCBuZXh0IGRlZmxhdGUgKi9cbnZhciBCU19GSU5JU0hfRE9ORSAgICA9IDQ7IC8qIGZpbmlzaCBkb25lLCBhY2NlcHQgbm8gbW9yZSBpbnB1dCBvciBvdXRwdXQgKi9cblxudmFyIE9TX0NPREUgPSAweDAzOyAvLyBVbml4IDopIC4gRG9uJ3QgZGV0ZWN0LCB1c2UgdGhpcyBkZWZhdWx0LlxuXG5mdW5jdGlvbiBlcnIoc3RybSwgZXJyb3JDb2RlKSB7XG4gIHN0cm0ubXNnID0gbXNnW2Vycm9yQ29kZV07XG4gIHJldHVybiBlcnJvckNvZGU7XG59XG5cbmZ1bmN0aW9uIHJhbmsoZikge1xuICByZXR1cm4gKChmKSA8PCAxKSAtICgoZikgPiA0ID8gOSA6IDApO1xufVxuXG5mdW5jdGlvbiB6ZXJvKGJ1ZikgeyB2YXIgbGVuID0gYnVmLmxlbmd0aDsgd2hpbGUgKC0tbGVuID49IDApIHsgYnVmW2xlbl0gPSAwOyB9IH1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlLiBBbGwgZGVmbGF0ZSgpIG91dHB1dCBnb2VzXG4gKiB0aHJvdWdoIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0XG4gKiB0byBhdm9pZCBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+b3V0cHV0IGJ1ZmZlciBhbmQgY29weWluZyBpbnRvIGl0LlxuICogKFNlZSBhbHNvIHJlYWRfYnVmKCkpLlxuICovXG5mdW5jdGlvbiBmbHVzaF9wZW5kaW5nKHN0cm0pIHtcbiAgdmFyIHMgPSBzdHJtLnN0YXRlO1xuXG4gIC8vX3RyX2ZsdXNoX2JpdHMocyk7XG4gIHZhciBsZW4gPSBzLnBlbmRpbmc7XG4gIGlmIChsZW4gPiBzdHJtLmF2YWlsX291dCkge1xuICAgIGxlbiA9IHN0cm0uYXZhaWxfb3V0O1xuICB9XG4gIGlmIChsZW4gPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgdXRpbHMuYXJyYXlTZXQoc3RybS5vdXRwdXQsIHMucGVuZGluZ19idWYsIHMucGVuZGluZ19vdXQsIGxlbiwgc3RybS5uZXh0X291dCk7XG4gIHN0cm0ubmV4dF9vdXQgKz0gbGVuO1xuICBzLnBlbmRpbmdfb3V0ICs9IGxlbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gbGVuO1xuICBzdHJtLmF2YWlsX291dCAtPSBsZW47XG4gIHMucGVuZGluZyAtPSBsZW47XG4gIGlmIChzLnBlbmRpbmcgPT09IDApIHtcbiAgICBzLnBlbmRpbmdfb3V0ID0gMDtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGZsdXNoX2Jsb2NrX29ubHkocywgbGFzdCkge1xuICB0cmVlcy5fdHJfZmx1c2hfYmxvY2socywgKHMuYmxvY2tfc3RhcnQgPj0gMCA/IHMuYmxvY2tfc3RhcnQgOiAtMSksIHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0LCBsYXN0KTtcbiAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIGZsdXNoX3BlbmRpbmcocy5zdHJtKTtcbn1cblxuXG5mdW5jdGlvbiBwdXRfYnl0ZShzLCBiKSB7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBQdXQgYSBzaG9ydCBpbiB0aGUgcGVuZGluZyBidWZmZXIuIFRoZSAxNi1iaXQgdmFsdWUgaXMgcHV0IGluIE1TQiBvcmRlci5cbiAqIElOIGFzc2VydGlvbjogdGhlIHN0cmVhbSBzdGF0ZSBpcyBjb3JyZWN0IGFuZCB0aGVyZSBpcyBlbm91Z2ggcm9vbSBpblxuICogcGVuZGluZ19idWYuXG4gKi9cbmZ1bmN0aW9uIHB1dFNob3J0TVNCKHMsIGIpIHtcbi8vICBwdXRfYnl0ZShzLCAoQnl0ZSkoYiA+PiA4KSk7XG4vLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgJiAweGZmKSk7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKGIgPj4+IDgpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiICYgMHhmZjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlYWQgYSBuZXcgYnVmZmVyIGZyb20gdGhlIGN1cnJlbnQgaW5wdXQgc3RyZWFtLCB1cGRhdGUgdGhlIGFkbGVyMzJcbiAqIGFuZCB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC4gIEFsbCBkZWZsYXRlKCkgaW5wdXQgZ29lcyB0aHJvdWdoXG4gKiB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdCB0byBhdm9pZFxuICogYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPmlucHV0IGJ1ZmZlciBhbmQgY29weWluZyBmcm9tIGl0LlxuICogKFNlZSBhbHNvIGZsdXNoX3BlbmRpbmcoKSkuXG4gKi9cbmZ1bmN0aW9uIHJlYWRfYnVmKHN0cm0sIGJ1Ziwgc3RhcnQsIHNpemUpIHtcbiAgdmFyIGxlbiA9IHN0cm0uYXZhaWxfaW47XG5cbiAgaWYgKGxlbiA+IHNpemUpIHsgbGVuID0gc2l6ZTsgfVxuICBpZiAobGVuID09PSAwKSB7IHJldHVybiAwOyB9XG5cbiAgc3RybS5hdmFpbF9pbiAtPSBsZW47XG5cbiAgLy8gem1lbWNweShidWYsIHN0cm0tPm5leHRfaW4sIGxlbik7XG4gIHV0aWxzLmFycmF5U2V0KGJ1Ziwgc3RybS5pbnB1dCwgc3RybS5uZXh0X2luLCBsZW4sIHN0YXJ0KTtcbiAgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMSkge1xuICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBlbHNlIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDIpIHtcbiAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiArPSBsZW47XG4gIHN0cm0udG90YWxfaW4gKz0gbGVuO1xuXG4gIHJldHVybiBsZW47XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZXQgbWF0Y2hfc3RhcnQgdG8gdGhlIGxvbmdlc3QgbWF0Y2ggc3RhcnRpbmcgYXQgdGhlIGdpdmVuIHN0cmluZyBhbmRcbiAqIHJldHVybiBpdHMgbGVuZ3RoLiBNYXRjaGVzIHNob3J0ZXIgb3IgZXF1YWwgdG8gcHJldl9sZW5ndGggYXJlIGRpc2NhcmRlZCxcbiAqIGluIHdoaWNoIGNhc2UgdGhlIHJlc3VsdCBpcyBlcXVhbCB0byBwcmV2X2xlbmd0aCBhbmQgbWF0Y2hfc3RhcnQgaXNcbiAqIGdhcmJhZ2UuXG4gKiBJTiBhc3NlcnRpb25zOiBjdXJfbWF0Y2ggaXMgdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gZm9yIHRoZSBjdXJyZW50XG4gKiAgIHN0cmluZyAoc3Ryc3RhcnQpIGFuZCBpdHMgZGlzdGFuY2UgaXMgPD0gTUFYX0RJU1QsIGFuZCBwcmV2X2xlbmd0aCA+PSAxXG4gKiBPVVQgYXNzZXJ0aW9uOiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdCBncmVhdGVyIHRoYW4gcy0+bG9va2FoZWFkLlxuICovXG5mdW5jdGlvbiBsb25nZXN0X21hdGNoKHMsIGN1cl9tYXRjaCkge1xuICB2YXIgY2hhaW5fbGVuZ3RoID0gcy5tYXhfY2hhaW5fbGVuZ3RoOyAgICAgIC8qIG1heCBoYXNoIGNoYWluIGxlbmd0aCAqL1xuICB2YXIgc2NhbiA9IHMuc3Ryc3RhcnQ7IC8qIGN1cnJlbnQgc3RyaW5nICovXG4gIHZhciBtYXRjaDsgICAgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoZWQgc3RyaW5nICovXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgbWF0Y2ggKi9cbiAgdmFyIGJlc3RfbGVuID0gcy5wcmV2X2xlbmd0aDsgICAgICAgICAgICAgIC8qIGJlc3QgbWF0Y2ggbGVuZ3RoIHNvIGZhciAqL1xuICB2YXIgbmljZV9tYXRjaCA9IHMubmljZV9tYXRjaDsgICAgICAgICAgICAgLyogc3RvcCBpZiBtYXRjaCBsb25nIGVub3VnaCAqL1xuICB2YXIgbGltaXQgPSAocy5zdHJzdGFydCA+IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSA/XG4gICAgICBzLnN0cnN0YXJ0IC0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgOiAwLypOSUwqLztcblxuICB2YXIgX3dpbiA9IHMud2luZG93OyAvLyBzaG9ydGN1dFxuXG4gIHZhciB3bWFzayA9IHMud19tYXNrO1xuICB2YXIgcHJldiAgPSBzLnByZXY7XG5cbiAgLyogU3RvcCB3aGVuIGN1cl9tYXRjaCBiZWNvbWVzIDw9IGxpbWl0LiBUbyBzaW1wbGlmeSB0aGUgY29kZSxcbiAgICogd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZyBvZiB3aW5kb3cgaW5kZXggMC5cbiAgICovXG5cbiAgdmFyIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XG4gIHZhciBzY2FuX2VuZDEgID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTtcbiAgdmFyIHNjYW5fZW5kICAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07XG5cbiAgLyogVGhlIGNvZGUgaXMgb3B0aW1pemVkIGZvciBIQVNIX0JJVFMgPj0gOCBhbmQgTUFYX01BVENILTIgbXVsdGlwbGUgb2YgMTYuXG4gICAqIEl0IGlzIGVhc3kgdG8gZ2V0IHJpZCBvZiB0aGlzIG9wdGltaXphdGlvbiBpZiBuZWNlc3NhcnkuXG4gICAqL1xuICAvLyBBc3NlcnQocy0+aGFzaF9iaXRzID49IDggJiYgTUFYX01BVENIID09IDI1OCwgXCJDb2RlIHRvbyBjbGV2ZXJcIik7XG5cbiAgLyogRG8gbm90IHdhc3RlIHRvbyBtdWNoIHRpbWUgaWYgd2UgYWxyZWFkeSBoYXZlIGEgZ29vZCBtYXRjaDogKi9cbiAgaWYgKHMucHJldl9sZW5ndGggPj0gcy5nb29kX21hdGNoKSB7XG4gICAgY2hhaW5fbGVuZ3RoID4+PSAyO1xuICB9XG4gIC8qIERvIG5vdCBsb29rIGZvciBtYXRjaGVzIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBpbnB1dC4gVGhpcyBpcyBuZWNlc3NhcnlcbiAgICogdG8gbWFrZSBkZWZsYXRlIGRldGVybWluaXN0aWMuXG4gICAqL1xuICBpZiAobmljZV9tYXRjaCA+IHMubG9va2FoZWFkKSB7IG5pY2VfbWF0Y2ggPSBzLmxvb2thaGVhZDsgfVxuXG4gIC8vIEFzc2VydCgodWxnKXMtPnN0cnN0YXJ0IDw9IHMtPndpbmRvd19zaXplLU1JTl9MT09LQUhFQUQsIFwibmVlZCBsb29rYWhlYWRcIik7XG5cbiAgZG8ge1xuICAgIC8vIEFzc2VydChjdXJfbWF0Y2ggPCBzLT5zdHJzdGFydCwgXCJubyBmdXR1cmVcIik7XG4gICAgbWF0Y2ggPSBjdXJfbWF0Y2g7XG5cbiAgICAvKiBTa2lwIHRvIG5leHQgbWF0Y2ggaWYgdGhlIG1hdGNoIGxlbmd0aCBjYW5ub3QgaW5jcmVhc2VcbiAgICAgKiBvciBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIGxlc3MgdGhhbiAyLiAgTm90ZSB0aGF0IHRoZSBjaGVja3MgYmVsb3dcbiAgICAgKiBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IG9jY3VyIG9jY2FzaW9uYWxseSBmb3IgcGVyZm9ybWFuY2VcbiAgICAgKiByZWFzb25zLiAgVGhlcmVmb3JlIHVuaW5pdGlhbGl6ZWQgbWVtb3J5IHdpbGwgYmUgYWNjZXNzZWQsIGFuZFxuICAgICAqIGNvbmRpdGlvbmFsIGp1bXBzIHdpbGwgYmUgbWFkZSB0aGF0IGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMuXG4gICAgICogSG93ZXZlciB0aGUgbGVuZ3RoIG9mIHRoZSBtYXRjaCBpcyBsaW1pdGVkIHRvIHRoZSBsb29rYWhlYWQsIHNvXG4gICAgICogdGhlIG91dHB1dCBvZiBkZWZsYXRlIGlzIG5vdCBhZmZlY3RlZCBieSB0aGUgdW5pbml0aWFsaXplZCB2YWx1ZXMuXG4gICAgICovXG5cbiAgICBpZiAoX3dpblttYXRjaCArIGJlc3RfbGVuXSAgICAgIT09IHNjYW5fZW5kICB8fFxuICAgICAgICBfd2luW21hdGNoICsgYmVzdF9sZW4gLSAxXSAhPT0gc2Nhbl9lbmQxIHx8XG4gICAgICAgIF93aW5bbWF0Y2hdICAgICAgICAgICAgICAgICE9PSBfd2luW3NjYW5dIHx8XG4gICAgICAgIF93aW5bKyttYXRjaF0gICAgICAgICAgICAgICE9PSBfd2luW3NjYW4gKyAxXSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyogVGhlIGNoZWNrIGF0IGJlc3RfbGVuLTEgY2FuIGJlIHJlbW92ZWQgYmVjYXVzZSBpdCB3aWxsIGJlIG1hZGVcbiAgICAgKiBhZ2FpbiBsYXRlci4gKFRoaXMgaGV1cmlzdGljIGlzIG5vdCBhbHdheXMgYSB3aW4uKVxuICAgICAqIEl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gY29tcGFyZSBzY2FuWzJdIGFuZCBtYXRjaFsyXSBzaW5jZSB0aGV5XG4gICAgICogYXJlIGFsd2F5cyBlcXVhbCB3aGVuIHRoZSBvdGhlciBieXRlcyBtYXRjaCwgZ2l2ZW4gdGhhdFxuICAgICAqIHRoZSBoYXNoIGtleXMgYXJlIGVxdWFsIGFuZCB0aGF0IEhBU0hfQklUUyA+PSA4LlxuICAgICAqL1xuICAgIHNjYW4gKz0gMjtcbiAgICBtYXRjaCsrO1xuICAgIC8vIEFzc2VydCgqc2NhbiA9PSAqbWF0Y2gsIFwibWF0Y2hbMl0/XCIpO1xuXG4gICAgLyogV2UgY2hlY2sgZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBldmVyeSA4dGggY29tcGFyaXNvbjtcbiAgICAgKiB0aGUgMjU2dGggY2hlY2sgd2lsbCBiZSBtYWRlIGF0IHN0cnN0YXJ0KzI1OC5cbiAgICAgKi9cbiAgICBkbyB7XG4gICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICB9IHdoaWxlIChfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgc2NhbiA8IHN0cmVuZCk7XG5cbiAgICAvLyBBc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVuc2lnbmVkKShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG5cbiAgICBsZW4gPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgc2NhbiA9IHN0cmVuZCAtIE1BWF9NQVRDSDtcblxuICAgIGlmIChsZW4gPiBiZXN0X2xlbikge1xuICAgICAgcy5tYXRjaF9zdGFydCA9IGN1cl9tYXRjaDtcbiAgICAgIGJlc3RfbGVuID0gbGVuO1xuICAgICAgaWYgKGxlbiA+PSBuaWNlX21hdGNoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gICAgICBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuICAgIH1cbiAgfSB3aGlsZSAoKGN1cl9tYXRjaCA9IHByZXZbY3VyX21hdGNoICYgd21hc2tdKSA+IGxpbWl0ICYmIC0tY2hhaW5fbGVuZ3RoICE9PSAwKTtcblxuICBpZiAoYmVzdF9sZW4gPD0gcy5sb29rYWhlYWQpIHtcbiAgICByZXR1cm4gYmVzdF9sZW47XG4gIH1cbiAgcmV0dXJuIHMubG9va2FoZWFkO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmlsbCB0aGUgd2luZG93IHdoZW4gdGhlIGxvb2thaGVhZCBiZWNvbWVzIGluc3VmZmljaWVudC5cbiAqIFVwZGF0ZXMgc3Ryc3RhcnQgYW5kIGxvb2thaGVhZC5cbiAqXG4gKiBJTiBhc3NlcnRpb246IGxvb2thaGVhZCA8IE1JTl9MT09LQUhFQURcbiAqIE9VVCBhc3NlcnRpb25zOiBzdHJzdGFydCA8PSB3aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFEXG4gKiAgICBBdCBsZWFzdCBvbmUgYnl0ZSBoYXMgYmVlbiByZWFkLCBvciBhdmFpbF9pbiA9PSAwOyByZWFkcyBhcmVcbiAqICAgIHBlcmZvcm1lZCBmb3IgYXQgbGVhc3QgdHdvIGJ5dGVzIChyZXF1aXJlZCBmb3IgdGhlIHppcCB0cmFuc2xhdGVfZW9sXG4gKiAgICBvcHRpb24gLS0gbm90IHN1cHBvcnRlZCBoZXJlKS5cbiAqL1xuZnVuY3Rpb24gZmlsbF93aW5kb3cocykge1xuICB2YXIgX3dfc2l6ZSA9IHMud19zaXplO1xuICB2YXIgcCwgbiwgbSwgbW9yZSwgc3RyO1xuXG4gIC8vQXNzZXJ0KHMtPmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQsIFwiYWxyZWFkeSBlbm91Z2ggbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICBtb3JlID0gcy53aW5kb3dfc2l6ZSAtIHMubG9va2FoZWFkIC0gcy5zdHJzdGFydDtcblxuICAgIC8vIEpTIGludHMgaGF2ZSAzMiBiaXQsIGJsb2NrIGJlbG93IG5vdCBuZWVkZWRcbiAgICAvKiBEZWFsIHdpdGggIUAjJCUgNjRLIGxpbWl0OiAqL1xuICAgIC8vaWYgKHNpemVvZihpbnQpIDw9IDIpIHtcbiAgICAvLyAgICBpZiAobW9yZSA9PSAwICYmIHMtPnN0cnN0YXJ0ID09IDAgJiYgcy0+bG9va2FoZWFkID09IDApIHtcbiAgICAvLyAgICAgICAgbW9yZSA9IHdzaXplO1xuICAgIC8vXG4gICAgLy8gIH0gZWxzZSBpZiAobW9yZSA9PSAodW5zaWduZWQpKC0xKSkge1xuICAgIC8vICAgICAgICAvKiBWZXJ5IHVubGlrZWx5LCBidXQgcG9zc2libGUgb24gMTYgYml0IG1hY2hpbmUgaWZcbiAgICAvLyAgICAgICAgICogc3Ryc3RhcnQgPT0gMCAmJiBsb29rYWhlYWQgPT0gMSAoaW5wdXQgZG9uZSBhIGJ5dGUgYXQgdGltZSlcbiAgICAvLyAgICAgICAgICovXG4gICAgLy8gICAgICAgIG1vcmUtLTtcbiAgICAvLyAgICB9XG4gICAgLy99XG5cblxuICAgIC8qIElmIHRoZSB3aW5kb3cgaXMgYWxtb3N0IGZ1bGwgYW5kIHRoZXJlIGlzIGluc3VmZmljaWVudCBsb29rYWhlYWQsXG4gICAgICogbW92ZSB0aGUgdXBwZXIgaGFsZiB0byB0aGUgbG93ZXIgb25lIHRvIG1ha2Ugcm9vbSBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCA+PSBfd19zaXplICsgKF93X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuXG4gICAgICB1dGlscy5hcnJheVNldChzLndpbmRvdywgcy53aW5kb3csIF93X3NpemUsIF93X3NpemUsIDApO1xuICAgICAgcy5tYXRjaF9zdGFydCAtPSBfd19zaXplO1xuICAgICAgcy5zdHJzdGFydCAtPSBfd19zaXplO1xuICAgICAgLyogd2Ugbm93IGhhdmUgc3Ryc3RhcnQgPj0gTUFYX0RJU1QgKi9cbiAgICAgIHMuYmxvY2tfc3RhcnQgLT0gX3dfc2l6ZTtcblxuICAgICAgLyogU2xpZGUgdGhlIGhhc2ggdGFibGUgKGNvdWxkIGJlIGF2b2lkZWQgd2l0aCAzMiBiaXQgdmFsdWVzXG4gICAgICAgYXQgdGhlIGV4cGVuc2Ugb2YgbWVtb3J5IHVzYWdlKS4gV2Ugc2xpZGUgZXZlbiB3aGVuIGxldmVsID09IDBcbiAgICAgICB0byBrZWVwIHRoZSBoYXNoIHRhYmxlIGNvbnNpc3RlbnQgaWYgd2Ugc3dpdGNoIGJhY2sgdG8gbGV2ZWwgPiAwXG4gICAgICAgbGF0ZXIuIChVc2luZyBsZXZlbCAwIHBlcm1hbmVudGx5IGlzIG5vdCBhbiBvcHRpbWFsIHVzYWdlIG9mXG4gICAgICAgemxpYiwgc28gd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGlzIHBhdGhvbG9naWNhbCBjYXNlLilcbiAgICAgICAqL1xuXG4gICAgICBuID0gcy5oYXNoX3NpemU7XG4gICAgICBwID0gbjtcbiAgICAgIGRvIHtcbiAgICAgICAgbSA9IHMuaGVhZFstLXBdO1xuICAgICAgICBzLmhlYWRbcF0gPSAobSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwKTtcbiAgICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAgIG4gPSBfd19zaXplO1xuICAgICAgcCA9IG47XG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLnByZXZbLS1wXTtcbiAgICAgICAgcy5wcmV2W3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICAgIC8qIElmIG4gaXMgbm90IG9uIGFueSBoYXNoIGNoYWluLCBwcmV2W25dIGlzIGdhcmJhZ2UgYnV0XG4gICAgICAgICAqIGl0cyB2YWx1ZSB3aWxsIG5ldmVyIGJlIHVzZWQuXG4gICAgICAgICAqL1xuICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgbW9yZSArPSBfd19zaXplO1xuICAgIH1cbiAgICBpZiAocy5zdHJtLmF2YWlsX2luID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvKiBJZiB0aGVyZSB3YXMgbm8gc2xpZGluZzpcbiAgICAgKiAgICBzdHJzdGFydCA8PSBXU0laRStNQVhfRElTVC0xICYmIGxvb2thaGVhZCA8PSBNSU5fTE9PS0FIRUFEIC0gMSAmJlxuICAgICAqICAgIG1vcmUgPT0gd2luZG93X3NpemUgLSBsb29rYWhlYWQgLSBzdHJzdGFydFxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAoTUlOX0xPT0tBSEVBRC0xICsgV1NJWkUgKyBNQVhfRElTVC0xKVxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAyKldTSVpFICsgMlxuICAgICAqIEluIHRoZSBCSUdfTUVNIG9yIE1NQVAgY2FzZSAobm90IHlldCBzdXBwb3J0ZWQpLFxuICAgICAqICAgd2luZG93X3NpemUgPT0gaW5wdXRfc2l6ZSArIE1JTl9MT09LQUhFQUQgICYmXG4gICAgICogICBzdHJzdGFydCArIHMtPmxvb2thaGVhZCA8PSBpbnB1dF9zaXplID0+IG1vcmUgPj0gTUlOX0xPT0tBSEVBRC5cbiAgICAgKiBPdGhlcndpc2UsIHdpbmRvd19zaXplID09IDIqV1NJWkUgc28gbW9yZSA+PSAyLlxuICAgICAqIElmIHRoZXJlIHdhcyBzbGlkaW5nLCBtb3JlID49IFdTSVpFLiBTbyBpbiBhbGwgY2FzZXMsIG1vcmUgPj0gMi5cbiAgICAgKi9cbiAgICAvL0Fzc2VydChtb3JlID49IDIsIFwibW9yZSA8IDJcIik7XG4gICAgbiA9IHJlYWRfYnVmKHMuc3RybSwgcy53aW5kb3csIHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCwgbW9yZSk7XG4gICAgcy5sb29rYWhlYWQgKz0gbjtcblxuICAgIC8qIEluaXRpYWxpemUgdGhlIGhhc2ggdmFsdWUgbm93IHRoYXQgd2UgaGF2ZSBzb21lIGlucHV0OiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0ID49IE1JTl9NQVRDSCkge1xuICAgICAgc3RyID0gcy5zdHJzdGFydCAtIHMuaW5zZXJ0O1xuICAgICAgcy5pbnNfaCA9IHMud2luZG93W3N0cl07XG5cbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgMV0pOyAqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgMV0pICYgcy5oYXNoX21hc2s7XG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgIENhbGwgdXBkYXRlX2hhc2goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgd2hpbGUgKHMuaW5zZXJ0KSB7XG4gICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG5cbiAgICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyO1xuICAgICAgICBzdHIrKztcbiAgICAgICAgcy5pbnNlcnQtLTtcbiAgICAgICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPCBNSU5fTUFUQ0gpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGUgd2hvbGUgaW5wdXQgaGFzIGxlc3MgdGhhbiBNSU5fTUFUQ0ggYnl0ZXMsIGluc19oIGlzIGdhcmJhZ2UsXG4gICAgICogYnV0IHRoaXMgaXMgbm90IGltcG9ydGFudCBzaW5jZSBvbmx5IGxpdGVyYWwgYnl0ZXMgd2lsbCBiZSBlbWl0dGVkLlxuICAgICAqL1xuXG4gIH0gd2hpbGUgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBzLnN0cm0uYXZhaWxfaW4gIT09IDApO1xuXG4gIC8qIElmIHRoZSBXSU5fSU5JVCBieXRlcyBhZnRlciB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGRhdGEgaGF2ZSBuZXZlciBiZWVuXG4gICAqIHdyaXR0ZW4sIHRoZW4gemVybyB0aG9zZSBieXRlcyBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgY2hlY2sgcmVwb3J0cyBvZlxuICAgKiB0aGUgdXNlIG9mIHVuaW5pdGlhbGl6ZWQgKG9yIHVuaW5pdGlhbGlzZWQgYXMgSnVsaWFuIHdyaXRlcykgYnl0ZXMgYnlcbiAgICogdGhlIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMuICBVcGRhdGUgdGhlIGhpZ2ggd2F0ZXIgbWFyayBmb3IgdGhlIG5leHRcbiAgICogdGltZSB0aHJvdWdoIGhlcmUuICBXSU5fSU5JVCBpcyBzZXQgdG8gTUFYX01BVENIIHNpbmNlIHRoZSBsb25nZXN0IG1hdGNoXG4gICAqIHJvdXRpbmVzIGFsbG93IHNjYW5uaW5nIHRvIHN0cnN0YXJ0ICsgTUFYX01BVENILCBpZ25vcmluZyBsb29rYWhlYWQuXG4gICAqL1xuLy8gIGlmIChzLmhpZ2hfd2F0ZXIgPCBzLndpbmRvd19zaXplKSB7XG4vLyAgICB2YXIgY3VyciA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZDtcbi8vICAgIHZhciBpbml0ID0gMDtcbi8vXG4vLyAgICBpZiAocy5oaWdoX3dhdGVyIDwgY3Vycikge1xuLy8gICAgICAvKiBQcmV2aW91cyBoaWdoIHdhdGVyIG1hcmsgYmVsb3cgY3VycmVudCBkYXRhIC0tIHplcm8gV0lOX0lOSVRcbi8vICAgICAgICogYnl0ZXMgb3IgdXAgdG8gZW5kIG9mIHdpbmRvdywgd2hpY2hldmVyIGlzIGxlc3MuXG4vLyAgICAgICAqL1xuLy8gICAgICBpbml0ID0gcy53aW5kb3dfc2l6ZSAtIGN1cnI7XG4vLyAgICAgIGlmIChpbml0ID4gV0lOX0lOSVQpXG4vLyAgICAgICAgaW5pdCA9IFdJTl9JTklUO1xuLy8gICAgICB6bWVtemVybyhzLT53aW5kb3cgKyBjdXJyLCAodW5zaWduZWQpaW5pdCk7XG4vLyAgICAgIHMtPmhpZ2hfd2F0ZXIgPSBjdXJyICsgaW5pdDtcbi8vICAgIH1cbi8vICAgIGVsc2UgaWYgKHMtPmhpZ2hfd2F0ZXIgPCAodWxnKWN1cnIgKyBXSU5fSU5JVCkge1xuLy8gICAgICAvKiBIaWdoIHdhdGVyIG1hcmsgYXQgb3IgYWJvdmUgY3VycmVudCBkYXRhLCBidXQgYmVsb3cgY3VycmVudCBkYXRhXG4vLyAgICAgICAqIHBsdXMgV0lOX0lOSVQgLS0gemVybyBvdXQgdG8gY3VycmVudCBkYXRhIHBsdXMgV0lOX0lOSVQsIG9yIHVwXG4vLyAgICAgICAqIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9ICh1bGcpY3VyciArIFdJTl9JTklUIC0gcy0+aGlnaF93YXRlcjtcbi8vICAgICAgaWYgKGluaXQgPiBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXIpXG4vLyAgICAgICAgaW5pdCA9IHMtPndpbmRvd19zaXplIC0gcy0+aGlnaF93YXRlcjtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgcy0+aGlnaF93YXRlciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyICs9IGluaXQ7XG4vLyAgICB9XG4vLyAgfVxuLy9cbi8vICBBc3NlcnQoKHVsZylzLT5zdHJzdGFydCA8PSBzLT53aW5kb3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQsXG4vLyAgICBcIm5vdCBlbm91Z2ggcm9vbSBmb3Igc2VhcmNoXCIpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgd2l0aG91dCBjb21wcmVzc2lvbiBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuXG4gKiB0aGUgY3VycmVudCBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgaW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IHNpbmNlXG4gKiB1bmNvbXByZXNzaWJsZSBkYXRhIGlzIHByb2JhYmx5IG5vdCB1c2VmdWwuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZFxuICogb25seSBmb3IgdGhlIGxldmVsPTAgY29tcHJlc3Npb24gb3B0aW9uLlxuICogTk9URTogdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgb3B0aW1pemVkIHRvIGF2b2lkIGV4dHJhIGNvcHlpbmcgZnJvbVxuICogd2luZG93IHRvIHBlbmRpbmdfYnVmLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3N0b3JlZChzLCBmbHVzaCkge1xuICAvKiBTdG9yZWQgYmxvY2tzIGFyZSBsaW1pdGVkIHRvIDB4ZmZmZiBieXRlcywgcGVuZGluZ19idWYgaXMgbGltaXRlZFxuICAgKiB0byBwZW5kaW5nX2J1Zl9zaXplLCBhbmQgZWFjaCBzdG9yZWQgYmxvY2sgaGFzIGEgNSBieXRlIGhlYWRlcjpcbiAgICovXG4gIHZhciBtYXhfYmxvY2tfc2l6ZSA9IDB4ZmZmZjtcblxuICBpZiAobWF4X2Jsb2NrX3NpemUgPiBzLnBlbmRpbmdfYnVmX3NpemUgLSA1KSB7XG4gICAgbWF4X2Jsb2NrX3NpemUgPSBzLnBlbmRpbmdfYnVmX3NpemUgLSA1O1xuICB9XG5cbiAgLyogQ29weSBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gaW5wdXQgdG8gb3V0cHV0OiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogRmlsbCB0aGUgd2luZG93IGFzIG11Y2ggYXMgcG9zc2libGU6ICovXG4gICAgaWYgKHMubG9va2FoZWFkIDw9IDEpIHtcblxuICAgICAgLy9Bc3NlcnQocy0+c3Ryc3RhcnQgPCBzLT53X3NpemUrTUFYX0RJU1QocykgfHxcbiAgICAgIC8vICBzLT5ibG9ja19zdGFydCA+PSAobG9uZylzLT53X3NpemUsIFwic2xpZGUgdG9vIGxhdGVcIik7XG4vLyAgICAgIGlmICghKHMuc3Ryc3RhcnQgPCBzLndfc2l6ZSArIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHx8XG4vLyAgICAgICAgcy5ibG9ja19zdGFydCA+PSBzLndfc2l6ZSkpIHtcbi8vICAgICAgICB0aHJvdyAgbmV3IEVycm9yKFwic2xpZGUgdG9vIGxhdGVcIik7XG4vLyAgICAgIH1cblxuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDAgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cblxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG4gICAgLy9Bc3NlcnQocy0+YmxvY2tfc3RhcnQgPj0gMEwsIFwiYmxvY2sgZ29uZVwiKTtcbi8vICAgIGlmIChzLmJsb2NrX3N0YXJ0IDwgMCkgdGhyb3cgbmV3IEVycm9yKFwiYmxvY2sgZ29uZVwiKTtcblxuICAgIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gICAgcy5sb29rYWhlYWQgPSAwO1xuXG4gICAgLyogRW1pdCBhIHN0b3JlZCBibG9jayBpZiBwZW5kaW5nX2J1ZiB3aWxsIGJlIGZ1bGw6ICovXG4gICAgdmFyIG1heF9zdGFydCA9IHMuYmxvY2tfc3RhcnQgKyBtYXhfYmxvY2tfc2l6ZTtcblxuICAgIGlmIChzLnN0cnN0YXJ0ID09PSAwIHx8IHMuc3Ryc3RhcnQgPj0gbWF4X3N0YXJ0KSB7XG4gICAgICAvKiBzdHJzdGFydCA9PSAwIGlzIHBvc3NpYmxlIHdoZW4gd3JhcGFyb3VuZCBvbiAxNi1iaXQgbWFjaGluZSAqL1xuICAgICAgcy5sb29rYWhlYWQgPSBzLnN0cnN0YXJ0IC0gbWF4X3N0YXJ0O1xuICAgICAgcy5zdHJzdGFydCA9IG1heF9zdGFydDtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG5cblxuICAgIH1cbiAgICAvKiBGbHVzaCBpZiB3ZSBtYXkgaGF2ZSB0byBzbGlkZSwgb3RoZXJ3aXNlIGJsb2NrX3N0YXJ0IG1heSBiZWNvbWVcbiAgICAgKiBuZWdhdGl2ZSBhbmQgdGhlIGRhdGEgd2lsbCBiZSBnb25lOlxuICAgICAqL1xuICAgIGlmIChzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCA+PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cblxuICBzLmluc2VydCA9IDA7XG5cbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG5cbiAgaWYgKHMuc3Ryc3RhcnQgPiBzLmJsb2NrX3N0YXJ0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG5cbiAgcmV0dXJuIEJTX05FRURfTU9SRTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wcmVzcyBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuIHRoZSBjdXJyZW50XG4gKiBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcGVyZm9ybSBsYXp5IGV2YWx1YXRpb24gb2YgbWF0Y2hlcyBhbmQgaW5zZXJ0c1xuICogbmV3IHN0cmluZ3MgaW4gdGhlIGRpY3Rpb25hcnkgb25seSBmb3IgdW5tYXRjaGVkIHN0cmluZ3Mgb3IgZm9yIHNob3J0XG4gKiBtYXRjaGVzLiBJdCBpcyB1c2VkIG9ubHkgZm9yIHRoZSBmYXN0IGNvbXByZXNzaW9uIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfZmFzdChzLCBmbHVzaCkge1xuICB2YXIgaGFzaF9oZWFkOyAgICAgICAgLyogaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiAqL1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhazsgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXG4gICAgICogZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XG4gICAgICovXG4gICAgaGFzaF9oZWFkID0gMC8qTklMKi87XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKiBBdCB0aGlzIHBvaW50IHdlIGhhdmUgYWx3YXlzIG1hdGNoX2xlbmd0aCA8IE1JTl9NQVRDSFxuICAgICAqL1xuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmICgocy5zdHJzdGFydCAtIGhhc2hfaGVhZCkgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpKSB7XG4gICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXG4gICAgICAgKiBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpO1xuICAgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cbiAgICB9XG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy8gY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGgpOyAvLyBmb3IgZGVidWcgb25seVxuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcblxuICAgICAgLyogSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aFxuICAgICAgICogaXMgbm90IHRvbyBsYXJnZS4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICAgICAqL1xuICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IHMubWF4X2xhenlfbWF0Y2gvKm1heF9pbnNlcnRfbGVuZ3RoKi8gJiYgcy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoLS07IC8qIHN0cmluZyBhdCBzdHJzdGFydCBhbHJlYWR5IGluIHRhYmxlICovXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICAgIC8qIHN0cnN0YXJ0IG5ldmVyIGV4Y2VlZHMgV1NJWkUtTUFYX01BVENILCBzbyB0aGVyZSBhcmVcbiAgICAgICAgICAgKiBhbHdheXMgTUlOX01BVENIIGJ5dGVzIGFoZWFkLlxuICAgICAgICAgICAqL1xuICAgICAgICB9IHdoaWxlICgtLXMubWF0Y2hfbGVuZ3RoICE9PSAwKTtcbiAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgfSBlbHNlXG4gICAgICB7XG4gICAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAgICAgcy5pbnNfaCA9IHMud2luZG93W3Muc3Ryc3RhcnRdO1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0KzFdKTsgKi9cbiAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgICAgICAgICAgQ2FsbCBVUERBVEVfSEFTSCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbi8vI2VuZGlmXG4gICAgICAgIC8qIElmIGxvb2thaGVhZCA8IE1JTl9NQVRDSCwgaW5zX2ggaXMgZ2FyYmFnZSwgYnV0IGl0IGRvZXMgbm90XG4gICAgICAgICAqIG1hdHRlciBzaW5jZSBpdCB3aWxsIGJlIHJlY29tcHV0ZWQgYXQgbmV4dCBkZWZsYXRlIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMud2luZG93W3Muc3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gKChzLnN0cnN0YXJ0IDwgKE1JTl9NQVRDSCAtIDEpKSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxKTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhbWUgYXMgYWJvdmUsIGJ1dCBhY2hpZXZlcyBiZXR0ZXIgY29tcHJlc3Npb24uIFdlIHVzZSBhIGxhenlcbiAqIGV2YWx1YXRpb24gZm9yIG1hdGNoZXM6IGEgbWF0Y2ggaXMgZmluYWxseSBhZG9wdGVkIG9ubHkgaWYgdGhlcmUgaXNcbiAqIG5vIGJldHRlciBtYXRjaCBhdCB0aGUgbmV4dCB3aW5kb3cgcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfc2xvdyhzLCBmbHVzaCkge1xuICB2YXIgaGFzaF9oZWFkOyAgICAgICAgICAvKiBoZWFkIG9mIGhhc2ggY2hhaW4gKi9cbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIHZhciBtYXhfaW5zZXJ0O1xuXG4gIC8qIFByb2Nlc3MgdGhlIGlucHV0IGJsb2NrLiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcbiAgICAgKiBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICovXG4gICAgcy5wcmV2X2xlbmd0aCA9IHMubWF0Y2hfbGVuZ3RoO1xuICAgIHMucHJldl9tYXRjaCA9IHMubWF0Y2hfc3RhcnQ7XG4gICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuXG4gICAgaWYgKGhhc2hfaGVhZCAhPT0gMC8qTklMKi8gJiYgcy5wcmV2X2xlbmd0aCA8IHMubWF4X2xhenlfbWF0Y2ggJiZcbiAgICAgICAgcy5zdHJzdGFydCAtIGhhc2hfaGVhZCA8PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKS8qTUFYX0RJU1QocykqLykge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG5cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSA1ICYmXG4gICAgICAgICAocy5zdHJhdGVneSA9PT0gWl9GSUxURVJFRCB8fCAocy5tYXRjaF9sZW5ndGggPT09IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCA+IDQwOTYvKlRPT19GQVIqLykpKSB7XG5cbiAgICAgICAgLyogSWYgcHJldl9tYXRjaCBpcyBhbHNvIE1JTl9NQVRDSCwgbWF0Y2hfc3RhcnQgaXMgZ2FyYmFnZVxuICAgICAgICAgKiBidXQgd2Ugd2lsbCBpZ25vcmUgdGhlIGN1cnJlbnQgbWF0Y2ggYW55d2F5LlxuICAgICAgICAgKi9cbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBhdCB0aGUgcHJldmlvdXMgc3RlcCBhbmQgdGhlIGN1cnJlbnRcbiAgICAgKiBtYXRjaCBpcyBub3QgYmV0dGVyLCBvdXRwdXQgdGhlIHByZXZpb3VzIG1hdGNoOlxuICAgICAqL1xuICAgIGlmIChzLnByZXZfbGVuZ3RoID49IE1JTl9NQVRDSCAmJiBzLm1hdGNoX2xlbmd0aCA8PSBzLnByZXZfbGVuZ3RoKSB7XG4gICAgICBtYXhfaW5zZXJ0ID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkIC0gTUlOX01BVENIO1xuICAgICAgLyogRG8gbm90IGluc2VydCBzdHJpbmdzIGluIGhhc2ggdGFibGUgYmV5b25kIHRoaXMuICovXG5cbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydC0xLCBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGgpO1xuXG4gICAgICAvKioqX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsXG4gICAgICAgICAgICAgICAgICAgICBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gMSAtIHMucHJldl9tYXRjaCwgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCk7XG4gICAgICAvKiBJbnNlcnQgaW4gaGFzaCB0YWJsZSBhbGwgc3RyaW5ncyB1cCB0byB0aGUgZW5kIG9mIHRoZSBtYXRjaC5cbiAgICAgICAqIHN0cnN0YXJ0LTEgYW5kIHN0cnN0YXJ0IGFyZSBhbHJlYWR5IGluc2VydGVkLiBJZiB0aGVyZSBpcyBub3RcbiAgICAgICAqIGVub3VnaCBsb29rYWhlYWQsIHRoZSBsYXN0IHR3byBzdHJpbmdzIGFyZSBub3QgaW5zZXJ0ZWQgaW5cbiAgICAgICAqIHRoZSBoYXNoIHRhYmxlLlxuICAgICAgICovXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLnByZXZfbGVuZ3RoIC0gMTtcbiAgICAgIHMucHJldl9sZW5ndGggLT0gMjtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKCsrcy5zdHJzdGFydCA8PSBtYXhfaW5zZXJ0KSB7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICgtLXMucHJldl9sZW5ndGggIT09IDApO1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICAvKioqL1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgICAgLyogSWYgdGhlcmUgd2FzIG5vIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBwb3NpdGlvbiwgb3V0cHV0IGFcbiAgICAgICAqIHNpbmdsZSBsaXRlcmFsLiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBidXQgdGhlIGN1cnJlbnQgbWF0Y2hcbiAgICAgICAqIGlzIGxvbmdlciwgdHJ1bmNhdGUgdGhlIHByZXZpb3VzIG1hdGNoIHRvIGEgc2luZ2xlIGxpdGVyYWwuXG4gICAgICAgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7XG5cbiAgICAgIGlmIChiZmx1c2gpIHtcbiAgICAgICAgLyoqKiBGTFVTSF9CTE9DS19PTkxZKHMsIDApICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIC8qKiovXG4gICAgICB9XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogVGhlcmUgaXMgbm8gcHJldmlvdXMgbWF0Y2ggdG8gY29tcGFyZSB3aXRoLCB3YWl0IGZvclxuICAgICAgICogdGhlIG5leHQgc3RlcCB0byBkZWNpZGUuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChmbHVzaCAhPSBaX05PX0ZMVVNILCBcIm5vIGZsdXNoP1wiKTtcbiAgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7XG4gICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnQtMV0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pO1xuXG4gICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICB9XG4gIHMuaW5zZXJ0ID0gcy5zdHJzdGFydCA8IE1JTl9NQVRDSCAtIDEgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG5cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9STEUsIHNpbXBseSBsb29rIGZvciBydW5zIG9mIGJ5dGVzLCBnZW5lcmF0ZSBtYXRjaGVzIG9ubHkgb2YgZGlzdGFuY2VcbiAqIG9uZS4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuICAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZlxuICogZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gWl9STEUuKVxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3JsZShzLCBmbHVzaCkge1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuICB2YXIgcHJldjsgICAgICAgICAgICAgIC8qIGJ5dGUgYXQgZGlzdGFuY2Ugb25lIHRvIG1hdGNoICovXG4gIHZhciBzY2FuLCBzdHJlbmQ7ICAgICAgLyogc2NhbiBnb2VzIHVwIHRvIHN0cmVuZCBmb3IgbGVuZ3RoIG9mIHJ1biAqL1xuXG4gIHZhciBfd2luID0gcy53aW5kb3c7XG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBsb25nZXN0IHJ1biwgcGx1cyBvbmUgZm9yIHRoZSB1bnJvbGxlZCBsb29wLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0gpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogU2VlIGhvdyBtYW55IHRpbWVzIHRoZSBwcmV2aW91cyBieXRlIHJlcGVhdHMgKi9cbiAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0ID4gMCkge1xuICAgICAgc2NhbiA9IHMuc3Ryc3RhcnQgLSAxO1xuICAgICAgcHJldiA9IF93aW5bc2Nhbl07XG4gICAgICBpZiAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0pIHtcbiAgICAgICAgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgICAgICB9IHdoaWxlIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTtcbiAgICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoID4gcy5sb29rYWhlYWQpIHtcbiAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IHMubG9va2FoZWFkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL0Fzc2VydChzY2FuIDw9IHMtPndpbmRvdysodUludCkocy0+d2luZG93X3NpemUtMSksIFwid2lsZCBzY2FuXCIpO1xuICAgIH1cblxuICAgIC8qIEVtaXQgbWF0Y2ggaWYgaGF2ZSBydW4gb2YgTUlOX01BVENIIG9yIGxvbmdlciwgZWxzZSBlbWl0IGxpdGVyYWwgKi9cbiAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7XG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMuc3Ryc3RhcnQgLSAxLCBzLm1hdGNoX2xlbmd0aCk7XG5cbiAgICAgIC8qKiogX3RyX3RhbGx5X2Rpc3QocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7XG5cbiAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZvciBaX0hVRkZNQU5fT05MWSwgZG8gbm90IGxvb2sgZm9yIG1hdGNoZXMuICBEbyBub3QgbWFpbnRhaW4gYSBoYXNoIHRhYmxlLlxuICogKEl0IHdpbGwgYmUgcmVnZW5lcmF0ZWQgaWYgdGhpcyBydW4gb2YgZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gSHVmZm1hbi4pXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfaHVmZihzLCBmbHVzaCkge1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgaGF2ZSBhIGxpdGVyYWwgdG8gd3JpdGUuICovXG4gICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrOyAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogT3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG4gICAgcy5sb29rYWhlYWQtLTtcbiAgICBzLnN0cnN0YXJ0Kys7XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qIFZhbHVlcyBmb3IgbWF4X2xhenlfbWF0Y2gsIGdvb2RfbWF0Y2ggYW5kIG1heF9jaGFpbl9sZW5ndGgsIGRlcGVuZGluZyBvblxuICogdGhlIGRlc2lyZWQgcGFjayBsZXZlbCAoMC4uOSkuIFRoZSB2YWx1ZXMgZ2l2ZW4gYmVsb3cgaGF2ZSBiZWVuIHR1bmVkIHRvXG4gKiBleGNsdWRlIHdvcnN0IGNhc2UgcGVyZm9ybWFuY2UgZm9yIHBhdGhvbG9naWNhbCBmaWxlcy4gQmV0dGVyIHZhbHVlcyBtYXkgYmVcbiAqIGZvdW5kIGZvciBzcGVjaWZpYyBmaWxlcy5cbiAqL1xuZnVuY3Rpb24gQ29uZmlnKGdvb2RfbGVuZ3RoLCBtYXhfbGF6eSwgbmljZV9sZW5ndGgsIG1heF9jaGFpbiwgZnVuYykge1xuICB0aGlzLmdvb2RfbGVuZ3RoID0gZ29vZF9sZW5ndGg7XG4gIHRoaXMubWF4X2xhenkgPSBtYXhfbGF6eTtcbiAgdGhpcy5uaWNlX2xlbmd0aCA9IG5pY2VfbGVuZ3RoO1xuICB0aGlzLm1heF9jaGFpbiA9IG1heF9jaGFpbjtcbiAgdGhpcy5mdW5jID0gZnVuYztcbn1cblxudmFyIGNvbmZpZ3VyYXRpb25fdGFibGU7XG5cbmNvbmZpZ3VyYXRpb25fdGFibGUgPSBbXG4gIC8qICAgICAgZ29vZCBsYXp5IG5pY2UgY2hhaW4gKi9cbiAgbmV3IENvbmZpZygwLCAwLCAwLCAwLCBkZWZsYXRlX3N0b3JlZCksICAgICAgICAgIC8qIDAgc3RvcmUgb25seSAqL1xuICBuZXcgQ29uZmlnKDQsIDQsIDgsIDQsIGRlZmxhdGVfZmFzdCksICAgICAgICAgICAgLyogMSBtYXggc3BlZWQsIG5vIGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDQsIDUsIDE2LCA4LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgLyogMiAqL1xuICBuZXcgQ29uZmlnKDQsIDYsIDMyLCAzMiwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgLyogMyAqL1xuXG4gIG5ldyBDb25maWcoNCwgNCwgMTYsIDE2LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgICAvKiA0IGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAzMiwgMzIsIGRlZmxhdGVfc2xvdyksICAgICAgICAgLyogNSAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAxMjgsIDEyOCwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNiAqL1xuICBuZXcgQ29uZmlnKDgsIDMyLCAxMjgsIDI1NiwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNyAqL1xuICBuZXcgQ29uZmlnKDMyLCAxMjgsIDI1OCwgMTAyNCwgZGVmbGF0ZV9zbG93KSwgICAgLyogOCAqL1xuICBuZXcgQ29uZmlnKDMyLCAyNTgsIDI1OCwgNDA5NiwgZGVmbGF0ZV9zbG93KSAgICAgLyogOSBtYXggY29tcHJlc3Npb24gKi9cbl07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSBcImxvbmdlc3QgbWF0Y2hcIiByb3V0aW5lcyBmb3IgYSBuZXcgemxpYiBzdHJlYW1cbiAqL1xuZnVuY3Rpb24gbG1faW5pdChzKSB7XG4gIHMud2luZG93X3NpemUgPSAyICogcy53X3NpemU7XG5cbiAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAvKiBTZXQgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzOlxuICAgKi9cbiAgcy5tYXhfbGF6eV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2xhenk7XG4gIHMuZ29vZF9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZ29vZF9sZW5ndGg7XG4gIHMubmljZV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubmljZV9sZW5ndGg7XG4gIHMubWF4X2NoYWluX2xlbmd0aCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2NoYWluO1xuXG4gIHMuc3Ryc3RhcnQgPSAwO1xuICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLmluc2VydCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgcy5pbnNfaCA9IDA7XG59XG5cblxuZnVuY3Rpb24gRGVmbGF0ZVN0YXRlKCkge1xuICB0aGlzLnN0cm0gPSBudWxsOyAgICAgICAgICAgIC8qIHBvaW50ZXIgYmFjayB0byB0aGlzIHpsaWIgc3RyZWFtICovXG4gIHRoaXMuc3RhdHVzID0gMDsgICAgICAgICAgICAvKiBhcyB0aGUgbmFtZSBpbXBsaWVzICovXG4gIHRoaXMucGVuZGluZ19idWYgPSBudWxsOyAgICAgIC8qIG91dHB1dCBzdGlsbCBwZW5kaW5nICovXG4gIHRoaXMucGVuZGluZ19idWZfc2l6ZSA9IDA7ICAvKiBzaXplIG9mIHBlbmRpbmdfYnVmICovXG4gIHRoaXMucGVuZGluZ19vdXQgPSAwOyAgICAgICAvKiBuZXh0IHBlbmRpbmcgYnl0ZSB0byBvdXRwdXQgdG8gdGhlIHN0cmVhbSAqL1xuICB0aGlzLnBlbmRpbmcgPSAwOyAgICAgICAgICAgLyogbmIgb2YgYnl0ZXMgaW4gdGhlIHBlbmRpbmcgYnVmZmVyICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuZ3poZWFkID0gbnVsbDsgICAgICAgICAvKiBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiB0byB3cml0ZSAqL1xuICB0aGlzLmd6aW5kZXggPSAwOyAgICAgICAgICAgLyogd2hlcmUgaW4gZXh0cmEsIG5hbWUsIG9yIGNvbW1lbnQgKi9cbiAgdGhpcy5tZXRob2QgPSBaX0RFRkxBVEVEOyAvKiBjYW4gb25seSBiZSBERUZMQVRFRCAqL1xuICB0aGlzLmxhc3RfZmx1c2ggPSAtMTsgICAvKiB2YWx1ZSBvZiBmbHVzaCBwYXJhbSBmb3IgcHJldmlvdXMgZGVmbGF0ZSBjYWxsICovXG5cbiAgdGhpcy53X3NpemUgPSAwOyAgLyogTFo3NyB3aW5kb3cgc2l6ZSAoMzJLIGJ5IGRlZmF1bHQpICovXG4gIHRoaXMud19iaXRzID0gMDsgIC8qIGxvZzIod19zaXplKSAgKDguLjE2KSAqL1xuICB0aGlzLndfbWFzayA9IDA7ICAvKiB3X3NpemUgLSAxICovXG5cbiAgdGhpcy53aW5kb3cgPSBudWxsO1xuICAvKiBTbGlkaW5nIHdpbmRvdy4gSW5wdXQgYnl0ZXMgYXJlIHJlYWQgaW50byB0aGUgc2Vjb25kIGhhbGYgb2YgdGhlIHdpbmRvdyxcbiAgICogYW5kIG1vdmUgdG8gdGhlIGZpcnN0IGhhbGYgbGF0ZXIgdG8ga2VlcCBhIGRpY3Rpb25hcnkgb2YgYXQgbGVhc3Qgd1NpemVcbiAgICogYnl0ZXMuIFdpdGggdGhpcyBvcmdhbml6YXRpb24sIG1hdGNoZXMgYXJlIGxpbWl0ZWQgdG8gYSBkaXN0YW5jZSBvZlxuICAgKiB3U2l6ZS1NQVhfTUFUQ0ggYnl0ZXMsIGJ1dCB0aGlzIGVuc3VyZXMgdGhhdCBJTyBpcyBhbHdheXNcbiAgICogcGVyZm9ybWVkIHdpdGggYSBsZW5ndGggbXVsdGlwbGUgb2YgdGhlIGJsb2NrIHNpemUuXG4gICAqL1xuXG4gIHRoaXMud2luZG93X3NpemUgPSAwO1xuICAvKiBBY3R1YWwgc2l6ZSBvZiB3aW5kb3c6IDIqd1NpemUsIGV4Y2VwdCB3aGVuIHRoZSB1c2VyIGlucHV0IGJ1ZmZlclxuICAgKiBpcyBkaXJlY3RseSB1c2VkIGFzIHNsaWRpbmcgd2luZG93LlxuICAgKi9cblxuICB0aGlzLnByZXYgPSBudWxsO1xuICAvKiBMaW5rIHRvIG9sZGVyIHN0cmluZyB3aXRoIHNhbWUgaGFzaCBpbmRleC4gVG8gbGltaXQgdGhlIHNpemUgb2YgdGhpc1xuICAgKiBhcnJheSB0byA2NEssIHRoaXMgbGluayBpcyBtYWludGFpbmVkIG9ubHkgZm9yIHRoZSBsYXN0IDMySyBzdHJpbmdzLlxuICAgKiBBbiBpbmRleCBpbiB0aGlzIGFycmF5IGlzIHRodXMgYSB3aW5kb3cgaW5kZXggbW9kdWxvIDMySy5cbiAgICovXG5cbiAgdGhpcy5oZWFkID0gbnVsbDsgICAvKiBIZWFkcyBvZiB0aGUgaGFzaCBjaGFpbnMgb3IgTklMLiAqL1xuXG4gIHRoaXMuaW5zX2ggPSAwOyAgICAgICAvKiBoYXNoIGluZGV4IG9mIHN0cmluZyB0byBiZSBpbnNlcnRlZCAqL1xuICB0aGlzLmhhc2hfc2l6ZSA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIGhhc2ggdGFibGUgKi9cbiAgdGhpcy5oYXNoX2JpdHMgPSAwOyAgIC8qIGxvZzIoaGFzaF9zaXplKSAqL1xuICB0aGlzLmhhc2hfbWFzayA9IDA7ICAgLyogaGFzaF9zaXplLTEgKi9cblxuICB0aGlzLmhhc2hfc2hpZnQgPSAwO1xuICAvKiBOdW1iZXIgb2YgYml0cyBieSB3aGljaCBpbnNfaCBtdXN0IGJlIHNoaWZ0ZWQgYXQgZWFjaCBpbnB1dFxuICAgKiBzdGVwLiBJdCBtdXN0IGJlIHN1Y2ggdGhhdCBhZnRlciBNSU5fTUFUQ0ggc3RlcHMsIHRoZSBvbGRlc3RcbiAgICogYnl0ZSBubyBsb25nZXIgdGFrZXMgcGFydCBpbiB0aGUgaGFzaCBrZXksIHRoYXQgaXM6XG4gICAqICAgaGFzaF9zaGlmdCAqIE1JTl9NQVRDSCA+PSBoYXNoX2JpdHNcbiAgICovXG5cbiAgdGhpcy5ibG9ja19zdGFydCA9IDA7XG4gIC8qIFdpbmRvdyBwb3NpdGlvbiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjdXJyZW50IG91dHB1dCBibG9jay4gR2V0c1xuICAgKiBuZWdhdGl2ZSB3aGVuIHRoZSB3aW5kb3cgaXMgbW92ZWQgYmFja3dhcmRzLlxuICAgKi9cblxuICB0aGlzLm1hdGNoX2xlbmd0aCA9IDA7ICAgICAgLyogbGVuZ3RoIG9mIGJlc3QgbWF0Y2ggKi9cbiAgdGhpcy5wcmV2X21hdGNoID0gMDsgICAgICAgIC8qIHByZXZpb3VzIG1hdGNoICovXG4gIHRoaXMubWF0Y2hfYXZhaWxhYmxlID0gMDsgICAvKiBzZXQgaWYgcHJldmlvdXMgbWF0Y2ggZXhpc3RzICovXG4gIHRoaXMuc3Ryc3RhcnQgPSAwOyAgICAgICAgICAvKiBzdGFydCBvZiBzdHJpbmcgdG8gaW5zZXJ0ICovXG4gIHRoaXMubWF0Y2hfc3RhcnQgPSAwOyAgICAgICAvKiBzdGFydCBvZiBtYXRjaGluZyBzdHJpbmcgKi9cbiAgdGhpcy5sb29rYWhlYWQgPSAwOyAgICAgICAgIC8qIG51bWJlciBvZiB2YWxpZCBieXRlcyBhaGVhZCBpbiB3aW5kb3cgKi9cblxuICB0aGlzLnByZXZfbGVuZ3RoID0gMDtcbiAgLyogTGVuZ3RoIG9mIHRoZSBiZXN0IG1hdGNoIGF0IHByZXZpb3VzIHN0ZXAuIE1hdGNoZXMgbm90IGdyZWF0ZXIgdGhhbiB0aGlzXG4gICAqIGFyZSBkaXNjYXJkZWQuIFRoaXMgaXMgdXNlZCBpbiB0aGUgbGF6eSBtYXRjaCBldmFsdWF0aW9uLlxuICAgKi9cblxuICB0aGlzLm1heF9jaGFpbl9sZW5ndGggPSAwO1xuICAvKiBUbyBzcGVlZCB1cCBkZWZsYXRpb24sIGhhc2ggY2hhaW5zIGFyZSBuZXZlciBzZWFyY2hlZCBiZXlvbmQgdGhpc1xuICAgKiBsZW5ndGguICBBIGhpZ2hlciBsaW1pdCBpbXByb3ZlcyBjb21wcmVzc2lvbiByYXRpbyBidXQgZGVncmFkZXMgdGhlXG4gICAqIHNwZWVkLlxuICAgKi9cblxuICB0aGlzLm1heF9sYXp5X21hdGNoID0gMDtcbiAgLyogQXR0ZW1wdCB0byBmaW5kIGEgYmV0dGVyIG1hdGNoIG9ubHkgd2hlbiB0aGUgY3VycmVudCBtYXRjaCBpcyBzdHJpY3RseVxuICAgKiBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZS4gVGhpcyBtZWNoYW5pc20gaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvblxuICAgKiBsZXZlbHMgPj0gNC5cbiAgICovXG4gIC8vIFRoYXQncyBhbGlhcyB0byBtYXhfbGF6eV9tYXRjaCwgZG9uJ3QgdXNlIGRpcmVjdGx5XG4gIC8vdGhpcy5tYXhfaW5zZXJ0X2xlbmd0aCA9IDA7XG4gIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbm90XG4gICAqIGdyZWF0ZXIgdGhhbiB0aGlzIGxlbmd0aC4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICogbWF4X2luc2VydF9sZW5ndGggaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvbiBsZXZlbHMgPD0gMy5cbiAgICovXG5cbiAgdGhpcy5sZXZlbCA9IDA7ICAgICAvKiBjb21wcmVzc2lvbiBsZXZlbCAoMS4uOSkgKi9cbiAgdGhpcy5zdHJhdGVneSA9IDA7ICAvKiBmYXZvciBvciBmb3JjZSBIdWZmbWFuIGNvZGluZyovXG5cbiAgdGhpcy5nb29kX21hdGNoID0gMDtcbiAgLyogVXNlIGEgZmFzdGVyIHNlYXJjaCB3aGVuIHRoZSBwcmV2aW91cyBtYXRjaCBpcyBsb25nZXIgdGhhbiB0aGlzICovXG5cbiAgdGhpcy5uaWNlX21hdGNoID0gMDsgLyogU3RvcCBzZWFyY2hpbmcgd2hlbiBjdXJyZW50IG1hdGNoIGV4Y2VlZHMgdGhpcyAqL1xuXG4gICAgICAgICAgICAgIC8qIHVzZWQgYnkgdHJlZXMuYzogKi9cblxuICAvKiBEaWRuJ3QgdXNlIGN0X2RhdGEgdHlwZWRlZiBiZWxvdyB0byBzdXBwcmVzcyBjb21waWxlciB3YXJuaW5nICovXG5cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fbHRyZWVbSEVBUF9TSVpFXTsgICAvKiBsaXRlcmFsIGFuZCBsZW5ndGggdHJlZSAqL1xuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGR5bl9kdHJlZVsyKkRfQ09ERVMrMV07IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBibF90cmVlWzIqQkxfQ09ERVMrMV07ICAvKiBIdWZmbWFuIHRyZWUgZm9yIGJpdCBsZW5ndGhzICovXG5cbiAgLy8gVXNlIGZsYXQgYXJyYXkgb2YgRE9VQkxFIHNpemUsIHdpdGggaW50ZXJsZWF2ZWQgZmF0YSxcbiAgLy8gYmVjYXVzZSBKUyBkb2VzIG5vdCBzdXBwb3J0IGVmZmVjdGl2ZVxuICB0aGlzLmR5bl9sdHJlZSAgPSBuZXcgdXRpbHMuQnVmMTYoSEVBUF9TSVpFICogMik7XG4gIHRoaXMuZHluX2R0cmVlICA9IG5ldyB1dGlscy5CdWYxNigoMiAqIERfQ09ERVMgKyAxKSAqIDIpO1xuICB0aGlzLmJsX3RyZWUgICAgPSBuZXcgdXRpbHMuQnVmMTYoKDIgKiBCTF9DT0RFUyArIDEpICogMik7XG4gIHplcm8odGhpcy5keW5fbHRyZWUpO1xuICB6ZXJvKHRoaXMuZHluX2R0cmVlKTtcbiAgemVybyh0aGlzLmJsX3RyZWUpO1xuXG4gIHRoaXMubF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBsaXRlcmFsIHRyZWUgKi9cbiAgdGhpcy5kX2Rlc2MgICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGRpc3RhbmNlIHRyZWUgKi9cbiAgdGhpcy5ibF9kZXNjICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGJpdCBsZW5ndGggdHJlZSAqL1xuXG4gIC8vdXNoIGJsX2NvdW50W01BWF9CSVRTKzFdO1xuICB0aGlzLmJsX2NvdW50ID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWF9CSVRTICsgMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vaW50IGhlYXBbMipMX0NPREVTKzFdOyAgICAgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB0aGlzLmhlYXAgPSBuZXcgdXRpbHMuQnVmMTYoMiAqIExfQ09ERVMgKyAxKTsgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB6ZXJvKHRoaXMuaGVhcCk7XG5cbiAgdGhpcy5oZWFwX2xlbiA9IDA7ICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBoZWFwICovXG4gIHRoaXMuaGVhcF9tYXggPSAwOyAgICAgICAgICAgICAgIC8qIGVsZW1lbnQgb2YgbGFyZ2VzdCBmcmVxdWVuY3kgKi9cbiAgLyogVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS4gaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICogVGhlIHNhbWUgaGVhcCBhcnJheSBpcyB1c2VkIHRvIGJ1aWxkIGFsbCB0cmVlcy5cbiAgICovXG5cbiAgdGhpcy5kZXB0aCA9IG5ldyB1dGlscy5CdWYxNigyICogTF9DT0RFUyArIDEpOyAvL3VjaCBkZXB0aFsyKkxfQ09ERVMrMV07XG4gIHplcm8odGhpcy5kZXB0aCk7XG4gIC8qIERlcHRoIG9mIGVhY2ggc3VidHJlZSB1c2VkIGFzIHRpZSBicmVha2VyIGZvciB0cmVlcyBvZiBlcXVhbCBmcmVxdWVuY3lcbiAgICovXG5cbiAgdGhpcy5sX2J1ZiA9IDA7ICAgICAgICAgIC8qIGJ1ZmZlciBpbmRleCBmb3IgbGl0ZXJhbHMgb3IgbGVuZ3RocyAqL1xuXG4gIHRoaXMubGl0X2J1ZnNpemUgPSAwO1xuICAvKiBTaXplIG9mIG1hdGNoIGJ1ZmZlciBmb3IgbGl0ZXJhbHMvbGVuZ3Rocy4gIFRoZXJlIGFyZSA0IHJlYXNvbnMgZm9yXG4gICAqIGxpbWl0aW5nIGxpdF9idWZzaXplIHRvIDY0SzpcbiAgICogICAtIGZyZXF1ZW5jaWVzIGNhbiBiZSBrZXB0IGluIDE2IGJpdCBjb3VudGVyc1xuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIHRoZSBmaXJzdCBibG9jaywgYWxsIGlucHV0XG4gICAqICAgICBkYXRhIGlzIHN0aWxsIGluIHRoZSB3aW5kb3cgc28gd2UgY2FuIHN0aWxsIGVtaXQgYSBzdG9yZWQgYmxvY2sgZXZlblxuICAgKiAgICAgd2hlbiBpbnB1dCBjb21lcyBmcm9tIHN0YW5kYXJkIGlucHV0LiAgKFRoaXMgY2FuIGFsc28gYmUgZG9uZSBmb3JcbiAgICogICAgIGFsbCBibG9ja3MgaWYgbGl0X2J1ZnNpemUgaXMgbm90IGdyZWF0ZXIgdGhhbiAzMksuKVxuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIGEgZmlsZSBzbWFsbGVyIHRoYW4gNjRLLCB3ZSBjYW5cbiAgICogICAgIGV2ZW4gZW1pdCBhIHN0b3JlZCBmaWxlIGluc3RlYWQgb2YgYSBzdG9yZWQgYmxvY2sgKHNhdmluZyA1IGJ5dGVzKS5cbiAgICogICAgIFRoaXMgaXMgYXBwbGljYWJsZSBvbmx5IGZvciB6aXAgKG5vdCBnemlwIG9yIHpsaWIpLlxuICAgKiAgIC0gY3JlYXRpbmcgbmV3IEh1ZmZtYW4gdHJlZXMgbGVzcyBmcmVxdWVudGx5IG1heSBub3QgcHJvdmlkZSBmYXN0XG4gICAqICAgICBhZGFwdGF0aW9uIHRvIGNoYW5nZXMgaW4gdGhlIGlucHV0IGRhdGEgc3RhdGlzdGljcy4gKFRha2UgZm9yXG4gICAqICAgICBleGFtcGxlIGEgYmluYXJ5IGZpbGUgd2l0aCBwb29ybHkgY29tcHJlc3NpYmxlIGNvZGUgZm9sbG93ZWQgYnlcbiAgICogICAgIGEgaGlnaGx5IGNvbXByZXNzaWJsZSBzdHJpbmcgdGFibGUuKSBTbWFsbGVyIGJ1ZmZlciBzaXplcyBnaXZlXG4gICAqICAgICBmYXN0IGFkYXB0YXRpb24gYnV0IGhhdmUgb2YgY291cnNlIHRoZSBvdmVyaGVhZCBvZiB0cmFuc21pdHRpbmdcbiAgICogICAgIHRyZWVzIG1vcmUgZnJlcXVlbnRseS5cbiAgICogICAtIEkgY2FuJ3QgY291bnQgYWJvdmUgNFxuICAgKi9cblxuICB0aGlzLmxhc3RfbGl0ID0gMDsgICAgICAvKiBydW5uaW5nIGluZGV4IGluIGxfYnVmICovXG5cbiAgdGhpcy5kX2J1ZiA9IDA7XG4gIC8qIEJ1ZmZlciBpbmRleCBmb3IgZGlzdGFuY2VzLiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgZF9idWYgYW5kIGxfYnVmIGhhdmVcbiAgICogdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzLiBUbyB1c2UgZGlmZmVyZW50IGxlbmd0aHMsIGFuIGV4dHJhIGZsYWdcbiAgICogYXJyYXkgd291bGQgYmUgbmVjZXNzYXJ5LlxuICAgKi9cblxuICB0aGlzLm9wdF9sZW4gPSAwOyAgICAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBvcHRpbWFsIHRyZWVzICovXG4gIHRoaXMuc3RhdGljX2xlbiA9IDA7ICAgIC8qIGJpdCBsZW5ndGggb2YgY3VycmVudCBibG9jayB3aXRoIHN0YXRpYyB0cmVlcyAqL1xuICB0aGlzLm1hdGNoZXMgPSAwOyAgICAgICAvKiBudW1iZXIgb2Ygc3RyaW5nIG1hdGNoZXMgaW4gY3VycmVudCBibG9jayAqL1xuICB0aGlzLmluc2VydCA9IDA7ICAgICAgICAvKiBieXRlcyBhdCBlbmQgb2Ygd2luZG93IGxlZnQgdG8gaW5zZXJ0ICovXG5cblxuICB0aGlzLmJpX2J1ZiA9IDA7XG4gIC8qIE91dHB1dCBidWZmZXIuIGJpdHMgYXJlIGluc2VydGVkIHN0YXJ0aW5nIGF0IHRoZSBib3R0b20gKGxlYXN0XG4gICAqIHNpZ25pZmljYW50IGJpdHMpLlxuICAgKi9cbiAgdGhpcy5iaV92YWxpZCA9IDA7XG4gIC8qIE51bWJlciBvZiB2YWxpZCBiaXRzIGluIGJpX2J1Zi4gIEFsbCBiaXRzIGFib3ZlIHRoZSBsYXN0IHZhbGlkIGJpdFxuICAgKiBhcmUgYWx3YXlzIHplcm8uXG4gICAqL1xuXG4gIC8vIFVzZWQgZm9yIHdpbmRvdyBtZW1vcnkgaW5pdC4gV2Ugc2FmZWx5IGlnbm9yZSBpdCBmb3IgSlMuIFRoYXQgbWFrZXNcbiAgLy8gc2Vuc2Ugb25seSBmb3IgcG9pbnRlcnMgYW5kIG1lbW9yeSBjaGVjayB0b29scy5cbiAgLy90aGlzLmhpZ2hfd2F0ZXIgPSAwO1xuICAvKiBIaWdoIHdhdGVyIG1hcmsgb2Zmc2V0IGluIHdpbmRvdyBmb3IgaW5pdGlhbGl6ZWQgYnl0ZXMgLS0gYnl0ZXMgYWJvdmVcbiAgICogdGhpcyBhcmUgc2V0IHRvIHplcm8gaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHdhcm5pbmdzIHdoZW5cbiAgICogbG9uZ2VzdCBtYXRjaCByb3V0aW5lcyBhY2Nlc3MgYnl0ZXMgcGFzdCB0aGUgaW5wdXQuICBUaGlzIGlzIHRoZW5cbiAgICogdXBkYXRlZCB0byB0aGUgbmV3IGhpZ2ggd2F0ZXIgbWFyay5cbiAgICovXG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKSB7XG4gIHZhciBzO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gMDtcbiAgc3RybS5kYXRhX3R5cGUgPSBaX1VOS05PV047XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG4gIHMucGVuZGluZyA9IDA7XG4gIHMucGVuZGluZ19vdXQgPSAwO1xuXG4gIGlmIChzLndyYXAgPCAwKSB7XG4gICAgcy53cmFwID0gLXMud3JhcDtcbiAgICAvKiB3YXMgbWFkZSBuZWdhdGl2ZSBieSBkZWZsYXRlKC4uLiwgWl9GSU5JU0gpOyAqL1xuICB9XG4gIHMuc3RhdHVzID0gKHMud3JhcCA/IElOSVRfU1RBVEUgOiBCVVNZX1NUQVRFKTtcbiAgc3RybS5hZGxlciA9IChzLndyYXAgPT09IDIpID9cbiAgICAwICAvLyBjcmMzMigwLCBaX05VTEwsIDApXG4gIDpcbiAgICAxOyAvLyBhZGxlcjMyKDAsIFpfTlVMTCwgMClcbiAgcy5sYXN0X2ZsdXNoID0gWl9OT19GTFVTSDtcbiAgdHJlZXMuX3RyX2luaXQocyk7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVSZXNldChzdHJtKSB7XG4gIHZhciByZXQgPSBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuICBpZiAocmV0ID09PSBaX09LKSB7XG4gICAgbG1faW5pdChzdHJtLnN0YXRlKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVTZXRIZWFkZXIoc3RybSwgaGVhZCkge1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgIT09IDIpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0cm0uc3RhdGUuZ3poZWFkID0gaGVhZDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZUluaXQyKHN0cm0sIGxldmVsLCBtZXRob2QsIHdpbmRvd0JpdHMsIG1lbUxldmVsLCBzdHJhdGVneSkge1xuICBpZiAoIXN0cm0pIHsgLy8gPT09IFpfTlVMTFxuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuICB2YXIgd3JhcCA9IDE7XG5cbiAgaWYgKGxldmVsID09PSBaX0RFRkFVTFRfQ09NUFJFU1NJT04pIHtcbiAgICBsZXZlbCA9IDY7XG4gIH1cblxuICBpZiAod2luZG93Qml0cyA8IDApIHsgLyogc3VwcHJlc3MgemxpYiB3cmFwcGVyICovXG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG5cbiAgZWxzZSBpZiAod2luZG93Qml0cyA+IDE1KSB7XG4gICAgd3JhcCA9IDI7ICAgICAgICAgICAvKiB3cml0ZSBnemlwIHdyYXBwZXIgaW5zdGVhZCAqL1xuICAgIHdpbmRvd0JpdHMgLT0gMTY7XG4gIH1cblxuXG4gIGlmIChtZW1MZXZlbCA8IDEgfHwgbWVtTGV2ZWwgPiBNQVhfTUVNX0xFVkVMIHx8IG1ldGhvZCAhPT0gWl9ERUZMQVRFRCB8fFxuICAgIHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSB8fCBsZXZlbCA8IDAgfHwgbGV2ZWwgPiA5IHx8XG4gICAgc3RyYXRlZ3kgPCAwIHx8IHN0cmF0ZWd5ID4gWl9GSVhFRCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cblxuICBpZiAod2luZG93Qml0cyA9PT0gOCkge1xuICAgIHdpbmRvd0JpdHMgPSA5O1xuICB9XG4gIC8qIHVudGlsIDI1Ni1ieXRlIHdpbmRvdyBidWcgZml4ZWQgKi9cblxuICB2YXIgcyA9IG5ldyBEZWZsYXRlU3RhdGUoKTtcblxuICBzdHJtLnN0YXRlID0gcztcbiAgcy5zdHJtID0gc3RybTtcblxuICBzLndyYXAgPSB3cmFwO1xuICBzLmd6aGVhZCA9IG51bGw7XG4gIHMud19iaXRzID0gd2luZG93Qml0cztcbiAgcy53X3NpemUgPSAxIDw8IHMud19iaXRzO1xuICBzLndfbWFzayA9IHMud19zaXplIC0gMTtcblxuICBzLmhhc2hfYml0cyA9IG1lbUxldmVsICsgNztcbiAgcy5oYXNoX3NpemUgPSAxIDw8IHMuaGFzaF9iaXRzO1xuICBzLmhhc2hfbWFzayA9IHMuaGFzaF9zaXplIC0gMTtcbiAgcy5oYXNoX3NoaWZ0ID0gfn4oKHMuaGFzaF9iaXRzICsgTUlOX01BVENIIC0gMSkgLyBNSU5fTUFUQ0gpO1xuXG4gIHMud2luZG93ID0gbmV3IHV0aWxzLkJ1Zjgocy53X3NpemUgKiAyKTtcbiAgcy5oZWFkID0gbmV3IHV0aWxzLkJ1ZjE2KHMuaGFzaF9zaXplKTtcbiAgcy5wcmV2ID0gbmV3IHV0aWxzLkJ1ZjE2KHMud19zaXplKTtcblxuICAvLyBEb24ndCBuZWVkIG1lbSBpbml0IG1hZ2ljIGZvciBKUy5cbiAgLy9zLmhpZ2hfd2F0ZXIgPSAwOyAgLyogbm90aGluZyB3cml0dGVuIHRvIHMtPndpbmRvdyB5ZXQgKi9cblxuICBzLmxpdF9idWZzaXplID0gMSA8PCAobWVtTGV2ZWwgKyA2KTsgLyogMTZLIGVsZW1lbnRzIGJ5IGRlZmF1bHQgKi9cblxuICBzLnBlbmRpbmdfYnVmX3NpemUgPSBzLmxpdF9idWZzaXplICogNDtcblxuICAvL292ZXJsYXkgPSAodXNoZiAqKSBaQUxMT0Moc3RybSwgcy0+bGl0X2J1ZnNpemUsIHNpemVvZih1c2gpKzIpO1xuICAvL3MtPnBlbmRpbmdfYnVmID0gKHVjaGYgKikgb3ZlcmxheTtcbiAgcy5wZW5kaW5nX2J1ZiA9IG5ldyB1dGlscy5CdWY4KHMucGVuZGluZ19idWZfc2l6ZSk7XG5cbiAgLy8gSXQgaXMgb2Zmc2V0IGZyb20gYHMucGVuZGluZ19idWZgIChzaXplIGlzIGBzLmxpdF9idWZzaXplICogMmApXG4gIC8vcy0+ZF9idWYgPSBvdmVybGF5ICsgcy0+bGl0X2J1ZnNpemUvc2l6ZW9mKHVzaCk7XG4gIHMuZF9idWYgPSAxICogcy5saXRfYnVmc2l6ZTtcblxuICAvL3MtPmxfYnVmID0gcy0+cGVuZGluZ19idWYgKyAoMStzaXplb2YodXNoKSkqcy0+bGl0X2J1ZnNpemU7XG4gIHMubF9idWYgPSAoMSArIDIpICogcy5saXRfYnVmc2l6ZTtcblxuICBzLmxldmVsID0gbGV2ZWw7XG4gIHMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgcy5tZXRob2QgPSBtZXRob2Q7XG5cbiAgcmV0dXJuIGRlZmxhdGVSZXNldChzdHJtKTtcbn1cblxuZnVuY3Rpb24gZGVmbGF0ZUluaXQoc3RybSwgbGV2ZWwpIHtcbiAgcmV0dXJuIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgWl9ERUZMQVRFRCwgTUFYX1dCSVRTLCBERUZfTUVNX0xFVkVMLCBaX0RFRkFVTFRfU1RSQVRFR1kpO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGUoc3RybSwgZmx1c2gpIHtcbiAgdmFyIG9sZF9mbHVzaCwgcztcbiAgdmFyIGJlZywgdmFsOyAvLyBmb3IgZ3ppcCBoZWFkZXIgd3JpdGUgb25seVxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fFxuICAgIGZsdXNoID4gWl9CTE9DSyB8fCBmbHVzaCA8IDApIHtcbiAgICByZXR1cm4gc3RybSA/IGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUikgOiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHMgPSBzdHJtLnN0YXRlO1xuXG4gIGlmICghc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB8fFxuICAgICAgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgZmx1c2ggIT09IFpfRklOSVNIKSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSA/IFpfQlVGX0VSUk9SIDogWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgcy5zdHJtID0gc3RybTsgLyoganVzdCBpbiBjYXNlICovXG4gIG9sZF9mbHVzaCA9IHMubGFzdF9mbHVzaDtcbiAgcy5sYXN0X2ZsdXNoID0gZmx1c2g7XG5cbiAgLyogV3JpdGUgdGhlIGhlYWRlciAqL1xuICBpZiAocy5zdGF0dXMgPT09IElOSVRfU1RBVEUpIHtcblxuICAgIGlmIChzLndyYXAgPT09IDIpIHsgLy8gR1pJUCBoZWFkZXJcbiAgICAgIHN0cm0uYWRsZXIgPSAwOyAgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgIHB1dF9ieXRlKHMsIDMxKTtcbiAgICAgIHB1dF9ieXRlKHMsIDEzOSk7XG4gICAgICBwdXRfYnl0ZShzLCA4KTtcbiAgICAgIGlmICghcy5nemhlYWQpIHsgLy8gcy0+Z3poZWFkID09IFpfTlVMTFxuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgICAgcHV0X2J5dGUocywgT1NfQ09ERSk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGV4dCA/IDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzLmd6aGVhZC5oY3JjID8gMiA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5leHRyYSA/IDAgOiA0KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQubmFtZSA/IDAgOiA4KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuY29tbWVudCA/IDAgOiAxNilcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC50aW1lICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDgpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDE2KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAyNCkgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOlxuICAgICAgICAgICAgICAgICAgICAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/XG4gICAgICAgICAgICAgICAgICAgICA0IDogMCkpO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5vcyAmIDB4ZmYpO1xuICAgICAgICBpZiAocy5nemhlYWQuZXh0cmEgJiYgcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZik7XG4gICAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7XG4gICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZywgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBFWFRSQV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSAvLyBERUZMQVRFIGhlYWRlclxuICAgIHtcbiAgICAgIHZhciBoZWFkZXIgPSAoWl9ERUZMQVRFRCArICgocy53X2JpdHMgLSA4KSA8PCA0KSkgPDwgODtcbiAgICAgIHZhciBsZXZlbF9mbGFncyA9IC0xO1xuXG4gICAgICBpZiAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPCA2KSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMTtcbiAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA9PT0gNikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDM7XG4gICAgICB9XG4gICAgICBoZWFkZXIgfD0gKGxldmVsX2ZsYWdzIDw8IDYpO1xuICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHsgaGVhZGVyIHw9IFBSRVNFVF9ESUNUOyB9XG4gICAgICBoZWFkZXIgKz0gMzEgLSAoaGVhZGVyICUgMzEpO1xuXG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICBwdXRTaG9ydE1TQihzLCBoZWFkZXIpO1xuXG4gICAgICAvKiBTYXZlIHRoZSBhZGxlcjMyIG9mIHRoZSBwcmVzZXQgZGljdGlvbmFyeTogKi9cbiAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7XG4gICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTtcbiAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gICAgICB9XG4gICAgICBzdHJtLmFkbGVyID0gMTsgLy8gYWRsZXIzMigwTCwgWl9OVUxMLCAwKTtcbiAgICB9XG4gIH1cblxuLy8jaWZkZWYgR1pJUFxuICBpZiAocy5zdGF0dXMgPT09IEVYVFJBX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmV4dHJhLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cblxuICAgICAgd2hpbGUgKHMuZ3ppbmRleCA8IChzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmZmYpKSB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmFbcy5nemluZGV4XSAmIDB4ZmYpO1xuICAgICAgICBzLmd6aW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3ppbmRleCA9PT0gcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gTkFNRV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5uYW1lLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIC8vaW50IHZhbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgdmFsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZ1xuICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQubmFtZS5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5uYW1lLmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7XG4gICAgICB9IHdoaWxlICh2YWwgIT09IDApO1xuXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBDT01NRU5UX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmNvbW1lbnQvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgLy9pbnQgdmFsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5jb21tZW50Lmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLmNvbW1lbnQuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG5cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PT0gMCkge1xuICAgICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IEhDUkNfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuaGNyYykge1xuICAgICAgaWYgKHMucGVuZGluZyArIDIgPiBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyIDw9IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDgpICYgMHhmZik7XG4gICAgICAgIHN0cm0uYWRsZXIgPSAwOyAvL2NyYzMyKDBMLCBaX05VTEwsIDApO1xuICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgIH1cbiAgfVxuLy8jZW5kaWZcblxuICAvKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlICovXG4gIGlmIChzLnBlbmRpbmcgIT09IDApIHtcbiAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgLyogU2luY2UgYXZhaWxfb3V0IGlzIDAsIGRlZmxhdGUgd2lsbCBiZSBjYWxsZWQgYWdhaW4gd2l0aFxuICAgICAgICogbW9yZSBvdXRwdXQgc3BhY2UsIGJ1dCBwb3NzaWJseSB3aXRoIGJvdGggcGVuZGluZyBhbmRcbiAgICAgICAqIGF2YWlsX2luIGVxdWFsIHRvIHplcm8uIFRoZXJlIHdvbid0IGJlIGFueXRoaW5nIHRvIGRvLFxuICAgICAgICogYnV0IHRoaXMgaXMgbm90IGFuIGVycm9yIHNpdHVhdGlvbiBzbyBtYWtlIHN1cmUgd2VcbiAgICAgICAqIHJldHVybiBPSyBpbnN0ZWFkIG9mIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwgb2YgZGVmbGF0ZTpcbiAgICAgICAqL1xuICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICByZXR1cm4gWl9PSztcbiAgICB9XG5cbiAgICAvKiBNYWtlIHN1cmUgdGhlcmUgaXMgc29tZXRoaW5nIHRvIGRvIGFuZCBhdm9pZCBkdXBsaWNhdGUgY29uc2VjdXRpdmVcbiAgICAgKiBmbHVzaGVzLiBGb3IgcmVwZWF0ZWQgYW5kIHVzZWxlc3MgY2FsbHMgd2l0aCBaX0ZJTklTSCwgd2Uga2VlcFxuICAgICAqIHJldHVybmluZyBaX1NUUkVBTV9FTkQgaW5zdGVhZCBvZiBaX0JVRl9FUlJPUi5cbiAgICAgKi9cbiAgfSBlbHNlIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIHJhbmsoZmx1c2gpIDw9IHJhbmsob2xkX2ZsdXNoKSAmJlxuICAgIGZsdXNoICE9PSBaX0ZJTklTSCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpO1xuICB9XG5cbiAgLyogVXNlciBtdXN0IG5vdCBwcm92aWRlIG1vcmUgaW5wdXQgYWZ0ZXIgdGhlIGZpcnN0IEZJTklTSDogKi9cbiAgaWYgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpO1xuICB9XG5cbiAgLyogU3RhcnQgYSBuZXcgYmxvY2sgb3IgY29udGludWUgdGhlIGN1cnJlbnQgb25lLlxuICAgKi9cbiAgaWYgKHN0cm0uYXZhaWxfaW4gIT09IDAgfHwgcy5sb29rYWhlYWQgIT09IDAgfHxcbiAgICAoZmx1c2ggIT09IFpfTk9fRkxVU0ggJiYgcy5zdGF0dXMgIT09IEZJTklTSF9TVEFURSkpIHtcbiAgICB2YXIgYnN0YXRlID0gKHMuc3RyYXRlZ3kgPT09IFpfSFVGRk1BTl9PTkxZKSA/IGRlZmxhdGVfaHVmZihzLCBmbHVzaCkgOlxuICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfUkxFID8gZGVmbGF0ZV9ybGUocywgZmx1c2gpIDpcbiAgICAgICAgY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5mdW5jKHMsIGZsdXNoKSk7XG5cbiAgICBpZiAoYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9ET05FKSB7XG4gICAgICBzLnN0YXR1cyA9IEZJTklTSF9TVEFURTtcbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfTkVFRF9NT1JFIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQpIHtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgICAgLyogYXZvaWQgQlVGX0VSUk9SIG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICB9XG4gICAgICByZXR1cm4gWl9PSztcbiAgICAgIC8qIElmIGZsdXNoICE9IFpfTk9fRkxVU0ggJiYgYXZhaWxfb3V0ID09IDAsIHRoZSBuZXh0IGNhbGxcbiAgICAgICAqIG9mIGRlZmxhdGUgc2hvdWxkIHVzZSB0aGUgc2FtZSBmbHVzaCBwYXJhbWV0ZXIgdG8gbWFrZSBzdXJlXG4gICAgICAgKiB0aGF0IHRoZSBmbHVzaCBpcyBjb21wbGV0ZS4gU28gd2UgZG9uJ3QgaGF2ZSB0byBvdXRwdXQgYW5cbiAgICAgICAqIGVtcHR5IGJsb2NrIGhlcmUsIHRoaXMgd2lsbCBiZSBkb25lIGF0IG5leHQgY2FsbC4gVGhpcyBhbHNvXG4gICAgICAgKiBlbnN1cmVzIHRoYXQgZm9yIGEgdmVyeSBzbWFsbCBvdXRwdXQgYnVmZmVyLCB3ZSBlbWl0IGF0IG1vc3RcbiAgICAgICAqIG9uZSBlbXB0eSBibG9jay5cbiAgICAgICAqL1xuICAgIH1cbiAgICBpZiAoYnN0YXRlID09PSBCU19CTE9DS19ET05FKSB7XG4gICAgICBpZiAoZmx1c2ggPT09IFpfUEFSVElBTF9GTFVTSCkge1xuICAgICAgICB0cmVlcy5fdHJfYWxpZ24ocyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChmbHVzaCAhPT0gWl9CTE9DSykgeyAvKiBGVUxMX0ZMVVNIIG9yIFNZTkNfRkxVU0ggKi9cblxuICAgICAgICB0cmVlcy5fdHJfc3RvcmVkX2Jsb2NrKHMsIDAsIDAsIGZhbHNlKTtcbiAgICAgICAgLyogRm9yIGEgZnVsbCBmbHVzaCwgdGhpcyBlbXB0eSBibG9jayB3aWxsIGJlIHJlY29nbml6ZWRcbiAgICAgICAgICogYXMgYSBzcGVjaWFsIG1hcmtlciBieSBpbmZsYXRlX3N5bmMoKS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9GVUxMX0ZMVVNIKSB7XG4gICAgICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovICAgICAgICAgICAgIC8qIGZvcmdldCBoaXN0b3J5ICovXG4gICAgICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuXG4gICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgICAgICBzLnN0cnN0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuYmxvY2tfc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5pbnNlcnQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTsgLyogYXZvaWQgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICAgIHJldHVybiBaX09LO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvL0Fzc2VydChzdHJtLT5hdmFpbF9vdXQgPiAwLCBcImJ1ZzJcIik7XG4gIC8vaWYgKHN0cm0uYXZhaWxfb3V0IDw9IDApIHsgdGhyb3cgbmV3IEVycm9yKFwiYnVnMlwiKTt9XG5cbiAgaWYgKGZsdXNoICE9PSBaX0ZJTklTSCkgeyByZXR1cm4gWl9PSzsgfVxuICBpZiAocy53cmFwIDw9IDApIHsgcmV0dXJuIFpfU1RSRUFNX0VORDsgfVxuXG4gIC8qIFdyaXRlIHRoZSB0cmFpbGVyICovXG4gIGlmIChzLndyYXAgPT09IDIpIHtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAyNCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLnRvdGFsX2luICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAyNCkgJiAweGZmKTtcbiAgfVxuICBlbHNlXG4gIHtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gIH1cblxuICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAvKiBJZiBhdmFpbF9vdXQgaXMgemVybywgdGhlIGFwcGxpY2F0aW9uIHdpbGwgY2FsbCBkZWZsYXRlIGFnYWluXG4gICAqIHRvIGZsdXNoIHRoZSByZXN0LlxuICAgKi9cbiAgaWYgKHMud3JhcCA+IDApIHsgcy53cmFwID0gLXMud3JhcDsgfVxuICAvKiB3cml0ZSB0aGUgdHJhaWxlciBvbmx5IG9uY2UhICovXG4gIHJldHVybiBzLnBlbmRpbmcgIT09IDAgPyBaX09LIDogWl9TVFJFQU1fRU5EO1xufVxuXG5mdW5jdGlvbiBkZWZsYXRlRW5kKHN0cm0pIHtcbiAgdmFyIHN0YXR1cztcblxuICBpZiAoIXN0cm0vKj09IFpfTlVMTCovIHx8ICFzdHJtLnN0YXRlLyo9PSBaX05VTEwqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHN0YXR1cyA9IHN0cm0uc3RhdGUuc3RhdHVzO1xuICBpZiAoc3RhdHVzICE9PSBJTklUX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBFWFRSQV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gTkFNRV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gQ09NTUVOVF9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gSENSQ19TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gQlVTWV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gRklOSVNIX1NUQVRFXG4gICkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgc3RybS5zdGF0ZSA9IG51bGw7XG5cbiAgcmV0dXJuIHN0YXR1cyA9PT0gQlVTWV9TVEFURSA/IGVycihzdHJtLCBaX0RBVEFfRVJST1IpIDogWl9PSztcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplcyB0aGUgY29tcHJlc3Npb24gZGljdGlvbmFyeSBmcm9tIHRoZSBnaXZlbiBieXRlXG4gKiBzZXF1ZW5jZSB3aXRob3V0IHByb2R1Y2luZyBhbnkgY29tcHJlc3NlZCBvdXRwdXQuXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVTZXREaWN0aW9uYXJ5KHN0cm0sIGRpY3Rpb25hcnkpIHtcbiAgdmFyIGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDtcblxuICB2YXIgcztcbiAgdmFyIHN0ciwgbjtcbiAgdmFyIHdyYXA7XG4gIHZhciBhdmFpbDtcbiAgdmFyIG5leHQ7XG4gIHZhciBpbnB1dDtcbiAgdmFyIHRtcERpY3Q7XG5cbiAgaWYgKCFzdHJtLyo9PSBaX05VTEwqLyB8fCAhc3RybS5zdGF0ZS8qPT0gWl9OVUxMKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzID0gc3RybS5zdGF0ZTtcbiAgd3JhcCA9IHMud3JhcDtcblxuICBpZiAod3JhcCA9PT0gMiB8fCAod3JhcCA9PT0gMSAmJiBzLnN0YXR1cyAhPT0gSU5JVF9TVEFURSkgfHwgcy5sb29rYWhlYWQpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICAvKiB3aGVuIHVzaW5nIHpsaWIgd3JhcHBlcnMsIGNvbXB1dGUgQWRsZXItMzIgZm9yIHByb3ZpZGVkIGRpY3Rpb25hcnkgKi9cbiAgaWYgKHdyYXAgPT09IDEpIHtcbiAgICAvKiBhZGxlcjMyKHN0cm0tPmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTsgKi9cbiAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTtcbiAgfVxuXG4gIHMud3JhcCA9IDA7ICAgLyogYXZvaWQgY29tcHV0aW5nIEFkbGVyLTMyIGluIHJlYWRfYnVmICovXG5cbiAgLyogaWYgZGljdGlvbmFyeSB3b3VsZCBmaWxsIHdpbmRvdywganVzdCByZXBsYWNlIHRoZSBoaXN0b3J5ICovXG4gIGlmIChkaWN0TGVuZ3RoID49IHMud19zaXplKSB7XG4gICAgaWYgKHdyYXAgPT09IDApIHsgICAgICAgICAgICAvKiBhbHJlYWR5IGVtcHR5IG90aGVyd2lzZSAqL1xuICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gICAgICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG4gICAgICBzLnN0cnN0YXJ0ID0gMDtcbiAgICAgIHMuYmxvY2tfc3RhcnQgPSAwO1xuICAgICAgcy5pbnNlcnQgPSAwO1xuICAgIH1cbiAgICAvKiB1c2UgdGhlIHRhaWwgKi9cbiAgICAvLyBkaWN0aW9uYXJ5ID0gZGljdGlvbmFyeS5zbGljZShkaWN0TGVuZ3RoIC0gcy53X3NpemUpO1xuICAgIHRtcERpY3QgPSBuZXcgdXRpbHMuQnVmOChzLndfc2l6ZSk7XG4gICAgdXRpbHMuYXJyYXlTZXQodG1wRGljdCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCAtIHMud19zaXplLCBzLndfc2l6ZSwgMCk7XG4gICAgZGljdGlvbmFyeSA9IHRtcERpY3Q7XG4gICAgZGljdExlbmd0aCA9IHMud19zaXplO1xuICB9XG4gIC8qIGluc2VydCBkaWN0aW9uYXJ5IGludG8gd2luZG93IGFuZCBoYXNoICovXG4gIGF2YWlsID0gc3RybS5hdmFpbF9pbjtcbiAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBzdHJtLmF2YWlsX2luID0gZGljdExlbmd0aDtcbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5pbnB1dCA9IGRpY3Rpb25hcnk7XG4gIGZpbGxfd2luZG93KHMpO1xuICB3aGlsZSAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgc3RyID0gcy5zdHJzdGFydDtcbiAgICBuID0gcy5sb29rYWhlYWQgLSAoTUlOX01BVENIIC0gMSk7XG4gICAgZG8ge1xuICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyBNSU5fTUFUQ0gtMV0pOyAqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG5cbiAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG5cbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjtcbiAgICAgIHN0cisrO1xuICAgIH0gd2hpbGUgKC0tbik7XG4gICAgcy5zdHJzdGFydCA9IHN0cjtcbiAgICBzLmxvb2thaGVhZCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgZmlsbF93aW5kb3cocyk7XG4gIH1cbiAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDtcbiAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIHMuaW5zZXJ0ID0gcy5sb29rYWhlYWQ7XG4gIHMubG9va2FoZWFkID0gMDtcbiAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICBzdHJtLmlucHV0ID0gaW5wdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBhdmFpbDtcbiAgcy53cmFwID0gd3JhcDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZXhwb3J0cy5kZWZsYXRlSW5pdCA9IGRlZmxhdGVJbml0O1xuZXhwb3J0cy5kZWZsYXRlSW5pdDIgPSBkZWZsYXRlSW5pdDI7XG5leHBvcnRzLmRlZmxhdGVSZXNldCA9IGRlZmxhdGVSZXNldDtcbmV4cG9ydHMuZGVmbGF0ZVJlc2V0S2VlcCA9IGRlZmxhdGVSZXNldEtlZXA7XG5leHBvcnRzLmRlZmxhdGVTZXRIZWFkZXIgPSBkZWZsYXRlU2V0SGVhZGVyO1xuZXhwb3J0cy5kZWZsYXRlID0gZGVmbGF0ZTtcbmV4cG9ydHMuZGVmbGF0ZUVuZCA9IGRlZmxhdGVFbmQ7XG5leHBvcnRzLmRlZmxhdGVTZXREaWN0aW9uYXJ5ID0gZGVmbGF0ZVNldERpY3Rpb25hcnk7XG5leHBvcnRzLmRlZmxhdGVJbmZvID0gJ3Bha28gZGVmbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCknO1xuXG4vKiBOb3QgaW1wbGVtZW50ZWRcbmV4cG9ydHMuZGVmbGF0ZUJvdW5kID0gZGVmbGF0ZUJvdW5kO1xuZXhwb3J0cy5kZWZsYXRlQ29weSA9IGRlZmxhdGVDb3B5O1xuZXhwb3J0cy5kZWZsYXRlUGFyYW1zID0gZGVmbGF0ZVBhcmFtcztcbmV4cG9ydHMuZGVmbGF0ZVBlbmRpbmcgPSBkZWZsYXRlUGVuZGluZztcbmV4cG9ydHMuZGVmbGF0ZVByaW1lID0gZGVmbGF0ZVByaW1lO1xuZXhwb3J0cy5kZWZsYXRlVHVuZSA9IGRlZmxhdGVUdW5lO1xuKi9cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/pako/lib/zlib/deflate.js\n");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/gzheader.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/gzheader.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(" // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction GZheader() {\n  /* true if compressed data believed to be text */\n  this.text = 0;\n  /* modification time */\n\n  this.time = 0;\n  /* extra flags (not used when writing a gzip file) */\n\n  this.xflags = 0;\n  /* operating system */\n\n  this.os = 0;\n  /* pointer to extra field or Z_NULL if none */\n\n  this.extra = null;\n  /* extra field length (valid if extra != Z_NULL) */\n\n  this.extra_len = 0; // Actually, we don't need it in JS,\n  // but leave for few code modifications\n  //\n  // Setup limits is not necessary because in js we should not preallocate memory\n  // for inflate use constant limit in 65536 bytes\n  //\n\n  /* space at extra (only when reading header) */\n  // this.extra_max  = 0;\n\n  /* pointer to zero-terminated file name or Z_NULL */\n\n  this.name = '';\n  /* space at name (only when reading header) */\n  // this.name_max   = 0;\n\n  /* pointer to zero-terminated comment or Z_NULL */\n\n  this.comment = '';\n  /* space at comment (only when reading header) */\n  // this.comm_max   = 0;\n\n  /* true if there was or will be a header crc */\n\n  this.hcrc = 0;\n  /* true when done reading gzip header (not used when writing a gzip file) */\n\n  this.done = false;\n}\n\nmodule.exports = GZheader;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9nemhlYWRlci5qcz84MDEzIl0sIm5hbWVzIjpbIkdaaGVhZGVyIiwidGV4dCIsInRpbWUiLCJ4ZmxhZ3MiLCJvcyIsImV4dHJhIiwiZXh0cmFfbGVuIiwibmFtZSIsImNvbW1lbnQiLCJoY3JjIiwiZG9uZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJDQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTQSxRQUFULEdBQW9CO0FBQ2xCO0FBQ0EsT0FBS0MsSUFBTCxHQUFrQixDQUFsQjtBQUNBOztBQUNBLE9BQUtDLElBQUwsR0FBa0IsQ0FBbEI7QUFDQTs7QUFDQSxPQUFLQyxNQUFMLEdBQWtCLENBQWxCO0FBQ0E7O0FBQ0EsT0FBS0MsRUFBTCxHQUFrQixDQUFsQjtBQUNBOztBQUNBLE9BQUtDLEtBQUwsR0FBa0IsSUFBbEI7QUFDQTs7QUFDQSxPQUFLQyxTQUFMLEdBQWtCLENBQWxCLENBWmtCLENBWUc7QUFDQTtBQUVyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBOztBQUNBLE9BQUtDLElBQUwsR0FBa0IsRUFBbEI7QUFDQTtBQUNBOztBQUNBOztBQUNBLE9BQUtDLE9BQUwsR0FBa0IsRUFBbEI7QUFDQTtBQUNBOztBQUNBOztBQUNBLE9BQUtDLElBQUwsR0FBa0IsQ0FBbEI7QUFDQTs7QUFDQSxPQUFLQyxJQUFMLEdBQWtCLEtBQWxCO0FBQ0Q7O0FBRURDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQlosUUFBakIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9nemhlYWRlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5mdW5jdGlvbiBHWmhlYWRlcigpIHtcbiAgLyogdHJ1ZSBpZiBjb21wcmVzc2VkIGRhdGEgYmVsaWV2ZWQgdG8gYmUgdGV4dCAqL1xuICB0aGlzLnRleHQgICAgICAgPSAwO1xuICAvKiBtb2RpZmljYXRpb24gdGltZSAqL1xuICB0aGlzLnRpbWUgICAgICAgPSAwO1xuICAvKiBleHRyYSBmbGFncyAobm90IHVzZWQgd2hlbiB3cml0aW5nIGEgZ3ppcCBmaWxlKSAqL1xuICB0aGlzLnhmbGFncyAgICAgPSAwO1xuICAvKiBvcGVyYXRpbmcgc3lzdGVtICovXG4gIHRoaXMub3MgICAgICAgICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gZXh0cmEgZmllbGQgb3IgWl9OVUxMIGlmIG5vbmUgKi9cbiAgdGhpcy5leHRyYSAgICAgID0gbnVsbDtcbiAgLyogZXh0cmEgZmllbGQgbGVuZ3RoICh2YWxpZCBpZiBleHRyYSAhPSBaX05VTEwpICovXG4gIHRoaXMuZXh0cmFfbGVuICA9IDA7IC8vIEFjdHVhbGx5LCB3ZSBkb24ndCBuZWVkIGl0IGluIEpTLFxuICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgbGVhdmUgZm9yIGZldyBjb2RlIG1vZGlmaWNhdGlvbnNcblxuICAvL1xuICAvLyBTZXR1cCBsaW1pdHMgaXMgbm90IG5lY2Vzc2FyeSBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5XG4gIC8vIGZvciBpbmZsYXRlIHVzZSBjb25zdGFudCBsaW1pdCBpbiA2NTUzNiBieXRlc1xuICAvL1xuXG4gIC8qIHNwYWNlIGF0IGV4dHJhIChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMuZXh0cmFfbWF4ICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gemVyby10ZXJtaW5hdGVkIGZpbGUgbmFtZSBvciBaX05VTEwgKi9cbiAgdGhpcy5uYW1lICAgICAgID0gJyc7XG4gIC8qIHNwYWNlIGF0IG5hbWUgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5uYW1lX21heCAgID0gMDtcbiAgLyogcG9pbnRlciB0byB6ZXJvLXRlcm1pbmF0ZWQgY29tbWVudCBvciBaX05VTEwgKi9cbiAgdGhpcy5jb21tZW50ICAgID0gJyc7XG4gIC8qIHNwYWNlIGF0IGNvbW1lbnQgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5jb21tX21heCAgID0gMDtcbiAgLyogdHJ1ZSBpZiB0aGVyZSB3YXMgb3Igd2lsbCBiZSBhIGhlYWRlciBjcmMgKi9cbiAgdGhpcy5oY3JjICAgICAgID0gMDtcbiAgLyogdHJ1ZSB3aGVuIGRvbmUgcmVhZGluZyBnemlwIGhlYWRlciAobm90IHVzZWQgd2hlbiB3cml0aW5nIGEgZ3ppcCBmaWxlKSAqL1xuICB0aGlzLmRvbmUgICAgICAgPSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHWmhlYWRlcjtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/pako/lib/zlib/gzheader.js\n");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/inffast.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/inffast.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(" // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n// See state defs from inflate.js\n\nvar BAD = 30;\n/* got a data error -- remain here until reset */\n\nvar TYPE = 12;\n/* i: waiting for type bits, including last-flag bit */\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\n\nmodule.exports = function inflate_fast(strm, start) {\n  var state;\n\n  var _in;\n  /* local strm.input */\n\n\n  var last;\n  /* have enough input while in < last */\n\n  var _out;\n  /* local strm.output */\n\n\n  var beg;\n  /* inflate()'s initial strm.output */\n\n  var end;\n  /* while out < end, enough space available */\n  //#ifdef INFLATE_STRICT\n\n  var dmax;\n  /* maximum distance from zlib header */\n  //#endif\n\n  var wsize;\n  /* window size or zero if not using window */\n\n  var whave;\n  /* valid bytes in the window */\n\n  var wnext;\n  /* window write index */\n  // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n\n  var s_window;\n  /* allocated sliding window, if wsize != 0 */\n\n  var hold;\n  /* local strm.hold */\n\n  var bits;\n  /* local strm.bits */\n\n  var lcode;\n  /* local strm.lencode */\n\n  var dcode;\n  /* local strm.distcode */\n\n  var lmask;\n  /* mask for first level of length codes */\n\n  var dmask;\n  /* mask for first level of distance codes */\n\n  var here;\n  /* retrieved table entry */\n\n  var op;\n  /* code bits, operation, extra bits, or */\n\n  /*  window position, window bytes to copy */\n\n  var len;\n  /* match length, unused bytes */\n\n  var dist;\n  /* match distance */\n\n  var from;\n  /* where to copy match from */\n\n  var from_source;\n  var input, output; // JS specific, because we have no pointers\n\n  /* copy state to local variables */\n\n  state = strm.state; //here = state.here;\n\n  _in = strm.next_in;\n  input = strm.input;\n  last = _in + (strm.avail_in - 5);\n  _out = strm.next_out;\n  output = strm.output;\n  beg = _out - (start - strm.avail_out);\n  end = _out + (strm.avail_out - 257); //#ifdef INFLATE_STRICT\n\n  dmax = state.dmax; //#endif\n\n  wsize = state.wsize;\n  whave = state.whave;\n  wnext = state.wnext;\n  s_window = state.window;\n  hold = state.hold;\n  bits = state.bits;\n  lcode = state.lencode;\n  dcode = state.distcode;\n  lmask = (1 << state.lenbits) - 1;\n  dmask = (1 << state.distbits) - 1;\n  /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */\n\n  top: do {\n    if (bits < 15) {\n      hold += input[_in++] << bits;\n      bits += 8;\n      hold += input[_in++] << bits;\n      bits += 8;\n    }\n\n    here = lcode[hold & lmask];\n\n    dolen: for (;;) {\n      // Goto emulation\n      op = here >>> 24\n      /*here.bits*/\n      ;\n      hold >>>= op;\n      bits -= op;\n      op = here >>> 16 & 0xff\n      /*here.op*/\n      ;\n\n      if (op === 0) {\n        /* literal */\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        output[_out++] = here & 0xffff\n        /*here.val*/\n        ;\n      } else if (op & 16) {\n        /* length base */\n        len = here & 0xffff\n        /*here.val*/\n        ;\n        op &= 15;\n        /* number of extra bits */\n\n        if (op) {\n          if (bits < op) {\n            hold += input[_in++] << bits;\n            bits += 8;\n          }\n\n          len += hold & (1 << op) - 1;\n          hold >>>= op;\n          bits -= op;\n        } //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n\n\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n\n        here = dcode[hold & dmask];\n\n        dodist: for (;;) {\n          // goto emulation\n          op = here >>> 24\n          /*here.bits*/\n          ;\n          hold >>>= op;\n          bits -= op;\n          op = here >>> 16 & 0xff\n          /*here.op*/\n          ;\n\n          if (op & 16) {\n            /* distance base */\n            dist = here & 0xffff\n            /*here.val*/\n            ;\n            op &= 15;\n            /* number of extra bits */\n\n            if (bits < op) {\n              hold += input[_in++] << bits;\n              bits += 8;\n\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n            }\n\n            dist += hold & (1 << op) - 1; //#ifdef INFLATE_STRICT\n\n            if (dist > dmax) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break top;\n            } //#endif\n\n\n            hold >>>= op;\n            bits -= op; //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n\n            op = _out - beg;\n            /* max distance in output */\n\n            if (dist > op) {\n              /* see if copy from window */\n              op = dist - op;\n              /* distance back in window */\n\n              if (op > whave) {\n                if (state.sane) {\n                  strm.msg = 'invalid distance too far back';\n                  state.mode = BAD;\n                  break top;\n                } // (!) This block is disabled in zlib defaults,\n                // don't enable it for binary compatibility\n                //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n                //                if (len <= op - whave) {\n                //                  do {\n                //                    output[_out++] = 0;\n                //                  } while (--len);\n                //                  continue top;\n                //                }\n                //                len -= op - whave;\n                //                do {\n                //                  output[_out++] = 0;\n                //                } while (--op > whave);\n                //                if (op === 0) {\n                //                  from = _out - dist;\n                //                  do {\n                //                    output[_out++] = output[from++];\n                //                  } while (--len);\n                //                  continue top;\n                //                }\n                //#endif\n\n              }\n\n              from = 0; // window index\n\n              from_source = s_window;\n\n              if (wnext === 0) {\n                /* very common case */\n                from += wsize - op;\n\n                if (op < len) {\n                  /* some from window */\n                  len -= op;\n\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n\n                  from = _out - dist;\n                  /* rest from output */\n\n                  from_source = output;\n                }\n              } else if (wnext < op) {\n                /* wrap around window */\n                from += wsize + wnext - op;\n                op -= wnext;\n\n                if (op < len) {\n                  /* some from end of window */\n                  len -= op;\n\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n\n                  from = 0;\n\n                  if (wnext < len) {\n                    /* some from start of window */\n                    op = wnext;\n                    len -= op;\n\n                    do {\n                      output[_out++] = s_window[from++];\n                    } while (--op);\n\n                    from = _out - dist;\n                    /* rest from output */\n\n                    from_source = output;\n                  }\n                }\n              } else {\n                /* contiguous in window */\n                from += wnext - op;\n\n                if (op < len) {\n                  /* some from window */\n                  len -= op;\n\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n\n                  from = _out - dist;\n                  /* rest from output */\n\n                  from_source = output;\n                }\n              }\n\n              while (len > 2) {\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                len -= 3;\n              }\n\n              if (len) {\n                output[_out++] = from_source[from++];\n\n                if (len > 1) {\n                  output[_out++] = from_source[from++];\n                }\n              }\n            } else {\n              from = _out - dist;\n              /* copy direct from output */\n\n              do {\n                /* minimum length is three */\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                len -= 3;\n              } while (len > 2);\n\n              if (len) {\n                output[_out++] = output[from++];\n\n                if (len > 1) {\n                  output[_out++] = output[from++];\n                }\n              }\n            }\n          } else if ((op & 64) === 0) {\n            /* 2nd level distance code */\n            here = dcode[(here & 0xffff) + (\n            /*here.val*/\n            hold & (1 << op) - 1)];\n            continue dodist;\n          } else {\n            strm.msg = 'invalid distance code';\n            state.mode = BAD;\n            break top;\n          }\n\n          break; // need to emulate goto via \"continue\"\n        }\n      } else if ((op & 64) === 0) {\n        /* 2nd level length code */\n        here = lcode[(here & 0xffff) + (\n        /*here.val*/\n        hold & (1 << op) - 1)];\n        continue dolen;\n      } else if (op & 32) {\n        /* end-of-block */\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.mode = TYPE;\n        break top;\n      } else {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD;\n        break top;\n      }\n\n      break; // need to emulate goto via \"continue\"\n    }\n  } while (_in < last && _out < end);\n  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n\n\n  len = bits >> 3;\n  _in -= len;\n  bits -= len << 3;\n  hold &= (1 << bits) - 1;\n  /* update state and return */\n\n  strm.next_in = _in;\n  strm.next_out = _out;\n  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);\n  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);\n  state.hold = hold;\n  state.bits = bits;\n  return;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZmYXN0LmpzPzdlYjEiXSwibmFtZXMiOlsiQkFEIiwiVFlQRSIsIm1vZHVsZSIsImV4cG9ydHMiLCJpbmZsYXRlX2Zhc3QiLCJzdHJtIiwic3RhcnQiLCJzdGF0ZSIsIl9pbiIsImxhc3QiLCJfb3V0IiwiYmVnIiwiZW5kIiwiZG1heCIsIndzaXplIiwid2hhdmUiLCJ3bmV4dCIsInNfd2luZG93IiwiaG9sZCIsImJpdHMiLCJsY29kZSIsImRjb2RlIiwibG1hc2siLCJkbWFzayIsImhlcmUiLCJvcCIsImxlbiIsImRpc3QiLCJmcm9tIiwiZnJvbV9zb3VyY2UiLCJpbnB1dCIsIm91dHB1dCIsIm5leHRfaW4iLCJhdmFpbF9pbiIsIm5leHRfb3V0IiwiYXZhaWxfb3V0Iiwid2luZG93IiwibGVuY29kZSIsImRpc3Rjb2RlIiwibGVuYml0cyIsImRpc3RiaXRzIiwidG9wIiwiZG9sZW4iLCJkb2Rpc3QiLCJtc2ciLCJtb2RlIiwic2FuZSJdLCJtYXBwaW5ncyI6IkNBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0EsSUFBSUEsR0FBRyxHQUFHLEVBQVY7QUFBb0I7O0FBQ3BCLElBQUlDLElBQUksR0FBRyxFQUFYO0FBQW9COztBQUVwQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUNBQyxNQUFNLENBQUNDLE9BQVAsR0FBaUIsU0FBU0MsWUFBVCxDQUFzQkMsSUFBdEIsRUFBNEJDLEtBQTVCLEVBQW1DO0FBQ2xELE1BQUlDLEtBQUo7O0FBQ0EsTUFBSUMsR0FBSjtBQUE0Qjs7O0FBQzVCLE1BQUlDLElBQUo7QUFBNEI7O0FBQzVCLE1BQUlDLElBQUo7QUFBNEI7OztBQUM1QixNQUFJQyxHQUFKO0FBQTRCOztBQUM1QixNQUFJQyxH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TCxPQUFLLENBQUNXLElBQU4sR0FBYUEsSUFBYjtBQUNBWCxPQUFLLENBQUNZLElBQU4sR0FBYUEsSUFBYjtBQUNBO0FBQ0QsQ0E1UkQiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZmYXN0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbi8vIFNlZSBzdGF0ZSBkZWZzIGZyb20gaW5mbGF0ZS5qc1xudmFyIEJBRCA9IDMwOyAgICAgICAvKiBnb3QgYSBkYXRhIGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgVFlQRSA9IDEyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIHR5cGUgYml0cywgaW5jbHVkaW5nIGxhc3QtZmxhZyBiaXQgKi9cblxuLypcbiAgIERlY29kZSBsaXRlcmFsLCBsZW5ndGgsIGFuZCBkaXN0YW5jZSBjb2RlcyBhbmQgd3JpdGUgb3V0IHRoZSByZXN1bHRpbmdcbiAgIGxpdGVyYWwgYW5kIG1hdGNoIGJ5dGVzIHVudGlsIGVpdGhlciBub3QgZW5vdWdoIGlucHV0IG9yIG91dHB1dCBpc1xuICAgYXZhaWxhYmxlLCBhbiBlbmQtb2YtYmxvY2sgaXMgZW5jb3VudGVyZWQsIG9yIGEgZGF0YSBlcnJvciBpcyBlbmNvdW50ZXJlZC5cbiAgIFdoZW4gbGFyZ2UgZW5vdWdoIGlucHV0IGFuZCBvdXRwdXQgYnVmZmVycyBhcmUgc3VwcGxpZWQgdG8gaW5mbGF0ZSgpLCBmb3JcbiAgIGV4YW1wbGUsIGEgMTZLIGlucHV0IGJ1ZmZlciBhbmQgYSA2NEsgb3V0cHV0IGJ1ZmZlciwgbW9yZSB0aGFuIDk1JSBvZiB0aGVcbiAgIGluZmxhdGUgZXhlY3V0aW9uIHRpbWUgaXMgc3BlbnQgaW4gdGhpcyByb3V0aW5lLlxuXG4gICBFbnRyeSBhc3N1bXB0aW9uczpcblxuICAgICAgICBzdGF0ZS5tb2RlID09PSBMRU5cbiAgICAgICAgc3RybS5hdmFpbF9pbiA+PSA2XG4gICAgICAgIHN0cm0uYXZhaWxfb3V0ID49IDI1OFxuICAgICAgICBzdGFydCA+PSBzdHJtLmF2YWlsX291dFxuICAgICAgICBzdGF0ZS5iaXRzIDwgOFxuXG4gICBPbiByZXR1cm4sIHN0YXRlLm1vZGUgaXMgb25lIG9mOlxuXG4gICAgICAgIExFTiAtLSByYW4gb3V0IG9mIGVub3VnaCBvdXRwdXQgc3BhY2Ugb3IgZW5vdWdoIGF2YWlsYWJsZSBpbnB1dFxuICAgICAgICBUWVBFIC0tIHJlYWNoZWQgZW5kIG9mIGJsb2NrIGNvZGUsIGluZmxhdGUoKSB0byBpbnRlcnByZXQgbmV4dCBibG9ja1xuICAgICAgICBCQUQgLS0gZXJyb3IgaW4gYmxvY2sgZGF0YVxuXG4gICBOb3RlczpcblxuICAgIC0gVGhlIG1heGltdW0gaW5wdXQgYml0cyB1c2VkIGJ5IGEgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgaXMgMTUgYml0cyBmb3IgdGhlXG4gICAgICBsZW5ndGggY29kZSwgNSBiaXRzIGZvciB0aGUgbGVuZ3RoIGV4dHJhLCAxNSBiaXRzIGZvciB0aGUgZGlzdGFuY2UgY29kZSxcbiAgICAgIGFuZCAxMyBiaXRzIGZvciB0aGUgZGlzdGFuY2UgZXh0cmEuICBUaGlzIHRvdGFscyA0OCBiaXRzLCBvciBzaXggYnl0ZXMuXG4gICAgICBUaGVyZWZvcmUgaWYgc3RybS5hdmFpbF9pbiA+PSA2LCB0aGVuIHRoZXJlIGlzIGVub3VnaCBpbnB1dCB0byBhdm9pZFxuICAgICAgY2hlY2tpbmcgZm9yIGF2YWlsYWJsZSBpbnB1dCB3aGlsZSBkZWNvZGluZy5cblxuICAgIC0gVGhlIG1heGltdW0gYnl0ZXMgdGhhdCBhIHNpbmdsZSBsZW5ndGgvZGlzdGFuY2UgcGFpciBjYW4gb3V0cHV0IGlzIDI1OFxuICAgICAgYnl0ZXMsIHdoaWNoIGlzIHRoZSBtYXhpbXVtIGxlbmd0aCB0aGF0IGNhbiBiZSBjb2RlZC4gIGluZmxhdGVfZmFzdCgpXG4gICAgICByZXF1aXJlcyBzdHJtLmF2YWlsX291dCA+PSAyNTggZm9yIGVhY2ggbG9vcCB0byBhdm9pZCBjaGVja2luZyBmb3JcbiAgICAgIG91dHB1dCBzcGFjZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmZsYXRlX2Zhc3Qoc3RybSwgc3RhcnQpIHtcbiAgdmFyIHN0YXRlO1xuICB2YXIgX2luOyAgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5pbnB1dCAqL1xuICB2YXIgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogaGF2ZSBlbm91Z2ggaW5wdXQgd2hpbGUgaW4gPCBsYXN0ICovXG4gIHZhciBfb3V0OyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLm91dHB1dCAqL1xuICB2YXIgYmVnOyAgICAgICAgICAgICAgICAgICAgLyogaW5mbGF0ZSgpJ3MgaW5pdGlhbCBzdHJtLm91dHB1dCAqL1xuICB2YXIgZW5kOyAgICAgICAgICAgICAgICAgICAgLyogd2hpbGUgb3V0IDwgZW5kLCBlbm91Z2ggc3BhY2UgYXZhaWxhYmxlICovXG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICB2YXIgZG1heDsgICAgICAgICAgICAgICAgICAgLyogbWF4aW11bSBkaXN0YW5jZSBmcm9tIHpsaWIgaGVhZGVyICovXG4vLyNlbmRpZlxuICB2YXIgd3NpemU7ICAgICAgICAgICAgICAgICAgLyogd2luZG93IHNpemUgb3IgemVybyBpZiBub3QgdXNpbmcgd2luZG93ICovXG4gIHZhciB3aGF2ZTsgICAgICAgICAgICAgICAgICAvKiB2YWxpZCBieXRlcyBpbiB0aGUgd2luZG93ICovXG4gIHZhciB3bmV4dDsgICAgICAgICAgICAgICAgICAvKiB3aW5kb3cgd3JpdGUgaW5kZXggKi9cbiAgLy8gVXNlIGBzX3dpbmRvd2AgaW5zdGVhZCBgd2luZG93YCwgYXZvaWQgY29uZmxpY3Qgd2l0aCBpbnN0cnVtZW50YXRpb24gdG9vbHNcbiAgdmFyIHNfd2luZG93OyAgICAgICAgICAgICAgIC8qIGFsbG9jYXRlZCBzbGlkaW5nIHdpbmRvdywgaWYgd3NpemUgIT0gMCAqL1xuICB2YXIgaG9sZDsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5ob2xkICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmJpdHMgKi9cbiAgdmFyIGxjb2RlOyAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0ubGVuY29kZSAqL1xuICB2YXIgZGNvZGU7ICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5kaXN0Y29kZSAqL1xuICB2YXIgbG1hc2s7ICAgICAgICAgICAgICAgICAgLyogbWFzayBmb3IgZmlyc3QgbGV2ZWwgb2YgbGVuZ3RoIGNvZGVzICovXG4gIHZhciBkbWFzazsgICAgICAgICAgICAgICAgICAvKiBtYXNrIGZvciBmaXJzdCBsZXZlbCBvZiBkaXN0YW5jZSBjb2RlcyAqL1xuICB2YXIgaGVyZTsgICAgICAgICAgICAgICAgICAgLyogcmV0cmlldmVkIHRhYmxlIGVudHJ5ICovXG4gIHZhciBvcDsgICAgICAgICAgICAgICAgICAgICAvKiBjb2RlIGJpdHMsIG9wZXJhdGlvbiwgZXh0cmEgYml0cywgb3IgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICB3aW5kb3cgcG9zaXRpb24sIHdpbmRvdyBieXRlcyB0byBjb3B5ICovXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAvKiBtYXRjaCBsZW5ndGgsIHVudXNlZCBieXRlcyAqL1xuICB2YXIgZGlzdDsgICAgICAgICAgICAgICAgICAgLyogbWF0Y2ggZGlzdGFuY2UgKi9cbiAgdmFyIGZyb207ICAgICAgICAgICAgICAgICAgIC8qIHdoZXJlIHRvIGNvcHkgbWF0Y2ggZnJvbSAqL1xuICB2YXIgZnJvbV9zb3VyY2U7XG5cblxuICB2YXIgaW5wdXQsIG91dHB1dDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuXG4gIC8qIGNvcHkgc3RhdGUgdG8gbG9jYWwgdmFyaWFibGVzICovXG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgLy9oZXJlID0gc3RhdGUuaGVyZTtcbiAgX2luID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIGxhc3QgPSBfaW4gKyAoc3RybS5hdmFpbF9pbiAtIDUpO1xuICBfb3V0ID0gc3RybS5uZXh0X291dDtcbiAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gIGJlZyA9IF9vdXQgLSAoc3RhcnQgLSBzdHJtLmF2YWlsX291dCk7XG4gIGVuZCA9IF9vdXQgKyAoc3RybS5hdmFpbF9vdXQgLSAyNTcpO1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgZG1heCA9IHN0YXRlLmRtYXg7XG4vLyNlbmRpZlxuICB3c2l6ZSA9IHN0YXRlLndzaXplO1xuICB3aGF2ZSA9IHN0YXRlLndoYXZlO1xuICB3bmV4dCA9IHN0YXRlLnduZXh0O1xuICBzX3dpbmRvdyA9IHN0YXRlLndpbmRvdztcbiAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICBsY29kZSA9IHN0YXRlLmxlbmNvZGU7XG4gIGRjb2RlID0gc3RhdGUuZGlzdGNvZGU7XG4gIGxtYXNrID0gKDEgPDwgc3RhdGUubGVuYml0cykgLSAxO1xuICBkbWFzayA9ICgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDE7XG5cblxuICAvKiBkZWNvZGUgbGl0ZXJhbHMgYW5kIGxlbmd0aC9kaXN0YW5jZXMgdW50aWwgZW5kLW9mLWJsb2NrIG9yIG5vdCBlbm91Z2hcbiAgICAgaW5wdXQgZGF0YSBvciBvdXRwdXQgc3BhY2UgKi9cblxuICB0b3A6XG4gIGRvIHtcbiAgICBpZiAoYml0cyA8IDE1KSB7XG4gICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgYml0cyArPSA4O1xuICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgIGJpdHMgKz0gODtcbiAgICB9XG5cbiAgICBoZXJlID0gbGNvZGVbaG9sZCAmIGxtYXNrXTtcblxuICAgIGRvbGVuOlxuICAgIGZvciAoOzspIHsgLy8gR290byBlbXVsYXRpb25cbiAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovO1xuICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgYml0cyAtPSBvcDtcbiAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLztcbiAgICAgIGlmIChvcCA9PT0gMCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGl0ZXJhbCAqL1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgaGVyZS52YWwgPj0gMHgyMCAmJiBoZXJlLnZhbCA8IDB4N2YgP1xuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgJyVjJ1xcblwiIDpcbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsIDB4JTAyeFxcblwiLCBoZXJlLnZhbCkpO1xuICAgICAgICBvdXRwdXRbX291dCsrXSA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcCAmIDE2KSB7ICAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIGJhc2UgKi9cbiAgICAgICAgbGVuID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgICAgb3AgJj0gMTU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgKi9cbiAgICAgICAgaWYgKG9wKSB7XG4gICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuICs9IGhvbGQgJiAoKDEgPDwgb3ApIC0gMSk7XG4gICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBsZW5ndGggJXVcXG5cIiwgbGVuKSk7XG4gICAgICAgIGlmIChiaXRzIDwgMTUpIHtcbiAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICBoZXJlID0gZGNvZGVbaG9sZCAmIGRtYXNrXTtcblxuICAgICAgICBkb2Rpc3Q6XG4gICAgICAgIGZvciAoOzspIHsgLy8gZ290byBlbXVsYXRpb25cbiAgICAgICAgICBvcCA9IGhlcmUgPj4+IDI0LypoZXJlLmJpdHMqLztcbiAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgICBvcCA9IChoZXJlID4+PiAxNikgJiAweGZmLypoZXJlLm9wKi87XG5cbiAgICAgICAgICBpZiAob3AgJiAxNikgeyAgICAgICAgICAgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYXNlICovXG4gICAgICAgICAgICBkaXN0ID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgICAgICAgIG9wICY9IDE1OyAgICAgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgKi9cbiAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3QgKz0gaG9sZCAmICgoMSA8PCBvcCkgLSAxKTtcbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gICAgICAgICAgICBpZiAoZGlzdCA+IGRtYXgpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZGlzdGFuY2UgJXVcXG5cIiwgZGlzdCkpO1xuICAgICAgICAgICAgb3AgPSBfb3V0IC0gYmVnOyAgICAgICAgICAgICAgICAvKiBtYXggZGlzdGFuY2UgaW4gb3V0cHV0ICovXG4gICAgICAgICAgICBpZiAoZGlzdCA+IG9wKSB7ICAgICAgICAgICAgICAgIC8qIHNlZSBpZiBjb3B5IGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgIG9wID0gZGlzdCAtIG9wOyAgICAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhY2sgaW4gd2luZG93ICovXG4gICAgICAgICAgICAgIGlmIChvcCA+IHdoYXZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHtcbiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgICAgICAgfVxuXG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmF1bHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuLy8jaWZkZWYgSU5GTEFURV9BTExPV19JTlZBTElEX0RJU1RBTkNFX1RPT0ZBUl9BUlJSXG4vLyAgICAgICAgICAgICAgICBpZiAobGVuIDw9IG9wIC0gd2hhdmUpIHtcbi8vICAgICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gMDtcbi8vICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1sZW4pO1xuLy8gICAgICAgICAgICAgICAgICBjb250aW51ZSB0b3A7XG4vLyAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICBsZW4gLT0gb3AgLSB3aGF2ZTtcbi8vICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwO1xuLy8gICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCA+IHdoYXZlKTtcbi8vICAgICAgICAgICAgICAgIGlmIChvcCA9PT0gMCkge1xuLy8gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7XG4vLyAgICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuLy8gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWxlbik7XG4vLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZnJvbSA9IDA7IC8vIHdpbmRvdyBpbmRleFxuICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IHNfd2luZG93O1xuICAgICAgICAgICAgICBpZiAod25leHQgPT09IDApIHsgICAgICAgICAgIC8qIHZlcnkgY29tbW9uIGNhc2UgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplIC0gb3A7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmICh3bmV4dCA8IG9wKSB7ICAgICAgLyogd3JhcCBhcm91bmQgd2luZG93ICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSArIHduZXh0IC0gb3A7XG4gICAgICAgICAgICAgICAgb3AgLT0gd25leHQ7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIGVuZCBvZiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gMDtcbiAgICAgICAgICAgICAgICAgIGlmICh3bmV4dCA8IGxlbikgeyAgLyogc29tZSBmcm9tIHN0YXJ0IG9mIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgICBvcCA9IHduZXh0O1xuICAgICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgIC8qIGNvbnRpZ3VvdXMgaW4gd2luZG93ICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3bmV4dCAtIG9wO1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd2hpbGUgKGxlbiA+IDIpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gMztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgICAgICAgICAvKiBjb3B5IGRpcmVjdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICBkbyB7ICAgICAgICAgICAgICAgICAgICAgICAgLyogbWluaW11bSBsZW5ndGggaXMgdGhyZWUgKi9cbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gMztcbiAgICAgICAgICAgICAgfSB3aGlsZSAobGVuID4gMik7XG4gICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsgICAgICAgICAgLyogMm5kIGxldmVsIGRpc3RhbmNlIGNvZGUgKi9cbiAgICAgICAgICAgIGhlcmUgPSBkY29kZVsoaGVyZSAmIDB4ZmZmZikvKmhlcmUudmFsKi8gKyAoaG9sZCAmICgoMSA8PCBvcCkgLSAxKSldO1xuICAgICAgICAgICAgY29udGludWUgZG9kaXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgY29kZSc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrOyAvLyBuZWVkIHRvIGVtdWxhdGUgZ290byB2aWEgXCJjb250aW51ZVwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAgICAgLyogMm5kIGxldmVsIGxlbmd0aCBjb2RlICovXG4gICAgICAgIGhlcmUgPSBsY29kZVsoaGVyZSAmIDB4ZmZmZikvKmhlcmUudmFsKi8gKyAoaG9sZCAmICgoMSA8PCBvcCkgLSAxKSldO1xuICAgICAgICBjb250aW51ZSBkb2xlbjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wICYgMzIpIHsgICAgICAgICAgICAgICAgICAgICAvKiBlbmQtb2YtYmxvY2sgKi9cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBlbmQgb2YgYmxvY2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrIHRvcDtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7IC8vIG5lZWQgdG8gZW11bGF0ZSBnb3RvIHZpYSBcImNvbnRpbnVlXCJcbiAgICB9XG4gIH0gd2hpbGUgKF9pbiA8IGxhc3QgJiYgX291dCA8IGVuZCk7XG5cbiAgLyogcmV0dXJuIHVudXNlZCBieXRlcyAob24gZW50cnksIGJpdHMgPCA4LCBzbyBpbiB3b24ndCBnbyB0b28gZmFyIGJhY2spICovXG4gIGxlbiA9IGJpdHMgPj4gMztcbiAgX2luIC09IGxlbjtcbiAgYml0cyAtPSBsZW4gPDwgMztcbiAgaG9sZCAmPSAoMSA8PCBiaXRzKSAtIDE7XG5cbiAgLyogdXBkYXRlIHN0YXRlIGFuZCByZXR1cm4gKi9cbiAgc3RybS5uZXh0X2luID0gX2luO1xuICBzdHJtLm5leHRfb3V0ID0gX291dDtcbiAgc3RybS5hdmFpbF9pbiA9IChfaW4gPCBsYXN0ID8gNSArIChsYXN0IC0gX2luKSA6IDUgLSAoX2luIC0gbGFzdCkpO1xuICBzdHJtLmF2YWlsX291dCA9IChfb3V0IDwgZW5kID8gMjU3ICsgKGVuZCAtIF9vdXQpIDogMjU3IC0gKF9vdXQgLSBlbmQpKTtcbiAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gIHN0YXRlLmJpdHMgPSBiaXRzO1xuICByZXR1cm47XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/pako/lib/zlib/inffast.js\n");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/inflate.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/inflate.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(" // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils = __webpack_require__(/*! ../utils/common */ \"./node_modules/pako/lib/utils/common.js\");\n\nvar adler32 = __webpack_require__(/*! ./adler32 */ \"./node_modules/pako/lib/zlib/adler32.js\");\n\nvar crc32 = __webpack_require__(/*! ./crc32 */ \"./node_modules/pako/lib/zlib/crc32.js\");\n\nvar inflate_fast = __webpack_require__(/*! ./inffast */ \"./node_modules/pako/lib/zlib/inffast.js\");\n\nvar inflate_table = __webpack_require__(/*! ./inftrees */ \"./node_modules/pako/lib/zlib/inftrees.js\");\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n/* Public constants ==========================================================*/\n\n/* ===========================================================================*/\n\n/* Allowed flush values; see deflate() and inflate() below for details */\n//var Z_NO_FLUSH      = 0;\n//var Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\n//var Z_FULL_FLUSH    = 3;\n\nvar Z_FINISH = 4;\nvar Z_BLOCK = 5;\nvar Z_TREES = 6;\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\n\nvar Z_OK = 0;\nvar Z_STREAM_END = 1;\nvar Z_NEED_DICT = 2; //var Z_ERRNO         = -1;\n\nvar Z_STREAM_ERROR = -2;\nvar Z_DATA_ERROR = -3;\nvar Z_MEM_ERROR = -4;\nvar Z_BUF_ERROR = -5; //var Z_VERSION_ERROR = -6;\n\n/* The deflate compression method */\n\nvar Z_DEFLATED = 8;\n/* STATES ====================================================================*/\n\n/* ===========================================================================*/\n\nvar HEAD = 1;\n/* i: waiting for magic header */\n\nvar FLAGS = 2;\n/* i: waiting for method and flags (gzip) */\n\nvar TIME = 3;\n/* i: waiting for modification time (gzip) */\n\nvar OS = 4;\n/* i: waiting for extra flags and operating system (gzip) */\n\nvar EXLEN = 5;\n/* i: waiting for extra length (gzip) */\n\nvar EXTRA = 6;\n/* i: waiting for extra bytes (gzip) */\n\nvar NAME = 7;\n/* i: waiting for end of file name (gzip) */\n\nvar COMMENT = 8;\n/* i: waiting for end of comment (gzip) */\n\nvar HCRC = 9;\n/* i: waiting for header crc (gzip) */\n\nvar DICTID = 10;\n/* i: waiting for dictionary check value */\n\nvar DICT = 11;\n/* waiting for inflateSetDictionary() call */\n\nvar TYPE = 12;\n/* i: waiting for type bits, including last-flag bit */\n\nvar TYPEDO = 13;\n/* i: same, but skip check to exit inflate on new block */\n\nvar STORED = 14;\n/* i: waiting for stored size (length and complement) */\n\nvar COPY_ = 15;\n/* i/o: same as COPY below, but only first time in */\n\nvar COPY = 16;\n/* i/o: waiting for input or output to copy stored block */\n\nvar TABLE = 17;\n/* i: waiting for dynamic block table lengths */\n\nvar LENLENS = 18;\n/* i: waiting for code length code lengths */\n\nvar CODELENS = 19;\n/* i: waiting for length/lit and distance code lengths */\n\nvar LEN_ = 20;\n/* i: same as LEN below, but only first time in */\n\nvar LEN = 21;\n/* i: waiting for length/lit/eob code */\n\nvar LENEXT = 22;\n/* i: waiting for length extra bits */\n\nvar DIST = 23;\n/* i: waiting for distance code */\n\nvar DISTEXT = 24;\n/* i: waiting for distance extra bits */\n\nvar MATCH = 25;\n/* o: waiting for output space to copy string */\n\nvar LIT = 26;\n/* o: waiting for output space to write literal */\n\nvar CHECK = 27;\n/* i: waiting for 32-bit check value */\n\nvar LENGTH = 28;\n/* i: waiting for 32-bit length (gzip) */\n\nvar DONE = 29;\n/* finished check, done -- remain here until reset */\n\nvar BAD = 30;\n/* got a data error -- remain here until reset */\n\nvar MEM = 31;\n/* got an inflate() memory error -- remain here until reset */\n\nvar SYNC = 32;\n/* looking for synchronization bytes to restart inflate() */\n\n/* ===========================================================================*/\n\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592; //var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\n\nvar DEF_WBITS = MAX_WBITS;\n\nfunction zswap32(q) {\n  return (q >>> 24 & 0xff) + (q >>> 8 & 0xff00) + ((q & 0xff00) << 8) + ((q & 0xff) << 24);\n}\n\nfunction InflateState() {\n  this.mode = 0;\n  /* current inflate mode */\n\n  this.last = false;\n  /* true if processing last block */\n\n  this.wrap = 0;\n  /* bit 0 true for zlib, bit 1 true for gzip */\n\n  this.havedict = false;\n  /* true if dictionary provided */\n\n  this.flags = 0;\n  /* gzip header method and flags (0 if zlib) */\n\n  this.dmax = 0;\n  /* zlib header max distance (INFLATE_STRICT) */\n\n  this.check = 0;\n  /* protected copy of check value */\n\n  this.total = 0;\n  /* protected copy of output count */\n  // TODO: may be {}\n\n  this.head = null;\n  /* where to save gzip header information */\n\n  /* sliding window */\n\n  this.wbits = 0;\n  /* log base 2 of requested window size */\n\n  this.wsize = 0;\n  /* window size or zero if not using window */\n\n  this.whave = 0;\n  /* valid bytes in the window */\n\n  this.wnext = 0;\n  /* window write index */\n\n  this.window = null;\n  /* allocated sliding window, if needed */\n\n  /* bit accumulator */\n\n  this.hold = 0;\n  /* input bit accumulator */\n\n  this.bits = 0;\n  /* number of bits in \"in\" */\n\n  /* for string and stored block copying */\n\n  this.length = 0;\n  /* literal or length of data to copy */\n\n  this.offset = 0;\n  /* distance back to copy string from */\n\n  /* for table and code decoding */\n\n  this.extra = 0;\n  /* extra bits needed */\n\n  /* fixed and dynamic code tables */\n\n  this.lencode = null;\n  /* starting table for length/literal codes */\n\n  this.distcode = null;\n  /* starting table for distance codes */\n\n  this.lenbits = 0;\n  /* index bits for lencode */\n\n  this.distbits = 0;\n  /* index bits for distcode */\n\n  /* dynamic table building */\n\n  this.ncode = 0;\n  /* number of code length code lengths */\n\n  this.nlen = 0;\n  /* number of length code lengths */\n\n  this.ndist = 0;\n  /* number of distance code lengths */\n\n  this.have = 0;\n  /* number of code lengths in lens[] */\n\n  this.next = null;\n  /* next available space in codes[] */\n\n  this.lens = new utils.Buf16(320);\n  /* temporary storage for code lengths */\n\n  this.work = new utils.Buf16(288);\n  /* work area for code table building */\n\n  /*\n   because we don't have pointers in js, we use lencode and distcode directly\n   as buffers so we don't need codes\n  */\n  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */\n\n  this.lendyn = null;\n  /* dynamic table for length/literal codes (JS specific) */\n\n  this.distdyn = null;\n  /* dynamic table for distance codes (JS specific) */\n\n  this.sane = 0;\n  /* if false, allow invalid distance too far */\n\n  this.back = 0;\n  /* bits back of last unprocessed length/lit */\n\n  this.was = 0;\n  /* initial length of match */\n}\n\nfunction inflateResetKeep(strm) {\n  var state;\n\n  if (!strm || !strm.state) {\n    return Z_STREAM_ERROR;\n  }\n\n  state = strm.state;\n  strm.total_in = strm.total_out = state.total = 0;\n  strm.msg = '';\n  /*Z_NULL*/\n\n  if (state.wrap) {\n    /* to support ill-conceived Java test suite */\n    strm.adler = state.wrap & 1;\n  }\n\n  state.mode = HEAD;\n  state.last = 0;\n  state.havedict = 0;\n  state.dmax = 32768;\n  state.head = null\n  /*Z_NULL*/\n  ;\n  state.hold = 0;\n  state.bits = 0; //state.lencode = state.distcode = state.next = state.codes;\n\n  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);\n  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);\n  state.sane = 1;\n  state.back = -1; //Tracev((stderr, \"inflate: reset\\n\"));\n\n  return Z_OK;\n}\n\nfunction inflateReset(strm) {\n  var state;\n\n  if (!strm || !strm.state) {\n    return Z_STREAM_ERROR;\n  }\n\n  state = strm.state;\n  state.wsize = 0;\n  state.whave = 0;\n  state.wnext = 0;\n  return inflateResetKeep(strm);\n}\n\nfunction inflateReset2(strm, windowBits) {\n  var wrap;\n  var state;\n  /* get the state */\n\n  if (!strm || !strm.state) {\n    return Z_STREAM_ERROR;\n  }\n\n  state = strm.state;\n  /* extract wrap request from windowBits parameter */\n\n  if (windowBits < 0) {\n    wrap = 0;\n    windowBits = -windowBits;\n  } else {\n    wrap = (windowBits >> 4) + 1;\n\n    if (windowBits < 48) {\n      windowBits &= 15;\n    }\n  }\n  /* set number of window bits, free window if different */\n\n\n  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n    return Z_STREAM_ERROR;\n  }\n\n  if (state.window !== null && state.wbits !== windowBits) {\n    state.window = null;\n  }\n  /* update state and reset the rest of it */\n\n\n  state.wrap = wrap;\n  state.wbits = windowBits;\n  return inflateReset(strm);\n}\n\nfunction inflateInit2(strm, windowBits) {\n  var ret;\n  var state;\n\n  if (!strm) {\n    return Z_STREAM_ERROR;\n  } //strm.msg = Z_NULL;                 /* in case we return an error */\n\n\n  state = new InflateState(); //if (state === Z_NULL) return Z_MEM_ERROR;\n  //Tracev((stderr, \"inflate: allocated\\n\"));\n\n  strm.state = state;\n  state.window = null\n  /*Z_NULL*/\n  ;\n  ret = inflateReset2(strm, windowBits);\n\n  if (ret !== Z_OK) {\n    strm.state = null\n    /*Z_NULL*/\n    ;\n  }\n\n  return ret;\n}\n\nfunction inflateInit(strm) {\n  return inflateInit2(strm, DEF_WBITS);\n}\n/*\n Return state with length and distance decoding tables and index sizes set to\n fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n If BUILDFIXED is defined, then instead this routine builds the tables the\n first time it's called, and returns those tables the first time and\n thereafter.  This reduces the size of the code by about 2K bytes, in\n exchange for a little execution time.  However, BUILDFIXED should not be\n used for threaded applications, since the rewriting of the tables and virgin\n may not be thread-safe.\n */\n\n\nvar virgin = true;\nvar lenfix, distfix; // We have no pointers in JS, so keep tables separate\n\nfunction fixedtables(state) {\n  /* build fixed huffman tables if first call (may not be thread safe) */\n  if (virgin) {\n    var sym;\n    lenfix = new utils.Buf32(512);\n    distfix = new utils.Buf32(32);\n    /* literal/length table */\n\n    sym = 0;\n\n    while (sym < 144) {\n      state.lens[sym++] = 8;\n    }\n\n    while (sym < 256) {\n      state.lens[sym++] = 9;\n    }\n\n    while (sym < 280) {\n      state.lens[sym++] = 7;\n    }\n\n    while (sym < 288) {\n      state.lens[sym++] = 8;\n    }\n\n    inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {\n      bits: 9\n    });\n    /* distance table */\n\n    sym = 0;\n\n    while (sym < 32) {\n      state.lens[sym++] = 5;\n    }\n\n    inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {\n      bits: 5\n    });\n    /* do this just once */\n\n    virgin = false;\n  }\n\n  state.lencode = lenfix;\n  state.lenbits = 9;\n  state.distcode = distfix;\n  state.distbits = 5;\n}\n/*\n Update the window with the last wsize (normally 32K) bytes written before\n returning.  If window does not exist yet, create it.  This is only called\n when a window is already in use, or when output has been written during this\n inflate call, but the end of the deflate stream has not been reached yet.\n It is also called to create a window for dictionary data when a dictionary\n is loaded.\n\n Providing output buffers larger than 32K to inflate() should provide a speed\n advantage, since only the last 32K of output is copied to the sliding window\n upon return from inflate(), and since all distances after the first 32K of\n output will fall in the output data, making match copies simpler and faster.\n The advantage may be dependent on the size of the processor's data caches.\n */\n\n\nfunction updatewindow(strm, src, end, copy) {\n  var dist;\n  var state = strm.state;\n  /* if it hasn't been done already, allocate space for the window */\n\n  if (state.window === null) {\n    state.wsize = 1 << state.wbits;\n    state.wnext = 0;\n    state.whave = 0;\n    state.window = new utils.Buf8(state.wsize);\n  }\n  /* copy state->wsize or less output bytes into the circular window */\n\n\n  if (copy >= state.wsize) {\n    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);\n    state.wnext = 0;\n    state.whave = state.wsize;\n  } else {\n    dist = state.wsize - state.wnext;\n\n    if (dist > copy) {\n      dist = copy;\n    } //zmemcpy(state->window + state->wnext, end - copy, dist);\n\n\n    utils.arraySet(state.window, src, end - copy, dist, state.wnext);\n    copy -= dist;\n\n    if (copy) {\n      //zmemcpy(state->window, end - copy, copy);\n      utils.arraySet(state.window, src, end - copy, copy, 0);\n      state.wnext = copy;\n      state.whave = state.wsize;\n    } else {\n      state.wnext += dist;\n\n      if (state.wnext === state.wsize) {\n        state.wnext = 0;\n      }\n\n      if (state.whave < state.wsize) {\n        state.whave += dist;\n      }\n    }\n  }\n\n  return 0;\n}\n\nfunction inflate(strm, flush) {\n  var state;\n  var input, output; // input/output buffers\n\n  var next;\n  /* next input INDEX */\n\n  var put;\n  /* next output INDEX */\n\n  var have, left;\n  /* available input and output */\n\n  var hold;\n  /* bit buffer */\n\n  var bits;\n  /* bits in bit buffer */\n\n  var _in, _out;\n  /* save starting available input and output */\n\n\n  var copy;\n  /* number of stored or match bytes to copy */\n\n  var from;\n  /* where to copy match bytes from */\n\n  var from_source;\n  var here = 0;\n  /* current decoding table entry */\n\n  var here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n  //var last;                   /* parent table entry */\n\n  var last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n\n  var len;\n  /* length to copy for repeats, bits to drop */\n\n  var ret;\n  /* return code */\n\n  var hbuf = new utils.Buf8(4);\n  /* buffer for gzip header crc calculation */\n\n  var opts;\n  var n; // temporary var for NEED_BITS\n\n  var order =\n  /* permutation of code lengths */\n  [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n\n  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {\n    return Z_STREAM_ERROR;\n  }\n\n  state = strm.state;\n\n  if (state.mode === TYPE) {\n    state.mode = TYPEDO;\n  }\n  /* skip check */\n  //--- LOAD() ---\n\n\n  put = strm.next_out;\n  output = strm.output;\n  left = strm.avail_out;\n  next = strm.next_in;\n  input = strm.input;\n  have = strm.avail_in;\n  hold = state.hold;\n  bits = state.bits; //---\n\n  _in = have;\n  _out = left;\n  ret = Z_OK;\n\n  inf_leave: // goto emulation\n  for (;;) {\n    switch (state.mode) {\n      case HEAD:\n        if (state.wrap === 0) {\n          state.mode = TYPEDO;\n          break;\n        } //=== NEEDBITS(16);\n\n\n        while (bits < 16) {\n          if (have === 0) {\n            break inf_leave;\n          }\n\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        } //===//\n\n\n        if (state.wrap & 2 && hold === 0x8b1f) {\n          /* gzip header */\n          state.check = 0\n          /*crc32(0L, Z_NULL, 0)*/\n          ; //=== CRC2(state.check, hold);\n\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = hold >>> 8 & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0); //===//\n          //=== INITBITS();\n\n          hold = 0;\n          bits = 0; //===//\n\n          state.mode = FLAGS;\n          break;\n        }\n\n        state.flags = 0;\n        /* expect zlib header */\n\n        if (state.head) {\n          state.head.done = false;\n        }\n\n        if (!(state.wrap & 1) ||\n        /* check if zlib header allowed */\n        (((hold & 0xff) <<\n        /*BITS(8)*/\n        8) + (hold >> 8)) % 31) {\n          strm.msg = 'incorrect header check';\n          state.mode = BAD;\n          break;\n        }\n\n        if ((hold & 0x0f) !==\n        /*BITS(4)*/\n        Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        } //--- DROPBITS(4) ---//\n\n\n        hold >>>= 4;\n        bits -= 4; //---//\n\n        len = (hold & 0x0f) +\n        /*BITS(4)*/\n        8;\n\n        if (state.wbits === 0) {\n          state.wbits = len;\n        } else if (len > state.wbits) {\n          strm.msg = 'invalid window size';\n          state.mode = BAD;\n          break;\n        }\n\n        state.dmax = 1 << len; //Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n\n        strm.adler = state.check = 1\n        /*adler32(0L, Z_NULL, 0)*/\n        ;\n        state.mode = hold & 0x200 ? DICTID : TYPE; //=== INITBITS();\n\n        hold = 0;\n        bits = 0; //===//\n\n        break;\n\n      case FLAGS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) {\n            break inf_leave;\n          }\n\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        } //===//\n\n\n        state.flags = hold;\n\n        if ((state.flags & 0xff) !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n\n        if (state.flags & 0xe000) {\n          strm.msg = 'unknown header flags set';\n          state.mode = BAD;\n          break;\n        }\n\n        if (state.head) {\n          state.head.text = hold >> 8 & 1;\n        }\n\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = hold >>> 8 & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0); //===//\n        } //=== INITBITS();\n\n\n        hold = 0;\n        bits = 0; //===//\n\n        state.mode = TIME;\n\n      /* falls through */\n\n      case TIME:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) {\n            break inf_leave;\n          }\n\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        } //===//\n\n\n        if (state.head) {\n          state.head.time = hold;\n        }\n\n        if (state.flags & 0x0200) {\n          //=== CRC4(state.check, hold)\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = hold >>> 8 & 0xff;\n          hbuf[2] = hold >>> 16 & 0xff;\n          hbuf[3] = hold >>> 24 & 0xff;\n          state.check = crc32(state.check, hbuf, 4, 0); //===\n        } //=== INITBITS();\n\n\n        hold = 0;\n        bits = 0; //===//\n\n        state.mode = OS;\n\n      /* falls through */\n\n      case OS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) {\n            break inf_leave;\n          }\n\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        } //===//\n\n\n        if (state.head) {\n          state.head.xflags = hold & 0xff;\n          state.head.os = hold >> 8;\n        }\n\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = hold >>> 8 & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0); //===//\n        } //=== INITBITS();\n\n\n        hold = 0;\n        bits = 0; //===//\n\n        state.mode = EXLEN;\n\n      /* falls through */\n\n      case EXLEN:\n        if (state.flags & 0x0400) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) {\n              break inf_leave;\n            }\n\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          } //===//\n\n\n          state.length = hold;\n\n          if (state.head) {\n            state.head.extra_len = hold;\n          }\n\n          if (state.flags & 0x0200) {\n            //=== CRC2(state.check, hold);\n            hbuf[0] = hold & 0xff;\n            hbuf[1] = hold >>> 8 & 0xff;\n            state.check = crc32(state.check, hbuf, 2, 0); //===//\n          } //=== INITBITS();\n\n\n          hold = 0;\n          bits = 0; //===//\n        } else if (state.head) {\n          state.head.extra = null\n          /*Z_NULL*/\n          ;\n        }\n\n        state.mode = EXTRA;\n\n      /* falls through */\n\n      case EXTRA:\n        if (state.flags & 0x0400) {\n          copy = state.length;\n\n          if (copy > have) {\n            copy = have;\n          }\n\n          if (copy) {\n            if (state.head) {\n              len = state.head.extra_len - state.length;\n\n              if (!state.head.extra) {\n                // Use untyped array for more convenient processing later\n                state.head.extra = new Array(state.head.extra_len);\n              }\n\n              utils.arraySet(state.head.extra, input, next, // extra field is limited to 65536 bytes\n              // - no need for additional size check\n              copy,\n              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n              len); //zmemcpy(state.head.extra + len, next,\n              //        len + copy > state.head.extra_max ?\n              //        state.head.extra_max - len : copy);\n            }\n\n            if (state.flags & 0x0200) {\n              state.check = crc32(state.check, input, copy, next);\n            }\n\n            have -= copy;\n            next += copy;\n            state.length -= copy;\n          }\n\n          if (state.length) {\n            break inf_leave;\n          }\n        }\n\n        state.length = 0;\n        state.mode = NAME;\n\n      /* falls through */\n\n      case NAME:\n        if (state.flags & 0x0800) {\n          if (have === 0) {\n            break inf_leave;\n          }\n\n          copy = 0;\n\n          do {\n            // TODO: 2 or 1 bytes?\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n\n            if (state.head && len && state.length < 65536\n            /*state.head.name_max*/\n            ) {\n              state.head.name += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n\n          have -= copy;\n          next += copy;\n\n          if (len) {\n            break inf_leave;\n          }\n        } else if (state.head) {\n          state.head.name = null;\n        }\n\n        state.length = 0;\n        state.mode = COMMENT;\n\n      /* falls through */\n\n      case COMMENT:\n        if (state.flags & 0x1000) {\n          if (have === 0) {\n            break inf_leave;\n          }\n\n          copy = 0;\n\n          do {\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n\n            if (state.head && len && state.length < 65536\n            /*state.head.comm_max*/\n            ) {\n              state.head.comment += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n\n          have -= copy;\n          next += copy;\n\n          if (len) {\n            break inf_leave;\n          }\n        } else if (state.head) {\n          state.head.comment = null;\n        }\n\n        state.mode = HCRC;\n\n      /* falls through */\n\n      case HCRC:\n        if (state.flags & 0x0200) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) {\n              break inf_leave;\n            }\n\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          } //===//\n\n\n          if (hold !== (state.check & 0xffff)) {\n            strm.msg = 'header crc mismatch';\n            state.mode = BAD;\n            break;\n          } //=== INITBITS();\n\n\n          hold = 0;\n          bits = 0; //===//\n        }\n\n        if (state.head) {\n          state.head.hcrc = state.flags >> 9 & 1;\n          state.head.done = true;\n        }\n\n        strm.adler = state.check = 0;\n        state.mode = TYPE;\n        break;\n\n      case DICTID:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) {\n            break inf_leave;\n          }\n\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        } //===//\n\n\n        strm.adler = state.check = zswap32(hold); //=== INITBITS();\n\n        hold = 0;\n        bits = 0; //===//\n\n        state.mode = DICT;\n\n      /* falls through */\n\n      case DICT:\n        if (state.havedict === 0) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits; //---\n\n          return Z_NEED_DICT;\n        }\n\n        strm.adler = state.check = 1\n        /*adler32(0L, Z_NULL, 0)*/\n        ;\n        state.mode = TYPE;\n\n      /* falls through */\n\n      case TYPE:\n        if (flush === Z_BLOCK || flush === Z_TREES) {\n          break inf_leave;\n        }\n\n      /* falls through */\n\n      case TYPEDO:\n        if (state.last) {\n          //--- BYTEBITS() ---//\n          hold >>>= bits & 7;\n          bits -= bits & 7; //---//\n\n          state.mode = CHECK;\n          break;\n        } //=== NEEDBITS(3); */\n\n\n        while (bits < 3) {\n          if (have === 0) {\n            break inf_leave;\n          }\n\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        } //===//\n\n\n        state.last = hold & 0x01\n        /*BITS(1)*/\n        ; //--- DROPBITS(1) ---//\n\n        hold >>>= 1;\n        bits -= 1; //---//\n\n        switch (hold & 0x03) {\n          /*BITS(2)*/\n          case 0:\n            /* stored block */\n            //Tracev((stderr, \"inflate:     stored block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = STORED;\n            break;\n\n          case 1:\n            /* fixed block */\n            fixedtables(state); //Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n\n            state.mode = LEN_;\n            /* decode codes */\n\n            if (flush === Z_TREES) {\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2; //---//\n\n              break inf_leave;\n            }\n\n            break;\n\n          case 2:\n            /* dynamic block */\n            //Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = TABLE;\n            break;\n\n          case 3:\n            strm.msg = 'invalid block type';\n            state.mode = BAD;\n        } //--- DROPBITS(2) ---//\n\n\n        hold >>>= 2;\n        bits -= 2; //---//\n\n        break;\n\n      case STORED:\n        //--- BYTEBITS() ---// /* go to byte boundary */\n        hold >>>= bits & 7;\n        bits -= bits & 7; //---//\n        //=== NEEDBITS(32); */\n\n        while (bits < 32) {\n          if (have === 0) {\n            break inf_leave;\n          }\n\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        } //===//\n\n\n        if ((hold & 0xffff) !== (hold >>> 16 ^ 0xffff)) {\n          strm.msg = 'invalid stored block lengths';\n          state.mode = BAD;\n          break;\n        }\n\n        state.length = hold & 0xffff; //Tracev((stderr, \"inflate:       stored length %u\\n\",\n        //        state.length));\n        //=== INITBITS();\n\n        hold = 0;\n        bits = 0; //===//\n\n        state.mode = COPY_;\n\n        if (flush === Z_TREES) {\n          break inf_leave;\n        }\n\n      /* falls through */\n\n      case COPY_:\n        state.mode = COPY;\n\n      /* falls through */\n\n      case COPY:\n        copy = state.length;\n\n        if (copy) {\n          if (copy > have) {\n            copy = have;\n          }\n\n          if (copy > left) {\n            copy = left;\n          }\n\n          if (copy === 0) {\n            break inf_leave;\n          } //--- zmemcpy(put, next, copy); ---\n\n\n          utils.arraySet(output, input, next, copy, put); //---//\n\n          have -= copy;\n          next += copy;\n          left -= copy;\n          put += copy;\n          state.length -= copy;\n          break;\n        } //Tracev((stderr, \"inflate:       stored end\\n\"));\n\n\n        state.mode = TYPE;\n        break;\n\n      case TABLE:\n        //=== NEEDBITS(14); */\n        while (bits < 14) {\n          if (have === 0) {\n            break inf_leave;\n          }\n\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        } //===//\n\n\n        state.nlen = (hold & 0x1f) +\n        /*BITS(5)*/\n        257; //--- DROPBITS(5) ---//\n\n        hold >>>= 5;\n        bits -= 5; //---//\n\n        state.ndist = (hold & 0x1f) +\n        /*BITS(5)*/\n        1; //--- DROPBITS(5) ---//\n\n        hold >>>= 5;\n        bits -= 5; //---//\n\n        state.ncode = (hold & 0x0f) +\n        /*BITS(4)*/\n        4; //--- DROPBITS(4) ---//\n\n        hold >>>= 4;\n        bits -= 4; //---//\n        //#ifndef PKZIP_BUG_WORKAROUND\n\n        if (state.nlen > 286 || state.ndist > 30) {\n          strm.msg = 'too many length or distance symbols';\n          state.mode = BAD;\n          break;\n        } //#endif\n        //Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n\n\n        state.have = 0;\n        state.mode = LENLENS;\n\n      /* falls through */\n\n      case LENLENS:\n        while (state.have < state.ncode) {\n          //=== NEEDBITS(3);\n          while (bits < 3) {\n            if (have === 0) {\n              break inf_leave;\n            }\n\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          } //===//\n\n\n          state.lens[order[state.have++]] = hold & 0x07; //BITS(3);\n          //--- DROPBITS(3) ---//\n\n          hold >>>= 3;\n          bits -= 3; //---//\n        }\n\n        while (state.have < 19) {\n          state.lens[order[state.have++]] = 0;\n        } // We have separate tables & no pointers. 2 commented lines below not needed.\n        //state.next = state.codes;\n        //state.lencode = state.next;\n        // Switch to use dynamic table\n\n\n        state.lencode = state.lendyn;\n        state.lenbits = 7;\n        opts = {\n          bits: state.lenbits\n        };\n        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n        state.lenbits = opts.bits;\n\n        if (ret) {\n          strm.msg = 'invalid code lengths set';\n          state.mode = BAD;\n          break;\n        } //Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n\n\n        state.have = 0;\n        state.mode = CODELENS;\n\n      /* falls through */\n\n      case CODELENS:\n        while (state.have < state.nlen + state.ndist) {\n          for (;;) {\n            here = state.lencode[hold & (1 << state.lenbits) - 1];\n            /*BITS(state.lenbits)*/\n\n            here_bits = here >>> 24;\n            here_op = here >>> 16 & 0xff;\n            here_val = here & 0xffff;\n\n            if (here_bits <= bits) {\n              break;\n            } //--- PULLBYTE() ---//\n\n\n            if (have === 0) {\n              break inf_leave;\n            }\n\n            have--;\n            hold += input[next++] << bits;\n            bits += 8; //---//\n          }\n\n          if (here_val < 16) {\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits; //---//\n\n            state.lens[state.have++] = here_val;\n          } else {\n            if (here_val === 16) {\n              //=== NEEDBITS(here.bits + 2);\n              n = here_bits + 2;\n\n              while (bits < n) {\n                if (have === 0) {\n                  break inf_leave;\n                }\n\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              } //===//\n              //--- DROPBITS(here.bits) ---//\n\n\n              hold >>>= here_bits;\n              bits -= here_bits; //---//\n\n              if (state.have === 0) {\n                strm.msg = 'invalid bit length repeat';\n                state.mode = BAD;\n                break;\n              }\n\n              len = state.lens[state.have - 1];\n              copy = 3 + (hold & 0x03); //BITS(2);\n              //--- DROPBITS(2) ---//\n\n              hold >>>= 2;\n              bits -= 2; //---//\n            } else if (here_val === 17) {\n              //=== NEEDBITS(here.bits + 3);\n              n = here_bits + 3;\n\n              while (bits < n) {\n                if (have === 0) {\n                  break inf_leave;\n                }\n\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              } //===//\n              //--- DROPBITS(here.bits) ---//\n\n\n              hold >>>= here_bits;\n              bits -= here_bits; //---//\n\n              len = 0;\n              copy = 3 + (hold & 0x07); //BITS(3);\n              //--- DROPBITS(3) ---//\n\n              hold >>>= 3;\n              bits -= 3; //---//\n            } else {\n              //=== NEEDBITS(here.bits + 7);\n              n = here_bits + 7;\n\n              while (bits < n) {\n                if (have === 0) {\n                  break inf_leave;\n                }\n\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              } //===//\n              //--- DROPBITS(here.bits) ---//\n\n\n              hold >>>= here_bits;\n              bits -= here_bits; //---//\n\n              len = 0;\n              copy = 11 + (hold & 0x7f); //BITS(7);\n              //--- DROPBITS(7) ---//\n\n              hold >>>= 7;\n              bits -= 7; //---//\n            }\n\n            if (state.have + copy > state.nlen + state.ndist) {\n              strm.msg = 'invalid bit length repeat';\n              state.mode = BAD;\n              break;\n            }\n\n            while (copy--) {\n              state.lens[state.have++] = len;\n            }\n          }\n        }\n        /* handle error breaks in while */\n\n\n        if (state.mode === BAD) {\n          break;\n        }\n        /* check for end-of-block code (better have one) */\n\n\n        if (state.lens[256] === 0) {\n          strm.msg = 'invalid code -- missing end-of-block';\n          state.mode = BAD;\n          break;\n        }\n        /* build code tables -- note: do not change the lenbits or distbits\n           values here (9 and 6) without reading the comments in inftrees.h\n           concerning the ENOUGH constants, which depend on those values */\n\n\n        state.lenbits = 9;\n        opts = {\n          bits: state.lenbits\n        };\n        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts); // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n\n        state.lenbits = opts.bits; // state.lencode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid literal/lengths set';\n          state.mode = BAD;\n          break;\n        }\n\n        state.distbits = 6; //state.distcode.copy(state.codes);\n        // Switch to use dynamic table\n\n        state.distcode = state.distdyn;\n        opts = {\n          bits: state.distbits\n        };\n        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts); // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n\n        state.distbits = opts.bits; // state.distcode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid distances set';\n          state.mode = BAD;\n          break;\n        } //Tracev((stderr, 'inflate:       codes ok\\n'));\n\n\n        state.mode = LEN_;\n\n        if (flush === Z_TREES) {\n          break inf_leave;\n        }\n\n      /* falls through */\n\n      case LEN_:\n        state.mode = LEN;\n\n      /* falls through */\n\n      case LEN:\n        if (have >= 6 && left >= 258) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits; //---\n\n          inflate_fast(strm, _out); //--- LOAD() ---\n\n          put = strm.next_out;\n          output = strm.output;\n          left = strm.avail_out;\n          next = strm.next_in;\n          input = strm.input;\n          have = strm.avail_in;\n          hold = state.hold;\n          bits = state.bits; //---\n\n          if (state.mode === TYPE) {\n            state.back = -1;\n          }\n\n          break;\n        }\n\n        state.back = 0;\n\n        for (;;) {\n          here = state.lencode[hold & (1 << state.lenbits) - 1];\n          /*BITS(state.lenbits)*/\n\n          here_bits = here >>> 24;\n          here_op = here >>> 16 & 0xff;\n          here_val = here & 0xffff;\n\n          if (here_bits <= bits) {\n            break;\n          } //--- PULLBYTE() ---//\n\n\n          if (have === 0) {\n            break inf_leave;\n          }\n\n          have--;\n          hold += input[next++] << bits;\n          bits += 8; //---//\n        }\n\n        if (here_op && (here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n\n          for (;;) {\n            here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >>\n            /*BITS(last.bits + last.op)*/\n            last_bits)];\n            here_bits = here >>> 24;\n            here_op = here >>> 16 & 0xff;\n            here_val = here & 0xffff;\n\n            if (last_bits + here_bits <= bits) {\n              break;\n            } //--- PULLBYTE() ---//\n\n\n            if (have === 0) {\n              break inf_leave;\n            }\n\n            have--;\n            hold += input[next++] << bits;\n            bits += 8; //---//\n          } //--- DROPBITS(last.bits) ---//\n\n\n          hold >>>= last_bits;\n          bits -= last_bits; //---//\n\n          state.back += last_bits;\n        } //--- DROPBITS(here.bits) ---//\n\n\n        hold >>>= here_bits;\n        bits -= here_bits; //---//\n\n        state.back += here_bits;\n        state.length = here_val;\n\n        if (here_op === 0) {\n          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n          //        \"inflate:         literal '%c'\\n\" :\n          //        \"inflate:         literal 0x%02x\\n\", here.val));\n          state.mode = LIT;\n          break;\n        }\n\n        if (here_op & 32) {\n          //Tracevv((stderr, \"inflate:         end of block\\n\"));\n          state.back = -1;\n          state.mode = TYPE;\n          break;\n        }\n\n        if (here_op & 64) {\n          strm.msg = 'invalid literal/length code';\n          state.mode = BAD;\n          break;\n        }\n\n        state.extra = here_op & 15;\n        state.mode = LENEXT;\n\n      /* falls through */\n\n      case LENEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n\n          while (bits < n) {\n            if (have === 0) {\n              break inf_leave;\n            }\n\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          } //===//\n\n\n          state.length += hold & (1 << state.extra) - 1\n          /*BITS(state.extra)*/\n          ; //--- DROPBITS(state.extra) ---//\n\n          hold >>>= state.extra;\n          bits -= state.extra; //---//\n\n          state.back += state.extra;\n        } //Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n\n\n        state.was = state.length;\n        state.mode = DIST;\n\n      /* falls through */\n\n      case DIST:\n        for (;;) {\n          here = state.distcode[hold & (1 << state.distbits) - 1];\n          /*BITS(state.distbits)*/\n\n          here_bits = here >>> 24;\n          here_op = here >>> 16 & 0xff;\n          here_val = here & 0xffff;\n\n          if (here_bits <= bits) {\n            break;\n          } //--- PULLBYTE() ---//\n\n\n          if (have === 0) {\n            break inf_leave;\n          }\n\n          have--;\n          hold += input[next++] << bits;\n          bits += 8; //---//\n        }\n\n        if ((here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n\n          for (;;) {\n            here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >>\n            /*BITS(last.bits + last.op)*/\n            last_bits)];\n            here_bits = here >>> 24;\n            here_op = here >>> 16 & 0xff;\n            here_val = here & 0xffff;\n\n            if (last_bits + here_bits <= bits) {\n              break;\n            } //--- PULLBYTE() ---//\n\n\n            if (have === 0) {\n              break inf_leave;\n            }\n\n            have--;\n            hold += input[next++] << bits;\n            bits += 8; //---//\n          } //--- DROPBITS(last.bits) ---//\n\n\n          hold >>>= last_bits;\n          bits -= last_bits; //---//\n\n          state.back += last_bits;\n        } //--- DROPBITS(here.bits) ---//\n\n\n        hold >>>= here_bits;\n        bits -= here_bits; //---//\n\n        state.back += here_bits;\n\n        if (here_op & 64) {\n          strm.msg = 'invalid distance code';\n          state.mode = BAD;\n          break;\n        }\n\n        state.offset = here_val;\n        state.extra = here_op & 15;\n        state.mode = DISTEXT;\n\n      /* falls through */\n\n      case DISTEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n\n          while (bits < n) {\n            if (have === 0) {\n              break inf_leave;\n            }\n\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          } //===//\n\n\n          state.offset += hold & (1 << state.extra) - 1\n          /*BITS(state.extra)*/\n          ; //--- DROPBITS(state.extra) ---//\n\n          hold >>>= state.extra;\n          bits -= state.extra; //---//\n\n          state.back += state.extra;\n        } //#ifdef INFLATE_STRICT\n\n\n        if (state.offset > state.dmax) {\n          strm.msg = 'invalid distance too far back';\n          state.mode = BAD;\n          break;\n        } //#endif\n        //Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n\n\n        state.mode = MATCH;\n\n      /* falls through */\n\n      case MATCH:\n        if (left === 0) {\n          break inf_leave;\n        }\n\n        copy = _out - left;\n\n        if (state.offset > copy) {\n          /* copy from window */\n          copy = state.offset - copy;\n\n          if (copy > state.whave) {\n            if (state.sane) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break;\n            } // (!) This block is disabled in zlib defaults,\n            // don't enable it for binary compatibility\n            //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n            //          Trace((stderr, \"inflate.c too far\\n\"));\n            //          copy -= state.whave;\n            //          if (copy > state.length) { copy = state.length; }\n            //          if (copy > left) { copy = left; }\n            //          left -= copy;\n            //          state.length -= copy;\n            //          do {\n            //            output[put++] = 0;\n            //          } while (--copy);\n            //          if (state.length === 0) { state.mode = LEN; }\n            //          break;\n            //#endif\n\n          }\n\n          if (copy > state.wnext) {\n            copy -= state.wnext;\n            from = state.wsize - copy;\n          } else {\n            from = state.wnext - copy;\n          }\n\n          if (copy > state.length) {\n            copy = state.length;\n          }\n\n          from_source = state.window;\n        } else {\n          /* copy from output */\n          from_source = output;\n          from = put - state.offset;\n          copy = state.length;\n        }\n\n        if (copy > left) {\n          copy = left;\n        }\n\n        left -= copy;\n        state.length -= copy;\n\n        do {\n          output[put++] = from_source[from++];\n        } while (--copy);\n\n        if (state.length === 0) {\n          state.mode = LEN;\n        }\n\n        break;\n\n      case LIT:\n        if (left === 0) {\n          break inf_leave;\n        }\n\n        output[put++] = state.length;\n        left--;\n        state.mode = LEN;\n        break;\n\n      case CHECK:\n        if (state.wrap) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) {\n              break inf_leave;\n            }\n\n            have--; // Use '|' instead of '+' to make sure that result is signed\n\n            hold |= input[next++] << bits;\n            bits += 8;\n          } //===//\n\n\n          _out -= left;\n          strm.total_out += _out;\n          state.total += _out;\n\n          if (_out) {\n            strm.adler = state.check =\n            /*UPDATE(state.check, put - _out, _out);*/\n            state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);\n          }\n\n          _out = left; // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n\n          if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n            strm.msg = 'incorrect data check';\n            state.mode = BAD;\n            break;\n          } //=== INITBITS();\n\n\n          hold = 0;\n          bits = 0; //===//\n          //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n        }\n\n        state.mode = LENGTH;\n\n      /* falls through */\n\n      case LENGTH:\n        if (state.wrap && state.flags) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) {\n              break inf_leave;\n            }\n\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          } //===//\n\n\n          if (hold !== (state.total & 0xffffffff)) {\n            strm.msg = 'incorrect length check';\n            state.mode = BAD;\n            break;\n          } //=== INITBITS();\n\n\n          hold = 0;\n          bits = 0; //===//\n          //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n        }\n\n        state.mode = DONE;\n\n      /* falls through */\n\n      case DONE:\n        ret = Z_STREAM_END;\n        break inf_leave;\n\n      case BAD:\n        ret = Z_DATA_ERROR;\n        break inf_leave;\n\n      case MEM:\n        return Z_MEM_ERROR;\n\n      case SYNC:\n      /* falls through */\n\n      default:\n        return Z_STREAM_ERROR;\n    }\n  } // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n\n  /*\n     Return from inflate(), updating the total counts and the check value.\n     If there was no progress during the inflate() call, return a buffer\n     error.  Call updatewindow() to create and/or update the window state.\n     Note: a memory error from inflate() is non-recoverable.\n   */\n  //--- RESTORE() ---\n\n\n  strm.next_out = put;\n  strm.avail_out = left;\n  strm.next_in = next;\n  strm.avail_in = have;\n  state.hold = hold;\n  state.bits = bits; //---\n\n  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {\n    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {\n      state.mode = MEM;\n      return Z_MEM_ERROR;\n    }\n  }\n\n  _in -= strm.avail_in;\n  _out -= strm.avail_out;\n  strm.total_in += _in;\n  strm.total_out += _out;\n  state.total += _out;\n\n  if (state.wrap && _out) {\n    strm.adler = state.check =\n    /*UPDATE(state.check, strm.next_out - _out, _out);*/\n    state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);\n  }\n\n  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n\n  if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {\n    ret = Z_BUF_ERROR;\n  }\n\n  return ret;\n}\n\nfunction inflateEnd(strm) {\n  if (!strm || !strm.state\n  /*|| strm->zfree == (free_func)0*/\n  ) {\n      return Z_STREAM_ERROR;\n    }\n\n  var state = strm.state;\n\n  if (state.window) {\n    state.window = null;\n  }\n\n  strm.state = null;\n  return Z_OK;\n}\n\nfunction inflateGetHeader(strm, head) {\n  var state;\n  /* check state */\n\n  if (!strm || !strm.state) {\n    return Z_STREAM_ERROR;\n  }\n\n  state = strm.state;\n\n  if ((state.wrap & 2) === 0) {\n    return Z_STREAM_ERROR;\n  }\n  /* save header structure */\n\n\n  state.head = head;\n  head.done = false;\n  return Z_OK;\n}\n\nfunction inflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n  var state;\n  var dictid;\n  var ret;\n  /* check state */\n\n  if (!strm\n  /* == Z_NULL */\n  || !strm.state\n  /* == Z_NULL */\n  ) {\n      return Z_STREAM_ERROR;\n    }\n\n  state = strm.state;\n\n  if (state.wrap !== 0 && state.mode !== DICT) {\n    return Z_STREAM_ERROR;\n  }\n  /* check for correct dictionary identifier */\n\n\n  if (state.mode === DICT) {\n    dictid = 1;\n    /* adler32(0, null, 0)*/\n\n    /* dictid = adler32(dictid, dictionary, dictLength); */\n\n    dictid = adler32(dictid, dictionary, dictLength, 0);\n\n    if (dictid !== state.check) {\n      return Z_DATA_ERROR;\n    }\n  }\n  /* copy dictionary to window using updatewindow(), which will amend the\n   existing dictionary if appropriate */\n\n\n  ret = updatewindow(strm, dictionary, dictLength, dictLength);\n\n  if (ret) {\n    state.mode = MEM;\n    return Z_MEM_ERROR;\n  }\n\n  state.havedict = 1; // Tracev((stderr, \"inflate:   dictionary set\\n\"));\n\n  return Z_OK;\n}\n\nexports.inflateReset = inflateReset;\nexports.inflateReset2 = inflateReset2;\nexports.inflateResetKeep = inflateResetKeep;\nexports.inflateInit = inflateInit;\nexports.inflateInit2 = inflateInit2;\nexports.inflate = inflate;\nexports.inflateEnd = inflateEnd;\nexports.inflateGetHeader = inflateGetHeader;\nexports.inflateSetDictionary = inflateSetDictionary;\nexports.inflateInfo = 'pako inflate (from Nodeca project)';\n/* Not implemented\nexports.inflateCopy = inflateCopy;\nexports.inflateGetDictionary = inflateGetDictionary;\nexports.inflateMark = inflateMark;\nexports.inflatePrime = inflatePrime;\nexports.inflateSync = inflateSync;\nexports.inflateSyncPoint = inflateSyncPoint;\nexports.inflateUndermine = inflateUndermine;\n*///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZsYXRlLmpzPzllNmUiXSwibmFtZXMiOlsidXRpbHMiLCJhZGxlcjMyIiwiY3JjMzIiLCJpbmZsYXRlX2Zhc3QiLCJpbmZsYXRlX3RhYmxlIiwiQ09ERVMiLCJMRU5TIiwiRElTVFMiLCJaX0ZJTklTSCIsIlpfQkxPQ0siLCJaX1RSRUVTIiwiWl9PSyIsIlpfU1RSRUFNX0VORCIsIlpfTkVFRF9ESUNUIiwiWl9TVFJFQU1fRVJST1IiLCJaX0RBVEFfRVJST1IiLCJaX01FTV9FUlJPUiIsIlpfQlVGX0VSUk9SIiwiWl9ERUZMQVRFRCIsIkhFQUQiLCJGTEFHUyIsIlRJTUUiLCJPUyIsIkVYTEVOIiwiRVhUUkEiLCJOQU1FIiwiQ09NTUVOVCIsIkhDUkMiLCJESUNUSUQiLCJESUNUIiwiVFlQRSIsIlRZUEVETyIsIlNUT1JFRCIsIkNPUFlfIiwiQ09QWSIsIlRBQkxFIiwiTEVOTEVOUyIsIkNPREVMRU5TIiwiTEVOXyIsIkxFTiIsIkxFTkVYVCIsIkRJU1QiLCJESVNURVhUIiwiTUFUQ0giLCJMSVQiLCJDSEVDSyIsIkxFTkdUSCIsIkRPTkUiLCJCQUQiLCJNRU0iLCJTWU5DIiwiRU5PVUdIX0xFTlMiLCJFTk9VR0hfRElTVFMiLCJNQVhfV0JJVFMiLCJERUZfV0JJVFMiLCJ6c3dhcDMyIiwicSIsIkluZmxhdGVTdGF0ZSIsIm1vZGUiLCJsYXN0Iiwid3JhcCIsImhhdmVkaWN0IiwiZmxhZ3MiLCJkbWF4IiwiY2hlY2siLCJ0b3RhbCIsImhlYWQiLCJ3Yml0cyIsIndzaXplIiwid2hhdmUiLCJ3bmV4dCIsIndpbmRvdyIsImhvbGQiLCJiaXRzIiwibGVuZ3RoIiwib2Zmc2V0IiwiZXh0cmEiLCJsZW5jb2RlIiwiZGlzdGNvZGUiLCJsZW5iaXRzIiwiZGlzdGJpdHMiLCJuY29kZSIsIm5sZW4iLCJuZGlzdCIsImhhdmUiLCJuZXh0IiwibGVucyIsIkJ1ZjE2Iiwid29yayIsImxlbmR5biIsImRpc3RkeW4iLCJzYW5lIiwiYmFjayIsIndhcyIsImluZmxhdGVSZXNldEtlZXAiLCJzdHJtIiwic3RhdGUiLCJ0b3RhbF9pbiIsInRvdGFsX291dCIsIm1zZyIsImFkbGVyIiwiQnVmMzIiLCJpbmZsYXRlUmVzZXQiLCJpbmZsYXRlUmVzZXQyIiwid2luZG93Qml0cyIsImluZmxhdGVJbml0MiIsInJldCIsImluZmxhdGVJbml0IiwidmlyZ2luIiwibGVuZml4IiwiZGlzdGZpeCIsImZpeGVkdGFibGVzIiwic3ltIiwidXBkYXRld2luZG93Iiwic3JjIiwiZW5kIiwiY29weSIsImRpc3QiLCJCdWY4IiwiYXJyYXlTZXQiLCJpbmZsYXRlIiwiZmx1c2giLCJpbnB1dCIsIm91dHB1dCIsInB1dCIsImxlZnQiLCJfaW4iLCJfb3V0IiwiZnJvbSIsImZyb21fc291cmNlIiwiaGVyZSIsImhlcmVfYml0cyIsImhlcmVfb3AiLCJoZXJlX3ZhbCIsImxhc3RfYml0cyIsImxhc3Rfb3AiLCJsYXN0X3ZhbCIsImxlbiIsImhidWYiLCJvcHRzIiwibiIsIm9yZGVyIiwiYXZhaWxfaW4iLCJuZXh0X291dCIsImF2YWlsX291dCIsIm5leHRfaW4iLCJpbmZfbGVhdmUiLCJkb25lIiwidGV4dCIsInRpbWUiLCJ4ZmxhZ3MiLCJvcyIsImV4dHJhX2xlbiIsIkFycmF5IiwibmFtZSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImNvbW1lbnQiLCJoY3JjIiwiZGF0YV90eXBlIiwiaW5mbGF0ZUVuZCIsImluZmxhdGVHZXRIZWFkZXIiLCJpbmZsYXRlU2V0RGljdGlvbmFyeSIsImRpY3Rpb25hcnkiLCJkaWN0TGVuZ3RoIiwiZGljdGlkIiwiZXhwb3J0cyIsImluZmxhdGVJbmZvIl0sIm1hcHBpbmdzIjoiQ0FFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSUEsS0FBSyxHQUFXLG1CQUFP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QkEsVUFBL0IsQ0FBbEI7O0FBQ0EsTUFBSTFELEdBQUosRUFBUztBQUNQVixTQUFLLENBQUN0QyxJQUFOLEdBQWFULEdBQWI7QUFDQSxXQUFPakMsV0FBUDtBQUNEOztBQUNEZ0YsT0FBSyxDQUFDbkMsUUFBTixHQUFpQixDQUFqQixDQS9COEMsQ0FnQzlDOztBQUNBLFNBQU9sRCxJQUFQO0FBQ0Q7O0FBRUQySixPQUFPLENBQUNoRSxZQUFSLEdBQXVCQSxZQUF2QjtBQUNBZ0UsT0FBTyxDQUFDL0QsYUFBUixHQUF3QkEsYUFBeEI7QUFDQStELE9BQU8sQ0FBQ3hFLGdCQUFSLEdBQTJCQSxnQkFBM0I7QUFDQXdFLE9BQU8sQ0FBQzNELFdBQVIsR0FBc0JBLFdBQXRCO0FBQ0EyRCxPQUFPLENBQUM3RCxZQUFSLEdBQXVCQSxZQUF2QjtBQUNBNkQsT0FBTyxDQUFDOUMsT0FBUixHQUFrQkEsT0FBbEI7QUFDQThDLE9BQU8sQ0FBQ04sVUFBUixHQUFxQkEsVUFBckI7QUFDQU0sT0FBTyxDQUFDTCxnQkFBUixHQUEyQkEsZ0JBQTNCO0FBQ0FLLE9BQU8sQ0FBQ0osb0JBQVIsR0FBK0JBLG9CQUEvQjtBQUNBSSxPQUFPLENBQUNDLFdBQVIsR0FBc0Isb0NBQXRCO0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZsYXRlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbnZhciB1dGlscyAgICAgICAgID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG52YXIgYWRsZXIzMiAgICAgICA9IHJlcXVpcmUoJy4vYWRsZXIzMicpO1xudmFyIGNyYzMyICAgICAgICAgPSByZXF1aXJlKCcuL2NyYzMyJyk7XG52YXIgaW5mbGF0ZV9mYXN0ICA9IHJlcXVpcmUoJy4vaW5mZmFzdCcpO1xudmFyIGluZmxhdGVfdGFibGUgPSByZXF1aXJlKCcuL2luZnRyZWVzJyk7XG5cbnZhciBDT0RFUyA9IDA7XG52YXIgTEVOUyA9IDE7XG52YXIgRElTVFMgPSAyO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG4vL3ZhciBaX05PX0ZMVVNIICAgICAgPSAwO1xuLy92YXIgWl9QQVJUSUFMX0ZMVVNIID0gMTtcbi8vdmFyIFpfU1lOQ19GTFVTSCAgICA9IDI7XG4vL3ZhciBaX0ZVTExfRkxVU0ggICAgPSAzO1xudmFyIFpfRklOSVNIICAgICAgICA9IDQ7XG52YXIgWl9CTE9DSyAgICAgICAgID0gNTtcbnZhciBaX1RSRUVTICAgICAgICAgPSA2O1xuXG5cbi8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAqL1xudmFyIFpfT0sgICAgICAgICAgICA9IDA7XG52YXIgWl9TVFJFQU1fRU5EICAgID0gMTtcbnZhciBaX05FRURfRElDVCAgICAgPSAyO1xuLy92YXIgWl9FUlJOTyAgICAgICAgID0gLTE7XG52YXIgWl9TVFJFQU1fRVJST1IgID0gLTI7XG52YXIgWl9EQVRBX0VSUk9SICAgID0gLTM7XG52YXIgWl9NRU1fRVJST1IgICAgID0gLTQ7XG52YXIgWl9CVUZfRVJST1IgICAgID0gLTU7XG4vL3ZhciBaX1ZFUlNJT05fRVJST1IgPSAtNjtcblxuLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG52YXIgWl9ERUZMQVRFRCAgPSA4O1xuXG5cbi8qIFNUQVRFUyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbnZhciAgICBIRUFEID0gMTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbWFnaWMgaGVhZGVyICovXG52YXIgICAgRkxBR1MgPSAyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1ldGhvZCBhbmQgZmxhZ3MgKGd6aXApICovXG52YXIgICAgVElNRSA9IDM7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1vZGlmaWNhdGlvbiB0aW1lIChnemlwKSAqL1xudmFyICAgIE9TID0gNDsgICAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBmbGFncyBhbmQgb3BlcmF0aW5nIHN5c3RlbSAoZ3ppcCkgKi9cbnZhciAgICBFWExFTiA9IDU7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgbGVuZ3RoIChnemlwKSAqL1xudmFyICAgIEVYVFJBID0gNjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBieXRlcyAoZ3ppcCkgKi9cbnZhciAgICBOQU1FID0gNzsgICAgICAgLyogaTogd2FpdGluZyBmb3IgZW5kIG9mIGZpbGUgbmFtZSAoZ3ppcCkgKi9cbnZhciAgICBDT01NRU5UID0gODsgICAgLyogaTogd2FpdGluZyBmb3IgZW5kIG9mIGNvbW1lbnQgKGd6aXApICovXG52YXIgICAgSENSQyA9IDk7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGhlYWRlciBjcmMgKGd6aXApICovXG52YXIgICAgRElDVElEID0gMTA7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpY3Rpb25hcnkgY2hlY2sgdmFsdWUgKi9cbnZhciAgICBESUNUID0gMTE7ICAgICAgLyogd2FpdGluZyBmb3IgaW5mbGF0ZVNldERpY3Rpb25hcnkoKSBjYWxsICovXG52YXIgICAgICAgIFRZUEUgPSAxMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciB0eXBlIGJpdHMsIGluY2x1ZGluZyBsYXN0LWZsYWcgYml0ICovXG52YXIgICAgICAgIFRZUEVETyA9IDEzOyAgICAvKiBpOiBzYW1lLCBidXQgc2tpcCBjaGVjayB0byBleGl0IGluZmxhdGUgb24gbmV3IGJsb2NrICovXG52YXIgICAgICAgIFNUT1JFRCA9IDE0OyAgICAvKiBpOiB3YWl0aW5nIGZvciBzdG9yZWQgc2l6ZSAobGVuZ3RoIGFuZCBjb21wbGVtZW50KSAqL1xudmFyICAgICAgICBDT1BZXyA9IDE1OyAgICAgLyogaS9vOiBzYW1lIGFzIENPUFkgYmVsb3csIGJ1dCBvbmx5IGZpcnN0IHRpbWUgaW4gKi9cbnZhciAgICAgICAgQ09QWSA9IDE2OyAgICAgIC8qIGkvbzogd2FpdGluZyBmb3IgaW5wdXQgb3Igb3V0cHV0IHRvIGNvcHkgc3RvcmVkIGJsb2NrICovXG52YXIgICAgICAgIFRBQkxFID0gMTc7ICAgICAvKiBpOiB3YWl0aW5nIGZvciBkeW5hbWljIGJsb2NrIHRhYmxlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgTEVOTEVOUyA9IDE4OyAgIC8qIGk6IHdhaXRpbmcgZm9yIGNvZGUgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xudmFyICAgICAgICBDT0RFTEVOUyA9IDE5OyAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdCBhbmQgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG52YXIgICAgICAgICAgICBMRU5fID0gMjA7ICAgICAgLyogaTogc2FtZSBhcyBMRU4gYmVsb3csIGJ1dCBvbmx5IGZpcnN0IHRpbWUgaW4gKi9cbnZhciAgICAgICAgICAgIExFTiA9IDIxOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGgvbGl0L2VvYiBjb2RlICovXG52YXIgICAgICAgICAgICBMRU5FWFQgPSAyMjsgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoIGV4dHJhIGJpdHMgKi9cbnZhciAgICAgICAgICAgIERJU1QgPSAyMzsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBkaXN0YW5jZSBjb2RlICovXG52YXIgICAgICAgICAgICBESVNURVhUID0gMjQ7ICAgLyogaTogd2FpdGluZyBmb3IgZGlzdGFuY2UgZXh0cmEgYml0cyAqL1xudmFyICAgICAgICAgICAgTUFUQ0ggPSAyNTsgICAgIC8qIG86IHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZSB0byBjb3B5IHN0cmluZyAqL1xudmFyICAgICAgICAgICAgTElUID0gMjY7ICAgICAgIC8qIG86IHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZSB0byB3cml0ZSBsaXRlcmFsICovXG52YXIgICAgQ0hFQ0sgPSAyNzsgICAgIC8qIGk6IHdhaXRpbmcgZm9yIDMyLWJpdCBjaGVjayB2YWx1ZSAqL1xudmFyICAgIExFTkdUSCA9IDI4OyAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgbGVuZ3RoIChnemlwKSAqL1xudmFyICAgIERPTkUgPSAyOTsgICAgICAvKiBmaW5pc2hlZCBjaGVjaywgZG9uZSAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIEJBRCA9IDMwOyAgICAgICAvKiBnb3QgYSBkYXRhIGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgICAgTUVNID0gMzE7ICAgICAgIC8qIGdvdCBhbiBpbmZsYXRlKCkgbWVtb3J5IGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgICAgU1lOQyA9IDMyOyAgICAgIC8qIGxvb2tpbmcgZm9yIHN5bmNocm9uaXphdGlvbiBieXRlcyB0byByZXN0YXJ0IGluZmxhdGUoKSAqL1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cblxudmFyIEVOT1VHSF9MRU5TID0gODUyO1xudmFyIEVOT1VHSF9ESVNUUyA9IDU5Mjtcbi8vdmFyIEVOT1VHSCA9ICAoRU5PVUdIX0xFTlMrRU5PVUdIX0RJU1RTKTtcblxudmFyIE1BWF9XQklUUyA9IDE1O1xuLyogMzJLIExaNzcgd2luZG93ICovXG52YXIgREVGX1dCSVRTID0gTUFYX1dCSVRTO1xuXG5cbmZ1bmN0aW9uIHpzd2FwMzIocSkge1xuICByZXR1cm4gICgoKHEgPj4+IDI0KSAmIDB4ZmYpICtcbiAgICAgICAgICAoKHEgPj4+IDgpICYgMHhmZjAwKSArXG4gICAgICAgICAgKChxICYgMHhmZjAwKSA8PCA4KSArXG4gICAgICAgICAgKChxICYgMHhmZikgPDwgMjQpKTtcbn1cblxuXG5mdW5jdGlvbiBJbmZsYXRlU3RhdGUoKSB7XG4gIHRoaXMubW9kZSA9IDA7ICAgICAgICAgICAgIC8qIGN1cnJlbnQgaW5mbGF0ZSBtb2RlICovXG4gIHRoaXMubGFzdCA9IGZhbHNlOyAgICAgICAgICAvKiB0cnVlIGlmIHByb2Nlc3NpbmcgbGFzdCBibG9jayAqL1xuICB0aGlzLndyYXAgPSAwOyAgICAgICAgICAgICAgLyogYml0IDAgdHJ1ZSBmb3IgemxpYiwgYml0IDEgdHJ1ZSBmb3IgZ3ppcCAqL1xuICB0aGlzLmhhdmVkaWN0ID0gZmFsc2U7ICAgICAgLyogdHJ1ZSBpZiBkaWN0aW9uYXJ5IHByb3ZpZGVkICovXG4gIHRoaXMuZmxhZ3MgPSAwOyAgICAgICAgICAgICAvKiBnemlwIGhlYWRlciBtZXRob2QgYW5kIGZsYWdzICgwIGlmIHpsaWIpICovXG4gIHRoaXMuZG1heCA9IDA7ICAgICAgICAgICAgICAvKiB6bGliIGhlYWRlciBtYXggZGlzdGFuY2UgKElORkxBVEVfU1RSSUNUKSAqL1xuICB0aGlzLmNoZWNrID0gMDsgICAgICAgICAgICAgLyogcHJvdGVjdGVkIGNvcHkgb2YgY2hlY2sgdmFsdWUgKi9cbiAgdGhpcy50b3RhbCA9IDA7ICAgICAgICAgICAgIC8qIHByb3RlY3RlZCBjb3B5IG9mIG91dHB1dCBjb3VudCAqL1xuICAvLyBUT0RPOiBtYXkgYmUge31cbiAgdGhpcy5oZWFkID0gbnVsbDsgICAgICAgICAgIC8qIHdoZXJlIHRvIHNhdmUgZ3ppcCBoZWFkZXIgaW5mb3JtYXRpb24gKi9cblxuICAvKiBzbGlkaW5nIHdpbmRvdyAqL1xuICB0aGlzLndiaXRzID0gMDsgICAgICAgICAgICAgLyogbG9nIGJhc2UgMiBvZiByZXF1ZXN0ZWQgd2luZG93IHNpemUgKi9cbiAgdGhpcy53c2l6ZSA9IDA7ICAgICAgICAgICAgIC8qIHdpbmRvdyBzaXplIG9yIHplcm8gaWYgbm90IHVzaW5nIHdpbmRvdyAqL1xuICB0aGlzLndoYXZlID0gMDsgICAgICAgICAgICAgLyogdmFsaWQgYnl0ZXMgaW4gdGhlIHdpbmRvdyAqL1xuICB0aGlzLnduZXh0ID0gMDsgICAgICAgICAgICAgLyogd2luZG93IHdyaXRlIGluZGV4ICovXG4gIHRoaXMud2luZG93ID0gbnVsbDsgICAgICAgICAvKiBhbGxvY2F0ZWQgc2xpZGluZyB3aW5kb3csIGlmIG5lZWRlZCAqL1xuXG4gIC8qIGJpdCBhY2N1bXVsYXRvciAqL1xuICB0aGlzLmhvbGQgPSAwOyAgICAgICAgICAgICAgLyogaW5wdXQgYml0IGFjY3VtdWxhdG9yICovXG4gIHRoaXMuYml0cyA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgYml0cyBpbiBcImluXCIgKi9cblxuICAvKiBmb3Igc3RyaW5nIGFuZCBzdG9yZWQgYmxvY2sgY29weWluZyAqL1xuICB0aGlzLmxlbmd0aCA9IDA7ICAgICAgICAgICAgLyogbGl0ZXJhbCBvciBsZW5ndGggb2YgZGF0YSB0byBjb3B5ICovXG4gIHRoaXMub2Zmc2V0ID0gMDsgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYWNrIHRvIGNvcHkgc3RyaW5nIGZyb20gKi9cblxuICAvKiBmb3IgdGFibGUgYW5kIGNvZGUgZGVjb2RpbmcgKi9cbiAgdGhpcy5leHRyYSA9IDA7ICAgICAgICAgICAgIC8qIGV4dHJhIGJpdHMgbmVlZGVkICovXG5cbiAgLyogZml4ZWQgYW5kIGR5bmFtaWMgY29kZSB0YWJsZXMgKi9cbiAgdGhpcy5sZW5jb2RlID0gbnVsbDsgICAgICAgICAgLyogc3RhcnRpbmcgdGFibGUgZm9yIGxlbmd0aC9saXRlcmFsIGNvZGVzICovXG4gIHRoaXMuZGlzdGNvZGUgPSBudWxsOyAgICAgICAgIC8qIHN0YXJ0aW5nIHRhYmxlIGZvciBkaXN0YW5jZSBjb2RlcyAqL1xuICB0aGlzLmxlbmJpdHMgPSAwOyAgICAgICAgICAgLyogaW5kZXggYml0cyBmb3IgbGVuY29kZSAqL1xuICB0aGlzLmRpc3RiaXRzID0gMDsgICAgICAgICAgLyogaW5kZXggYml0cyBmb3IgZGlzdGNvZGUgKi9cblxuICAvKiBkeW5hbWljIHRhYmxlIGJ1aWxkaW5nICovXG4gIHRoaXMubmNvZGUgPSAwOyAgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZSBsZW5ndGggY29kZSBsZW5ndGhzICovXG4gIHRoaXMubmxlbiA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLm5kaXN0ID0gMDsgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLmhhdmUgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGUgbGVuZ3RocyBpbiBsZW5zW10gKi9cbiAgdGhpcy5uZXh0ID0gbnVsbDsgICAgICAgICAgICAgIC8qIG5leHQgYXZhaWxhYmxlIHNwYWNlIGluIGNvZGVzW10gKi9cblxuICB0aGlzLmxlbnMgPSBuZXcgdXRpbHMuQnVmMTYoMzIwKTsgLyogdGVtcG9yYXJ5IHN0b3JhZ2UgZm9yIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLndvcmsgPSBuZXcgdXRpbHMuQnVmMTYoMjg4KTsgLyogd29yayBhcmVhIGZvciBjb2RlIHRhYmxlIGJ1aWxkaW5nICovXG5cbiAgLypcbiAgIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBwb2ludGVycyBpbiBqcywgd2UgdXNlIGxlbmNvZGUgYW5kIGRpc3Rjb2RlIGRpcmVjdGx5XG4gICBhcyBidWZmZXJzIHNvIHdlIGRvbid0IG5lZWQgY29kZXNcbiAgKi9cbiAgLy90aGlzLmNvZGVzID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSCk7ICAgICAgIC8qIHNwYWNlIGZvciBjb2RlIHRhYmxlcyAqL1xuICB0aGlzLmxlbmR5biA9IG51bGw7ICAgICAgICAgICAgICAvKiBkeW5hbWljIHRhYmxlIGZvciBsZW5ndGgvbGl0ZXJhbCBjb2RlcyAoSlMgc3BlY2lmaWMpICovXG4gIHRoaXMuZGlzdGR5biA9IG51bGw7ICAgICAgICAgICAgIC8qIGR5bmFtaWMgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzIChKUyBzcGVjaWZpYykgKi9cbiAgdGhpcy5zYW5lID0gMDsgICAgICAgICAgICAgICAgICAgLyogaWYgZmFsc2UsIGFsbG93IGludmFsaWQgZGlzdGFuY2UgdG9vIGZhciAqL1xuICB0aGlzLmJhY2sgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBiaXRzIGJhY2sgb2YgbGFzdCB1bnByb2Nlc3NlZCBsZW5ndGgvbGl0ICovXG4gIHRoaXMud2FzID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIGluaXRpYWwgbGVuZ3RoIG9mIG1hdGNoICovXG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldEtlZXAoc3RybSkge1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IHN0YXRlLnRvdGFsID0gMDtcbiAgc3RybS5tc2cgPSAnJzsgLypaX05VTEwqL1xuICBpZiAoc3RhdGUud3JhcCkgeyAgICAgICAvKiB0byBzdXBwb3J0IGlsbC1jb25jZWl2ZWQgSmF2YSB0ZXN0IHN1aXRlICovXG4gICAgc3RybS5hZGxlciA9IHN0YXRlLndyYXAgJiAxO1xuICB9XG4gIHN0YXRlLm1vZGUgPSBIRUFEO1xuICBzdGF0ZS5sYXN0ID0gMDtcbiAgc3RhdGUuaGF2ZWRpY3QgPSAwO1xuICBzdGF0ZS5kbWF4ID0gMzI3Njg7XG4gIHN0YXRlLmhlYWQgPSBudWxsLypaX05VTEwqLztcbiAgc3RhdGUuaG9sZCA9IDA7XG4gIHN0YXRlLmJpdHMgPSAwO1xuICAvL3N0YXRlLmxlbmNvZGUgPSBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQgPSBzdGF0ZS5jb2RlcztcbiAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5biA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0hfTEVOUyk7XG4gIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5biA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0hfRElTVFMpO1xuXG4gIHN0YXRlLnNhbmUgPSAxO1xuICBzdGF0ZS5iYWNrID0gLTE7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogcmVzZXRcXG5cIikpO1xuICByZXR1cm4gWl9PSztcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0KHN0cm0pIHtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBzdGF0ZS53c2l6ZSA9IDA7XG4gIHN0YXRlLndoYXZlID0gMDtcbiAgc3RhdGUud25leHQgPSAwO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKTtcblxufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXQyKHN0cm0sIHdpbmRvd0JpdHMpIHtcbiAgdmFyIHdyYXA7XG4gIHZhciBzdGF0ZTtcblxuICAvKiBnZXQgdGhlIHN0YXRlICovXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIC8qIGV4dHJhY3Qgd3JhcCByZXF1ZXN0IGZyb20gd2luZG93Qml0cyBwYXJhbWV0ZXIgKi9cbiAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7XG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG4gIGVsc2Uge1xuICAgIHdyYXAgPSAod2luZG93Qml0cyA+PiA0KSArIDE7XG4gICAgaWYgKHdpbmRvd0JpdHMgPCA0OCkge1xuICAgICAgd2luZG93Qml0cyAmPSAxNTtcbiAgICB9XG4gIH1cblxuICAvKiBzZXQgbnVtYmVyIG9mIHdpbmRvdyBiaXRzLCBmcmVlIHdpbmRvdyBpZiBkaWZmZXJlbnQgKi9cbiAgaWYgKHdpbmRvd0JpdHMgJiYgKHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSkpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cbiAgaWYgKHN0YXRlLndpbmRvdyAhPT0gbnVsbCAmJiBzdGF0ZS53Yml0cyAhPT0gd2luZG93Qml0cykge1xuICAgIHN0YXRlLndpbmRvdyA9IG51bGw7XG4gIH1cblxuICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJlc2V0IHRoZSByZXN0IG9mIGl0ICovXG4gIHN0YXRlLndyYXAgPSB3cmFwO1xuICBzdGF0ZS53Yml0cyA9IHdpbmRvd0JpdHM7XG4gIHJldHVybiBpbmZsYXRlUmVzZXQoc3RybSk7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVJbml0MihzdHJtLCB3aW5kb3dCaXRzKSB7XG4gIHZhciByZXQ7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0pIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIC8vc3RybS5tc2cgPSBaX05VTEw7ICAgICAgICAgICAgICAgICAvKiBpbiBjYXNlIHdlIHJldHVybiBhbiBlcnJvciAqL1xuXG4gIHN0YXRlID0gbmV3IEluZmxhdGVTdGF0ZSgpO1xuXG4gIC8vaWYgKHN0YXRlID09PSBaX05VTEwpIHJldHVybiBaX01FTV9FUlJPUjtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiBhbGxvY2F0ZWRcXG5cIikpO1xuICBzdHJtLnN0YXRlID0gc3RhdGU7XG4gIHN0YXRlLndpbmRvdyA9IG51bGwvKlpfTlVMTCovO1xuICByZXQgPSBpbmZsYXRlUmVzZXQyKHN0cm0sIHdpbmRvd0JpdHMpO1xuICBpZiAocmV0ICE9PSBaX09LKSB7XG4gICAgc3RybS5zdGF0ZSA9IG51bGwvKlpfTlVMTCovO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVJbml0KHN0cm0pIHtcbiAgcmV0dXJuIGluZmxhdGVJbml0MihzdHJtLCBERUZfV0JJVFMpO1xufVxuXG5cbi8qXG4gUmV0dXJuIHN0YXRlIHdpdGggbGVuZ3RoIGFuZCBkaXN0YW5jZSBkZWNvZGluZyB0YWJsZXMgYW5kIGluZGV4IHNpemVzIHNldCB0b1xuIGZpeGVkIGNvZGUgZGVjb2RpbmcuICBOb3JtYWxseSB0aGlzIHJldHVybnMgZml4ZWQgdGFibGVzIGZyb20gaW5mZml4ZWQuaC5cbiBJZiBCVUlMREZJWEVEIGlzIGRlZmluZWQsIHRoZW4gaW5zdGVhZCB0aGlzIHJvdXRpbmUgYnVpbGRzIHRoZSB0YWJsZXMgdGhlXG4gZmlyc3QgdGltZSBpdCdzIGNhbGxlZCwgYW5kIHJldHVybnMgdGhvc2UgdGFibGVzIHRoZSBmaXJzdCB0aW1lIGFuZFxuIHRoZXJlYWZ0ZXIuICBUaGlzIHJlZHVjZXMgdGhlIHNpemUgb2YgdGhlIGNvZGUgYnkgYWJvdXQgMksgYnl0ZXMsIGluXG4gZXhjaGFuZ2UgZm9yIGEgbGl0dGxlIGV4ZWN1dGlvbiB0aW1lLiAgSG93ZXZlciwgQlVJTERGSVhFRCBzaG91bGQgbm90IGJlXG4gdXNlZCBmb3IgdGhyZWFkZWQgYXBwbGljYXRpb25zLCBzaW5jZSB0aGUgcmV3cml0aW5nIG9mIHRoZSB0YWJsZXMgYW5kIHZpcmdpblxuIG1heSBub3QgYmUgdGhyZWFkLXNhZmUuXG4gKi9cbnZhciB2aXJnaW4gPSB0cnVlO1xuXG52YXIgbGVuZml4LCBkaXN0Zml4OyAvLyBXZSBoYXZlIG5vIHBvaW50ZXJzIGluIEpTLCBzbyBrZWVwIHRhYmxlcyBzZXBhcmF0ZVxuXG5mdW5jdGlvbiBmaXhlZHRhYmxlcyhzdGF0ZSkge1xuICAvKiBidWlsZCBmaXhlZCBodWZmbWFuIHRhYmxlcyBpZiBmaXJzdCBjYWxsIChtYXkgbm90IGJlIHRocmVhZCBzYWZlKSAqL1xuICBpZiAodmlyZ2luKSB7XG4gICAgdmFyIHN5bTtcblxuICAgIGxlbmZpeCA9IG5ldyB1dGlscy5CdWYzMig1MTIpO1xuICAgIGRpc3RmaXggPSBuZXcgdXRpbHMuQnVmMzIoMzIpO1xuXG4gICAgLyogbGl0ZXJhbC9sZW5ndGggdGFibGUgKi9cbiAgICBzeW0gPSAwO1xuICAgIHdoaWxlIChzeW0gPCAxNDQpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA4OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI1NikgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDk7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjgwKSB7IHN0YXRlLmxlbnNbc3ltKytdID0gNzsgfVxuICAgIHdoaWxlIChzeW0gPCAyODgpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA4OyB9XG5cbiAgICBpbmZsYXRlX3RhYmxlKExFTlMsICBzdGF0ZS5sZW5zLCAwLCAyODgsIGxlbmZpeCwgICAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDkgfSk7XG5cbiAgICAvKiBkaXN0YW5jZSB0YWJsZSAqL1xuICAgIHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDMyKSB7IHN0YXRlLmxlbnNbc3ltKytdID0gNTsgfVxuXG4gICAgaW5mbGF0ZV90YWJsZShESVNUUywgc3RhdGUubGVucywgMCwgMzIsICAgZGlzdGZpeCwgMCwgc3RhdGUud29yaywgeyBiaXRzOiA1IH0pO1xuXG4gICAgLyogZG8gdGhpcyBqdXN0IG9uY2UgKi9cbiAgICB2aXJnaW4gPSBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmxlbmNvZGUgPSBsZW5maXg7XG4gIHN0YXRlLmxlbmJpdHMgPSA5O1xuICBzdGF0ZS5kaXN0Y29kZSA9IGRpc3RmaXg7XG4gIHN0YXRlLmRpc3RiaXRzID0gNTtcbn1cblxuXG4vKlxuIFVwZGF0ZSB0aGUgd2luZG93IHdpdGggdGhlIGxhc3Qgd3NpemUgKG5vcm1hbGx5IDMySykgYnl0ZXMgd3JpdHRlbiBiZWZvcmVcbiByZXR1cm5pbmcuICBJZiB3aW5kb3cgZG9lcyBub3QgZXhpc3QgeWV0LCBjcmVhdGUgaXQuICBUaGlzIGlzIG9ubHkgY2FsbGVkXG4gd2hlbiBhIHdpbmRvdyBpcyBhbHJlYWR5IGluIHVzZSwgb3Igd2hlbiBvdXRwdXQgaGFzIGJlZW4gd3JpdHRlbiBkdXJpbmcgdGhpc1xuIGluZmxhdGUgY2FsbCwgYnV0IHRoZSBlbmQgb2YgdGhlIGRlZmxhdGUgc3RyZWFtIGhhcyBub3QgYmVlbiByZWFjaGVkIHlldC5cbiBJdCBpcyBhbHNvIGNhbGxlZCB0byBjcmVhdGUgYSB3aW5kb3cgZm9yIGRpY3Rpb25hcnkgZGF0YSB3aGVuIGEgZGljdGlvbmFyeVxuIGlzIGxvYWRlZC5cblxuIFByb3ZpZGluZyBvdXRwdXQgYnVmZmVycyBsYXJnZXIgdGhhbiAzMksgdG8gaW5mbGF0ZSgpIHNob3VsZCBwcm92aWRlIGEgc3BlZWRcbiBhZHZhbnRhZ2UsIHNpbmNlIG9ubHkgdGhlIGxhc3QgMzJLIG9mIG91dHB1dCBpcyBjb3BpZWQgdG8gdGhlIHNsaWRpbmcgd2luZG93XG4gdXBvbiByZXR1cm4gZnJvbSBpbmZsYXRlKCksIGFuZCBzaW5jZSBhbGwgZGlzdGFuY2VzIGFmdGVyIHRoZSBmaXJzdCAzMksgb2ZcbiBvdXRwdXQgd2lsbCBmYWxsIGluIHRoZSBvdXRwdXQgZGF0YSwgbWFraW5nIG1hdGNoIGNvcGllcyBzaW1wbGVyIGFuZCBmYXN0ZXIuXG4gVGhlIGFkdmFudGFnZSBtYXkgYmUgZGVwZW5kZW50IG9uIHRoZSBzaXplIG9mIHRoZSBwcm9jZXNzb3IncyBkYXRhIGNhY2hlcy5cbiAqL1xuZnVuY3Rpb24gdXBkYXRld2luZG93KHN0cm0sIHNyYywgZW5kLCBjb3B5KSB7XG4gIHZhciBkaXN0O1xuICB2YXIgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIC8qIGlmIGl0IGhhc24ndCBiZWVuIGRvbmUgYWxyZWFkeSwgYWxsb2NhdGUgc3BhY2UgZm9yIHRoZSB3aW5kb3cgKi9cbiAgaWYgKHN0YXRlLndpbmRvdyA9PT0gbnVsbCkge1xuICAgIHN0YXRlLndzaXplID0gMSA8PCBzdGF0ZS53Yml0cztcbiAgICBzdGF0ZS53bmV4dCA9IDA7XG4gICAgc3RhdGUud2hhdmUgPSAwO1xuXG4gICAgc3RhdGUud2luZG93ID0gbmV3IHV0aWxzLkJ1Zjgoc3RhdGUud3NpemUpO1xuICB9XG5cbiAgLyogY29weSBzdGF0ZS0+d3NpemUgb3IgbGVzcyBvdXRwdXQgYnl0ZXMgaW50byB0aGUgY2lyY3VsYXIgd2luZG93ICovXG4gIGlmIChjb3B5ID49IHN0YXRlLndzaXplKSB7XG4gICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIHN0YXRlLndzaXplLCBzdGF0ZS53c2l6ZSwgMCk7XG4gICAgc3RhdGUud25leHQgPSAwO1xuICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7XG4gIH1cbiAgZWxzZSB7XG4gICAgZGlzdCA9IHN0YXRlLndzaXplIC0gc3RhdGUud25leHQ7XG4gICAgaWYgKGRpc3QgPiBjb3B5KSB7XG4gICAgICBkaXN0ID0gY29weTtcbiAgICB9XG4gICAgLy96bWVtY3B5KHN0YXRlLT53aW5kb3cgKyBzdGF0ZS0+d25leHQsIGVuZCAtIGNvcHksIGRpc3QpO1xuICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBjb3B5LCBkaXN0LCBzdGF0ZS53bmV4dCk7XG4gICAgY29weSAtPSBkaXN0O1xuICAgIGlmIChjb3B5KSB7XG4gICAgICAvL3ptZW1jcHkoc3RhdGUtPndpbmRvdywgZW5kIC0gY29weSwgY29weSk7XG4gICAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gY29weSwgY29weSwgMCk7XG4gICAgICBzdGF0ZS53bmV4dCA9IGNvcHk7XG4gICAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHN0YXRlLnduZXh0ICs9IGRpc3Q7XG4gICAgICBpZiAoc3RhdGUud25leHQgPT09IHN0YXRlLndzaXplKSB7IHN0YXRlLnduZXh0ID0gMDsgfVxuICAgICAgaWYgKHN0YXRlLndoYXZlIDwgc3RhdGUud3NpemUpIHsgc3RhdGUud2hhdmUgKz0gZGlzdDsgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZShzdHJtLCBmbHVzaCkge1xuICB2YXIgc3RhdGU7XG4gIHZhciBpbnB1dCwgb3V0cHV0OyAgICAgICAgICAvLyBpbnB1dC9vdXRwdXQgYnVmZmVyc1xuICB2YXIgbmV4dDsgICAgICAgICAgICAgICAgICAgLyogbmV4dCBpbnB1dCBJTkRFWCAqL1xuICB2YXIgcHV0OyAgICAgICAgICAgICAgICAgICAgLyogbmV4dCBvdXRwdXQgSU5ERVggKi9cbiAgdmFyIGhhdmUsIGxlZnQ7ICAgICAgICAgICAgIC8qIGF2YWlsYWJsZSBpbnB1dCBhbmQgb3V0cHV0ICovXG4gIHZhciBob2xkOyAgICAgICAgICAgICAgICAgICAvKiBiaXQgYnVmZmVyICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgICAgICAgICAvKiBiaXRzIGluIGJpdCBidWZmZXIgKi9cbiAgdmFyIF9pbiwgX291dDsgICAgICAgICAgICAgIC8qIHNhdmUgc3RhcnRpbmcgYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgKi9cbiAgdmFyIGNvcHk7ICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBzdG9yZWQgb3IgbWF0Y2ggYnl0ZXMgdG8gY29weSAqL1xuICB2YXIgZnJvbTsgICAgICAgICAgICAgICAgICAgLyogd2hlcmUgdG8gY29weSBtYXRjaCBieXRlcyBmcm9tICovXG4gIHZhciBmcm9tX3NvdXJjZTtcbiAgdmFyIGhlcmUgPSAwOyAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgZGVjb2RpbmcgdGFibGUgZW50cnkgKi9cbiAgdmFyIGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7IC8vIHBha2VkIFwiaGVyZVwiIGRlbm9ybWFsaXplZCAoSlMgc3BlY2lmaWMpXG4gIC8vdmFyIGxhc3Q7ICAgICAgICAgICAgICAgICAgIC8qIHBhcmVudCB0YWJsZSBlbnRyeSAqL1xuICB2YXIgbGFzdF9iaXRzLCBsYXN0X29wLCBsYXN0X3ZhbDsgLy8gcGFrZWQgXCJsYXN0XCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgdmFyIGxlbjsgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCB0byBjb3B5IGZvciByZXBlYXRzLCBiaXRzIHRvIGRyb3AgKi9cbiAgdmFyIHJldDsgICAgICAgICAgICAgICAgICAgIC8qIHJldHVybiBjb2RlICovXG4gIHZhciBoYnVmID0gbmV3IHV0aWxzLkJ1ZjgoNCk7ICAgIC8qIGJ1ZmZlciBmb3IgZ3ppcCBoZWFkZXIgY3JjIGNhbGN1bGF0aW9uICovXG4gIHZhciBvcHRzO1xuXG4gIHZhciBuOyAvLyB0ZW1wb3JhcnkgdmFyIGZvciBORUVEX0JJVFNcblxuICB2YXIgb3JkZXIgPSAvKiBwZXJtdXRhdGlvbiBvZiBjb2RlIGxlbmd0aHMgKi9cbiAgICBbIDE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTUgXTtcblxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fCAhc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHsgc3RhdGUubW9kZSA9IFRZUEVETzsgfSAgICAvKiBza2lwIGNoZWNrICovXG5cblxuICAvLy0tLSBMT0FEKCkgLS0tXG4gIHB1dCA9IHN0cm0ubmV4dF9vdXQ7XG4gIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7XG4gIG5leHQgPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47XG4gIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICBiaXRzID0gc3RhdGUuYml0cztcbiAgLy8tLS1cblxuICBfaW4gPSBoYXZlO1xuICBfb3V0ID0gbGVmdDtcbiAgcmV0ID0gWl9PSztcblxuICBpbmZfbGVhdmU6IC8vIGdvdG8gZW11bGF0aW9uXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKHN0YXRlLm1vZGUpIHtcbiAgICAgIGNhc2UgSEVBRDpcbiAgICAgICAgaWYgKHN0YXRlLndyYXAgPT09IDApIHtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRURPO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTtcbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoKHN0YXRlLndyYXAgJiAyKSAmJiBob2xkID09PSAweDhiMWYpIHsgIC8qIGd6aXAgaGVhZGVyICovXG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSAwLypjcmMzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG5cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5tb2RlID0gRkxBR1M7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZmxhZ3MgPSAwOyAgICAgICAgICAgLyogZXhwZWN0IHpsaWIgaGVhZGVyICovXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5kb25lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoc3RhdGUud3JhcCAmIDEpIHx8ICAgLyogY2hlY2sgaWYgemxpYiBoZWFkZXIgYWxsb3dlZCAqL1xuICAgICAgICAgICgoKGhvbGQgJiAweGZmKS8qQklUUyg4KSovIDw8IDgpICsgKGhvbGQgPj4gOCkpICUgMzEpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgaGVhZGVyIGNoZWNrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gIT09IFpfREVGTEFURUQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyg0KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNDtcbiAgICAgICAgYml0cyAtPSA0O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIGxlbiA9IChob2xkICYgMHgwZikvKkJJVFMoNCkqLyArIDg7XG4gICAgICAgIGlmIChzdGF0ZS53Yml0cyA9PT0gMCkge1xuICAgICAgICAgIHN0YXRlLndiaXRzID0gbGVuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlbiA+IHN0YXRlLndiaXRzKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCB3aW5kb3cgc2l6ZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5kbWF4ID0gMSA8PCBsZW47XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICB6bGliIGhlYWRlciBva1xcblwiKSk7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDEvKmFkbGVyMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgc3RhdGUubW9kZSA9IGhvbGQgJiAweDIwMCA/IERJQ1RJRCA6IFRZUEU7XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRkxBR1M6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5mbGFncyA9IGhvbGQ7XG4gICAgICAgIGlmICgoc3RhdGUuZmxhZ3MgJiAweGZmKSAhPT0gWl9ERUZMQVRFRCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gY29tcHJlc3Npb24gbWV0aG9kJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4ZTAwMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gaGVhZGVyIGZsYWdzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQudGV4dCA9ICgoaG9sZCA+PiA4KSAmIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBUSU1FO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRJTUU6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQudGltZSA9IGhvbGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDNChzdGF0ZS5jaGVjaywgaG9sZClcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsyXSA9IChob2xkID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhidWZbM10gPSAoaG9sZCA+Pj4gMjQpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCA0LCAwKTtcbiAgICAgICAgICAvLz09PVxuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gT1M7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgT1M6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQueGZsYWdzID0gKGhvbGQgJiAweGZmKTtcbiAgICAgICAgICBzdGF0ZS5oZWFkLm9zID0gKGhvbGQgPj4gOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IEVYTEVOO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIEVYTEVOOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA0MDApIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLmxlbmd0aCA9IGhvbGQ7XG4gICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmFfbGVuID0gaG9sZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbnVsbC8qWl9OVUxMKi87XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IEVYVFJBO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIEVYVFJBOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA0MDApIHtcbiAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgeyBjb3B5ID0gaGF2ZTsgfVxuICAgICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgICAgICBsZW4gPSBzdGF0ZS5oZWFkLmV4dHJhX2xlbiAtIHN0YXRlLmxlbmd0aDtcbiAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5oZWFkLmV4dHJhKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIHVudHlwZWQgYXJyYXkgZm9yIG1vcmUgY29udmVuaWVudCBwcm9jZXNzaW5nIGxhdGVyXG4gICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG5ldyBBcnJheShzdGF0ZS5oZWFkLmV4dHJhX2xlbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdXRpbHMuYXJyYXlTZXQoXG4gICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSxcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgICAgIC8vIGV4dHJhIGZpZWxkIGlzIGxpbWl0ZWQgdG8gNjU1MzYgYnl0ZXNcbiAgICAgICAgICAgICAgICAvLyAtIG5vIG5lZWQgZm9yIGFkZGl0aW9uYWwgc2l6ZSBjaGVja1xuICAgICAgICAgICAgICAgIGNvcHksXG4gICAgICAgICAgICAgICAgLypsZW4gKyBjb3B5ID4gc3RhdGUuaGVhZC5leHRyYV9tYXggLSBsZW4gPyBzdGF0ZS5oZWFkLmV4dHJhX21heCA6IGNvcHksKi9cbiAgICAgICAgICAgICAgICBsZW5cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgLy96bWVtY3B5KHN0YXRlLmhlYWQuZXh0cmEgKyBsZW4sIG5leHQsXG4gICAgICAgICAgICAgIC8vICAgICAgICBsZW4gKyBjb3B5ID4gc3RhdGUuaGVhZC5leHRyYV9tYXggP1xuICAgICAgICAgICAgICAvLyAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9tYXggLSBsZW4gOiBjb3B5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTkFNRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBOQU1FOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA4MDApIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBjb3B5ID0gMDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAvLyBUT0RPOiAyIG9yIDEgYnl0ZXM/XG4gICAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTtcbiAgICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovXG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiZcbiAgICAgICAgICAgICAgICAoc3RhdGUubGVuZ3RoIDwgNjU1MzYgLypzdGF0ZS5oZWFkLm5hbWVfbWF4Ki8pKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTtcblxuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IENPTU1FTlQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09NTUVOVDpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgxMDAwKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgY29weSA9IDA7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5jb21tX21heCovKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgaWYgKGxlbikgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gSENSQztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBIQ1JDOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUuY2hlY2sgJiAweGZmZmYpKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdoZWFkZXIgY3JjIG1pc21hdGNoJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmhjcmMgPSAoKHN0YXRlLmZsYWdzID4+IDkpICYgMSk7XG4gICAgICAgICAgc3RhdGUuaGVhZC5kb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJQ1RJRDpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IHpzd2FwMzIoaG9sZCk7XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElDVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESUNUOlxuICAgICAgICBpZiAoc3RhdGUuaGF2ZWRpY3QgPT09IDApIHtcbiAgICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgICAvLy0tLVxuICAgICAgICAgIHJldHVybiBaX05FRURfRElDVDtcbiAgICAgICAgfVxuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxLyphZGxlcjMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRZUEU6XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9CTE9DSyB8fCBmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUWVBFRE86XG4gICAgICAgIGlmIChzdGF0ZS5sYXN0KSB7XG4gICAgICAgICAgLy8tLS0gQllURUJJVFMoKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBiaXRzICYgNztcbiAgICAgICAgICBiaXRzIC09IGJpdHMgJiA3O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQ0hFQ0s7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMyk7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMykge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5sYXN0ID0gKGhvbGQgJiAweDAxKS8qQklUUygxKSovO1xuICAgICAgICAvLy0tLSBEUk9QQklUUygxKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gMTtcbiAgICAgICAgYml0cyAtPSAxO1xuICAgICAgICAvLy0tLS8vXG5cbiAgICAgICAgc3dpdGNoICgoaG9sZCAmIDB4MDMpLypCSVRTKDIpKi8pIHtcbiAgICAgICAgICBjYXNlIDA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBzdG9yZWQgYmxvY2sgKi9cbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIHN0b3JlZCBibG9jayVzXFxuXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IFNUT1JFRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGZpeGVkIGJsb2NrICovXG4gICAgICAgICAgICBmaXhlZHRhYmxlcyhzdGF0ZSk7XG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBmaXhlZCBjb2RlcyBibG9jayVzXFxuXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTl87ICAgICAgICAgICAgIC8qIGRlY29kZSBjb2RlcyAqL1xuICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZHluYW1pYyBibG9jayAqL1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZHluYW1pYyBjb2RlcyBibG9jayVzXFxuXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRBQkxFO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBibG9jayB0eXBlJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU1RPUkVEOlxuICAgICAgICAvLy0tLSBCWVRFQklUUygpIC0tLS8vIC8qIGdvIHRvIGJ5dGUgYm91bmRhcnkgKi9cbiAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3O1xuICAgICAgICBiaXRzIC09IGJpdHMgJiA3O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoKGhvbGQgJiAweGZmZmYpICE9PSAoKGhvbGQgPj4+IDE2KSBeIDB4ZmZmZikpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHN0b3JlZCBibG9jayBsZW5ndGhzJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IGhvbGQgJiAweGZmZmY7XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgc3RvcmVkIGxlbmd0aCAldVxcblwiLFxuICAgICAgICAvLyAgICAgICAgc3RhdGUubGVuZ3RoKSk7XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ09QWV87XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT1BZXzpcbiAgICAgICAgc3RhdGUubW9kZSA9IENPUFk7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09QWTpcbiAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgaWYgKGNvcHkpIHtcbiAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH1cbiAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbiAgICAgICAgICBpZiAoY29weSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAvLy0tLSB6bWVtY3B5KHB1dCwgbmV4dCwgY29weSk7IC0tLVxuICAgICAgICAgIHV0aWxzLmFycmF5U2V0KG91dHB1dCwgaW5wdXQsIG5leHQsIGNvcHksIHB1dCk7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgbGVmdCAtPSBjb3B5O1xuICAgICAgICAgIHB1dCArPSBjb3B5O1xuICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgc3RvcmVkIGVuZFxcblwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVEFCTEU6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE0KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNCkge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5ubGVuID0gKGhvbGQgJiAweDFmKS8qQklUUyg1KSovICsgMjU3O1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg1KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNTtcbiAgICAgICAgYml0cyAtPSA1O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLm5kaXN0ID0gKGhvbGQgJiAweDFmKS8qQklUUyg1KSovICsgMTtcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDU7XG4gICAgICAgIGJpdHMgLT0gNTtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5uY29kZSA9IChob2xkICYgMHgwZikvKkJJVFMoNCkqLyArIDQ7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDQpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA0O1xuICAgICAgICBiaXRzIC09IDQ7XG4gICAgICAgIC8vLS0tLy9cbi8vI2lmbmRlZiBQS1pJUF9CVUdfV09SS0FST1VORFxuICAgICAgICBpZiAoc3RhdGUubmxlbiA+IDI4NiB8fCBzdGF0ZS5uZGlzdCA+IDMwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndG9vIG1hbnkgbGVuZ3RoIG9yIGRpc3RhbmNlIHN5bWJvbHMnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgdGFibGUgc2l6ZXMgb2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5oYXZlID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkxFTlM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOTEVOUzpcbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCBzdGF0ZS5uY29kZSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMykge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLmxlbnNbb3JkZXJbc3RhdGUuaGF2ZSsrXV0gPSAoaG9sZCAmIDB4MDcpOy8vQklUUygzKTtcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUygzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSAzO1xuICAgICAgICAgIGJpdHMgLT0gMztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCAxOSkge1xuICAgICAgICAgIHN0YXRlLmxlbnNbb3JkZXJbc3RhdGUuaGF2ZSsrXV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICAgICAgICAvL3N0YXRlLmxlbmNvZGUgPSBzdGF0ZS5uZXh0O1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdXNlIGR5bmFtaWMgdGFibGVcbiAgICAgICAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5bjtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IDc7XG5cbiAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUubGVuYml0cyB9O1xuICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKENPREVTLCBzdGF0ZS5sZW5zLCAwLCAxOSwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSBsZW5ndGhzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIGNvZGUgbGVuZ3RocyBva1xcblwiKSk7XG4gICAgICAgIHN0YXRlLmhhdmUgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ09ERUxFTlM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09ERUxFTlM6XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDEpXTsvKkJJVFMoc3RhdGUubGVuYml0cykqL1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGVyZV92YWwgPCAxNikge1xuICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gaGVyZV92YWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGhlcmVfdmFsID09PSAxNikge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAyKTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDI7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZW4gPSBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUgLSAxXTtcbiAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDMpOy8vQklUUygyKTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGVyZV92YWwgPT09IDE3KSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDMpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMztcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDcpOy8vQklUUygzKTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDcpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgNztcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgICAgY29weSA9IDExICsgKGhvbGQgJiAweDdmKTsvL0JJVFMoNyk7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDcpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSA3O1xuICAgICAgICAgICAgICBiaXRzIC09IDc7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlICsgY29weSA+IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0JztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY29weS0tKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiBoYW5kbGUgZXJyb3IgYnJlYWtzIGluIHdoaWxlICovXG4gICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBCQUQpIHsgYnJlYWs7IH1cblxuICAgICAgICAvKiBjaGVjayBmb3IgZW5kLW9mLWJsb2NrIGNvZGUgKGJldHRlciBoYXZlIG9uZSkgKi9cbiAgICAgICAgaWYgKHN0YXRlLmxlbnNbMjU2XSA9PT0gMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSAtLSBtaXNzaW5nIGVuZC1vZi1ibG9jayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGJ1aWxkIGNvZGUgdGFibGVzIC0tIG5vdGU6IGRvIG5vdCBjaGFuZ2UgdGhlIGxlbmJpdHMgb3IgZGlzdGJpdHNcbiAgICAgICAgICAgdmFsdWVzIGhlcmUgKDkgYW5kIDYpIHdpdGhvdXQgcmVhZGluZyB0aGUgY29tbWVudHMgaW4gaW5mdHJlZXMuaFxuICAgICAgICAgICBjb25jZXJuaW5nIHRoZSBFTk9VR0ggY29uc3RhbnRzLCB3aGljaCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzICovXG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSA5O1xuXG4gICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShMRU5TLCBzdGF0ZS5sZW5zLCAwLCBzdGF0ZS5ubGVuLCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy8gc3RhdGUubmV4dF9pbmRleCA9IG9wdHMudGFibGVfaW5kZXg7XG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAgIC8vIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5uZXh0O1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RocyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5kaXN0Yml0cyA9IDY7XG4gICAgICAgIC8vc3RhdGUuZGlzdGNvZGUuY29weShzdGF0ZS5jb2Rlcyk7XG4gICAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZVxuICAgICAgICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW47XG4gICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmRpc3RiaXRzIH07XG4gICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoRElTVFMsIHN0YXRlLmxlbnMsIHN0YXRlLm5sZW4sIHN0YXRlLm5kaXN0LCBzdGF0ZS5kaXN0Y29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgICBzdGF0ZS5kaXN0Yml0cyA9IG9wdHMuYml0cztcbiAgICAgICAgLy8gc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5uZXh0O1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlcyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgJ2luZmxhdGU6ICAgICAgIGNvZGVzIG9rXFxuJykpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOXztcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTl86XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU47XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOOlxuICAgICAgICBpZiAoaGF2ZSA+PSA2ICYmIGxlZnQgPj0gMjU4KSB7XG4gICAgICAgICAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICAgICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gICAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gICAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7XG4gICAgICAgICAgLy8tLS1cbiAgICAgICAgICBpbmZsYXRlX2Zhc3Qoc3RybSwgX291dCk7XG4gICAgICAgICAgLy8tLS0gTE9BRCgpIC0tLVxuICAgICAgICAgIHB1dCA9IHN0cm0ubmV4dF9vdXQ7XG4gICAgICAgICAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gICAgICAgICAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICAgICAgICAgIG5leHQgPSBzdHJtLm5leHRfaW47XG4gICAgICAgICAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICAgICAgICAgIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICAgICAgICAgIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICAgICAgICAgIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICAgICAgICAgIC8vLS0tXG5cbiAgICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkge1xuICAgICAgICAgICAgc3RhdGUuYmFjayA9IC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5iYWNrID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUubGVuYml0cykgLSAxKV07ICAvKkJJVFMoc3RhdGUubGVuYml0cykqL1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoaGVyZV9iaXRzIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiYgKGhlcmVfb3AgJiAweGYwKSA9PT0gMCkge1xuICAgICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0cztcbiAgICAgICAgICBsYXN0X29wID0gaGVyZV9vcDtcbiAgICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsO1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2xhc3RfdmFsICtcbiAgICAgICAgICAgICAgICAgICAgKChob2xkICYgKCgxIDw8IChsYXN0X2JpdHMgKyBsYXN0X29wKSkgLSAxKSkvKkJJVFMobGFzdC5iaXRzICsgbGFzdC5vcCkqLyA+PiBsYXN0X2JpdHMpXTtcbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGxhc3RfYml0cyArIGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMobGFzdC5iaXRzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7XG4gICAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IGhlcmVfdmFsO1xuICAgICAgICBpZiAoaGVyZV9vcCA9PT0gMCkge1xuICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsICclYydcXG5cIiA6XG4gICAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsIDB4JTAyeFxcblwiLCBoZXJlLnZhbCkpO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBMSVQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiAzMikge1xuICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZW5kIG9mIGJsb2NrXFxuXCIpKTtcbiAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5leHRyYSA9IGhlcmVfb3AgJiAxNTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkVYVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5FWFQ6XG4gICAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKHN0YXRlLmV4dHJhKTtcbiAgICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuZ3RoICs9IGhvbGQgJiAoKDEgPDwgc3RhdGUuZXh0cmEpIC0gMSkvKkJJVFMoc3RhdGUuZXh0cmEpKi87XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBsZW5ndGggJXVcXG5cIiwgc3RhdGUubGVuZ3RoKSk7XG4gICAgICAgIHN0YXRlLndhcyA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgc3RhdGUubW9kZSA9IERJU1Q7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElTVDpcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDEpXTsvKkJJVFMoc3RhdGUuZGlzdGJpdHMpKi9cbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKChoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKChoZXJlX29wICYgMHhmMCkgPT09IDApIHtcbiAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbbGFzdF92YWwgK1xuICAgICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtIDEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgICBiaXRzIC09IGxhc3RfYml0cztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgY29kZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5vZmZzZXQgPSBoZXJlX3ZhbDtcbiAgICAgICAgc3RhdGUuZXh0cmEgPSAoaGVyZV9vcCkgJiAxNTtcbiAgICAgICAgc3RhdGUubW9kZSA9IERJU1RFWFQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElTVEVYVDpcbiAgICAgICAgaWYgKHN0YXRlLmV4dHJhKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoc3RhdGUuZXh0cmEpO1xuICAgICAgICAgIG4gPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5vZmZzZXQgKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLSAxKS8qQklUUyhzdGF0ZS5leHRyYSkqLztcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgfVxuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IHN0YXRlLmRtYXgpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBzdGF0ZS5vZmZzZXQpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IE1BVENIO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE1BVENIOlxuICAgICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgY29weSA9IF9vdXQgLSBsZWZ0O1xuICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gY29weSkgeyAgICAgICAgIC8qIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICBjb3B5ID0gc3RhdGUub2Zmc2V0IC0gY29weTtcbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLndoYXZlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuLy8gICAgICAgICAgVHJhY2UoKHN0ZGVyciwgXCJpbmZsYXRlLmMgdG9vIGZhclxcblwiKSk7XG4vLyAgICAgICAgICBjb3B5IC09IHN0YXRlLndoYXZlO1xuLy8gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsgY29weSA9IHN0YXRlLmxlbmd0aDsgfVxuLy8gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4vLyAgICAgICAgICBsZWZ0IC09IGNvcHk7XG4vLyAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbi8vICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IDA7XG4vLyAgICAgICAgICB9IHdoaWxlICgtLWNvcHkpO1xuLy8gICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4vLyAgICAgICAgICBicmVhaztcbi8vI2VuZGlmXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUud25leHQpIHtcbiAgICAgICAgICAgIGNvcHkgLT0gc3RhdGUud25leHQ7XG4gICAgICAgICAgICBmcm9tID0gc3RhdGUud3NpemUgLSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53bmV4dCAtIGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbiAgICAgICAgICBmcm9tX3NvdXJjZSA9IHN0YXRlLndpbmRvdztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBjb3B5IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgZnJvbSA9IHB1dCAtIHN0YXRlLm9mZnNldDtcbiAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgIH0gd2hpbGUgKC0tY29weSk7XG4gICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTElUOlxuICAgICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgb3V0cHV0W3B1dCsrXSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgbGVmdC0tO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ0hFQ0s6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgLy8gVXNlICd8JyBpbnN0ZWFkIG9mICcrJyB0byBtYWtlIHN1cmUgdGhhdCByZXN1bHQgaXMgc2lnbmVkXG4gICAgICAgICAgICBob2xkIHw9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIF9vdXQgLT0gbGVmdDtcbiAgICAgICAgICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICAgICAgICAgIHN0YXRlLnRvdGFsICs9IF9vdXQ7XG4gICAgICAgICAgaWYgKF9vdXQpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9XG4gICAgICAgICAgICAgICAgLypVUERBVEUoc3RhdGUuY2hlY2ssIHB1dCAtIF9vdXQsIF9vdXQpOyovXG4gICAgICAgICAgICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCkgOiBhZGxlcjMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpKTtcblxuICAgICAgICAgIH1cbiAgICAgICAgICBfb3V0ID0gbGVmdDtcbiAgICAgICAgICAvLyBOQjogY3JjMzIgc3RvcmVkIGFzIHNpZ25lZCAzMi1iaXQgaW50LCB6c3dhcDMyIHJldHVybnMgc2lnbmVkIHRvb1xuICAgICAgICAgIGlmICgoc3RhdGUuZmxhZ3MgPyBob2xkIDogenN3YXAzMihob2xkKSkgIT09IHN0YXRlLmNoZWNrKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgZGF0YSBjaGVjayc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBjaGVjayBtYXRjaGVzIHRyYWlsZXJcXG5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5HVEg7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOR1RIOlxuICAgICAgICBpZiAoc3RhdGUud3JhcCAmJiBzdGF0ZS5mbGFncykge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS50b3RhbCAmIDB4ZmZmZmZmZmYpKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgbGVuZ3RoIGNoZWNrJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGxlbmd0aCBtYXRjaGVzIHRyYWlsZXJcXG5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBET05FO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERPTkU6XG4gICAgICAgIHJldCA9IFpfU1RSRUFNX0VORDtcbiAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgY2FzZSBCQUQ6XG4gICAgICAgIHJldCA9IFpfREFUQV9FUlJPUjtcbiAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgY2FzZSBNRU06XG4gICAgICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgICAgIGNhc2UgU1lOQzpcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIH1cbiAgfVxuXG4gIC8vIGluZl9sZWF2ZSA8LSBoZXJlIGlzIHJlYWwgcGxhY2UgZm9yIFwiZ290byBpbmZfbGVhdmVcIiwgZW11bGF0ZWQgdmlhIFwiYnJlYWsgaW5mX2xlYXZlXCJcblxuICAvKlxuICAgICBSZXR1cm4gZnJvbSBpbmZsYXRlKCksIHVwZGF0aW5nIHRoZSB0b3RhbCBjb3VudHMgYW5kIHRoZSBjaGVjayB2YWx1ZS5cbiAgICAgSWYgdGhlcmUgd2FzIG5vIHByb2dyZXNzIGR1cmluZyB0aGUgaW5mbGF0ZSgpIGNhbGwsIHJldHVybiBhIGJ1ZmZlclxuICAgICBlcnJvci4gIENhbGwgdXBkYXRld2luZG93KCkgdG8gY3JlYXRlIGFuZC9vciB1cGRhdGUgdGhlIHdpbmRvdyBzdGF0ZS5cbiAgICAgTm90ZTogYSBtZW1vcnkgZXJyb3IgZnJvbSBpbmZsYXRlKCkgaXMgbm9uLXJlY292ZXJhYmxlLlxuICAgKi9cblxuICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gIHN0YXRlLmhvbGQgPSBob2xkO1xuICBzdGF0ZS5iaXRzID0gYml0cztcbiAgLy8tLS1cblxuICBpZiAoc3RhdGUud3NpemUgfHwgKF9vdXQgIT09IHN0cm0uYXZhaWxfb3V0ICYmIHN0YXRlLm1vZGUgPCBCQUQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA8IENIRUNLIHx8IGZsdXNoICE9PSBaX0ZJTklTSCkpKSB7XG4gICAgaWYgKHVwZGF0ZXdpbmRvdyhzdHJtLCBzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCwgX291dCAtIHN0cm0uYXZhaWxfb3V0KSkge1xuICAgICAgc3RhdGUubW9kZSA9IE1FTTtcbiAgICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgICB9XG4gIH1cbiAgX2luIC09IHN0cm0uYXZhaWxfaW47XG4gIF9vdXQgLT0gc3RybS5hdmFpbF9vdXQ7XG4gIHN0cm0udG90YWxfaW4gKz0gX2luO1xuICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICBzdGF0ZS50b3RhbCArPSBfb3V0O1xuICBpZiAoc3RhdGUud3JhcCAmJiBfb3V0KSB7XG4gICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gLypVUERBVEUoc3RhdGUuY2hlY2ssIHN0cm0ubmV4dF9vdXQgLSBfb3V0LCBfb3V0KTsqL1xuICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCkpO1xuICB9XG4gIHN0cm0uZGF0YV90eXBlID0gc3RhdGUuYml0cyArIChzdGF0ZS5sYXN0ID8gNjQgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlID09PSBUWVBFID8gMTI4IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gTEVOXyB8fCBzdGF0ZS5tb2RlID09PSBDT1BZXyA/IDI1NiA6IDApO1xuICBpZiAoKChfaW4gPT09IDAgJiYgX291dCA9PT0gMCkgfHwgZmx1c2ggPT09IFpfRklOSVNIKSAmJiByZXQgPT09IFpfT0spIHtcbiAgICByZXQgPSBaX0JVRl9FUlJPUjtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlRW5kKHN0cm0pIHtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgLyp8fCBzdHJtLT56ZnJlZSA9PSAoZnJlZV9mdW5jKTAqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHZhciBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmIChzdGF0ZS53aW5kb3cpIHtcbiAgICBzdGF0ZS53aW5kb3cgPSBudWxsO1xuICB9XG4gIHN0cm0uc3RhdGUgPSBudWxsO1xuICByZXR1cm4gWl9PSztcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUdldEhlYWRlcihzdHJtLCBoZWFkKSB7XG4gIHZhciBzdGF0ZTtcblxuICAvKiBjaGVjayBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKChzdGF0ZS53cmFwICYgMikgPT09IDApIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG5cbiAgLyogc2F2ZSBoZWFkZXIgc3RydWN0dXJlICovXG4gIHN0YXRlLmhlYWQgPSBoZWFkO1xuICBoZWFkLmRvbmUgPSBmYWxzZTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVTZXREaWN0aW9uYXJ5KHN0cm0sIGRpY3Rpb25hcnkpIHtcbiAgdmFyIGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDtcblxuICB2YXIgc3RhdGU7XG4gIHZhciBkaWN0aWQ7XG4gIHZhciByZXQ7XG5cbiAgLyogY2hlY2sgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIC8qID09IFpfTlVMTCAqLyB8fCAhc3RybS5zdGF0ZSAvKiA9PSBaX05VTEwgKi8pIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICBpZiAoc3RhdGUud3JhcCAhPT0gMCAmJiBzdGF0ZS5tb2RlICE9PSBESUNUKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgLyogY2hlY2sgZm9yIGNvcnJlY3QgZGljdGlvbmFyeSBpZGVudGlmaWVyICovXG4gIGlmIChzdGF0ZS5tb2RlID09PSBESUNUKSB7XG4gICAgZGljdGlkID0gMTsgLyogYWRsZXIzMigwLCBudWxsLCAwKSovXG4gICAgLyogZGljdGlkID0gYWRsZXIzMihkaWN0aWQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpOyAqL1xuICAgIGRpY3RpZCA9IGFkbGVyMzIoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTtcbiAgICBpZiAoZGljdGlkICE9PSBzdGF0ZS5jaGVjaykge1xuICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjtcbiAgICB9XG4gIH1cbiAgLyogY29weSBkaWN0aW9uYXJ5IHRvIHdpbmRvdyB1c2luZyB1cGRhdGV3aW5kb3coKSwgd2hpY2ggd2lsbCBhbWVuZCB0aGVcbiAgIGV4aXN0aW5nIGRpY3Rpb25hcnkgaWYgYXBwcm9wcmlhdGUgKi9cbiAgcmV0ID0gdXBkYXRld2luZG93KHN0cm0sIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIGRpY3RMZW5ndGgpO1xuICBpZiAocmV0KSB7XG4gICAgc3RhdGUubW9kZSA9IE1FTTtcbiAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gIH1cbiAgc3RhdGUuaGF2ZWRpY3QgPSAxO1xuICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGRpY3Rpb25hcnkgc2V0XFxuXCIpKTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmV4cG9ydHMuaW5mbGF0ZVJlc2V0ID0gaW5mbGF0ZVJlc2V0O1xuZXhwb3J0cy5pbmZsYXRlUmVzZXQyID0gaW5mbGF0ZVJlc2V0MjtcbmV4cG9ydHMuaW5mbGF0ZVJlc2V0S2VlcCA9IGluZmxhdGVSZXNldEtlZXA7XG5leHBvcnRzLmluZmxhdGVJbml0ID0gaW5mbGF0ZUluaXQ7XG5leHBvcnRzLmluZmxhdGVJbml0MiA9IGluZmxhdGVJbml0MjtcbmV4cG9ydHMuaW5mbGF0ZSA9IGluZmxhdGU7XG5leHBvcnRzLmluZmxhdGVFbmQgPSBpbmZsYXRlRW5kO1xuZXhwb3J0cy5pbmZsYXRlR2V0SGVhZGVyID0gaW5mbGF0ZUdldEhlYWRlcjtcbmV4cG9ydHMuaW5mbGF0ZVNldERpY3Rpb25hcnkgPSBpbmZsYXRlU2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuaW5mbGF0ZUluZm8gPSAncGFrbyBpbmZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSc7XG5cbi8qIE5vdCBpbXBsZW1lbnRlZFxuZXhwb3J0cy5pbmZsYXRlQ29weSA9IGluZmxhdGVDb3B5O1xuZXhwb3J0cy5pbmZsYXRlR2V0RGljdGlvbmFyeSA9IGluZmxhdGVHZXREaWN0aW9uYXJ5O1xuZXhwb3J0cy5pbmZsYXRlTWFyayA9IGluZmxhdGVNYXJrO1xuZXhwb3J0cy5pbmZsYXRlUHJpbWUgPSBpbmZsYXRlUHJpbWU7XG5leHBvcnRzLmluZmxhdGVTeW5jID0gaW5mbGF0ZVN5bmM7XG5leHBvcnRzLmluZmxhdGVTeW5jUG9pbnQgPSBpbmZsYXRlU3luY1BvaW50O1xuZXhwb3J0cy5pbmZsYXRlVW5kZXJtaW5lID0gaW5mbGF0ZVVuZGVybWluZTtcbiovXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/pako/lib/zlib/inflate.js\n");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/inftrees.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/inftrees.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(" // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils = __webpack_require__(/*! ../utils/common */ \"./node_modules/pako/lib/utils/common.js\");\n\nvar MAXBITS = 15;\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592; //var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\nvar lbase = [\n/* Length codes 257..285 base */\n3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];\nvar lext = [\n/* Length codes 257..285 extra */\n16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78];\nvar dbase = [\n/* Distance codes 0..29 base */\n1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0];\nvar dext = [\n/* Distance codes 0..29 extra */\n16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];\n\nmodule.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {\n  var bits = opts.bits; //here = opts.here; /* table entry for duplication */\n\n  var len = 0;\n  /* a code's length in bits */\n\n  var sym = 0;\n  /* index of code symbols */\n\n  var min = 0,\n      max = 0;\n  /* minimum and maximum code lengths */\n\n  var root = 0;\n  /* number of index bits for root table */\n\n  var curr = 0;\n  /* number of index bits for current table */\n\n  var drop = 0;\n  /* code bits to drop for sub-table */\n\n  var left = 0;\n  /* number of prefix codes available */\n\n  var used = 0;\n  /* code entries in table used */\n\n  var huff = 0;\n  /* Huffman code */\n\n  var incr;\n  /* for incrementing code, index */\n\n  var fill;\n  /* index for replicating entries */\n\n  var low;\n  /* low bits for current root entry */\n\n  var mask;\n  /* mask for low root bits */\n\n  var next;\n  /* next available space in table */\n\n  var base = null;\n  /* base value table to use */\n\n  var base_index = 0; //  var shoextra;    /* extra bits table to use */\n\n  var end;\n  /* use base and extra for symbol > end */\n\n  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */\n\n  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */\n\n  var extra = null;\n  var extra_index = 0;\n  var here_bits, here_op, here_val;\n  /*\n   Process a set of code lengths to create a canonical Huffman code.  The\n   code lengths are lens[0..codes-1].  Each length corresponds to the\n   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n   symbols by length from short to long, and retaining the symbol order\n   for codes with equal lengths.  Then the code starts with all zero bits\n   for the first code of the shortest length, and the codes are integer\n   increments for the same length, and zeros are appended as the length\n   increases.  For the deflate format, these bits are stored backwards\n   from their more natural integer increment ordering, and so when the\n   decoding tables are built in the large loop below, the integer codes\n   are incremented backwards.\n    This routine assumes, but does not check, that all of the entries in\n   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n   1..MAXBITS is interpreted as that code length.  zero means that that\n   symbol does not occur in this code.\n    The codes are sorted by computing a count of codes for each length,\n   creating from that a table of starting indices for each length in the\n   sorted table, and then entering the symbols in order in the sorted\n   table.  The sorted table is work[], with that space being provided by\n   the caller.\n    The length counts are used for other purposes as well, i.e. finding\n   the minimum and maximum length codes, determining if there are any\n   codes at all, checking for a valid set of lengths, and looking ahead\n   at length counts to determine sub-table sizes when building the\n   decoding tables.\n   */\n\n  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n\n  for (len = 0; len <= MAXBITS; len++) {\n    count[len] = 0;\n  }\n\n  for (sym = 0; sym < codes; sym++) {\n    count[lens[lens_index + sym]]++;\n  }\n  /* bound code lengths, force root to be within code lengths */\n\n\n  root = bits;\n\n  for (max = MAXBITS; max >= 1; max--) {\n    if (count[max] !== 0) {\n      break;\n    }\n  }\n\n  if (root > max) {\n    root = max;\n  }\n\n  if (max === 0) {\n    /* no symbols to code at all */\n    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n    table[table_index++] = 1 << 24 | 64 << 16 | 0; //table.op[opts.table_index] = 64;\n    //table.bits[opts.table_index] = 1;\n    //table.val[opts.table_index++] = 0;\n\n    table[table_index++] = 1 << 24 | 64 << 16 | 0;\n    opts.bits = 1;\n    return 0;\n    /* no symbols, but wait for decoding to report error */\n  }\n\n  for (min = 1; min < max; min++) {\n    if (count[min] !== 0) {\n      break;\n    }\n  }\n\n  if (root < min) {\n    root = min;\n  }\n  /* check for an over-subscribed or incomplete set of lengths */\n\n\n  left = 1;\n\n  for (len = 1; len <= MAXBITS; len++) {\n    left <<= 1;\n    left -= count[len];\n\n    if (left < 0) {\n      return -1;\n    }\n    /* over-subscribed */\n\n  }\n\n  if (left > 0 && (type === CODES || max !== 1)) {\n    return -1;\n    /* incomplete set */\n  }\n  /* generate offsets into symbol table for each length for sorting */\n\n\n  offs[1] = 0;\n\n  for (len = 1; len < MAXBITS; len++) {\n    offs[len + 1] = offs[len] + count[len];\n  }\n  /* sort symbols by length, by symbol order within each length */\n\n\n  for (sym = 0; sym < codes; sym++) {\n    if (lens[lens_index + sym] !== 0) {\n      work[offs[lens[lens_index + sym]]++] = sym;\n    }\n  }\n  /*\n   Create and fill in decoding tables.  In this loop, the table being\n   filled is at next and has curr index bits.  The code being used is huff\n   with length len.  That code is converted to an index by dropping drop\n   bits off of the bottom.  For codes where len is less than drop + curr,\n   those top drop + curr - len bits are incremented through all values to\n   fill the table with replicated entries.\n    root is the number of index bits for the root table.  When len exceeds\n   root, sub-tables are created pointed to by the root entry with an index\n   of the low root bits of huff.  This is saved in low to check for when a\n   new sub-table should be started.  drop is zero when the root table is\n   being filled, and drop is root when sub-tables are being filled.\n    When a new sub-table is needed, it is necessary to look ahead in the\n   code lengths to determine what size sub-table is needed.  The length\n   counts are used for this, and so count[] is decremented as codes are\n   entered in the tables.\n    used keeps track of how many table entries have been allocated from the\n   provided *table space.  It is checked for LENS and DIST tables against\n   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n   the initial root table size constants.  See the comments in inftrees.h\n   for more information.\n    sym increments through all symbols, and the loop terminates when\n   all codes of length max, i.e. all codes, have been processed.  This\n   routine permits incomplete codes, so another loop after this one fills\n   in the rest of the decoding tables with invalid code markers.\n   */\n\n  /* set up for code type */\n  // poor man optimization - use if-else instead of switch,\n  // to avoid deopts in old v8\n\n\n  if (type === CODES) {\n    base = extra = work;\n    /* dummy value--not used */\n\n    end = 19;\n  } else if (type === LENS) {\n    base = lbase;\n    base_index -= 257;\n    extra = lext;\n    extra_index -= 257;\n    end = 256;\n  } else {\n    /* DISTS */\n    base = dbase;\n    extra = dext;\n    end = -1;\n  }\n  /* initialize opts for loop */\n\n\n  huff = 0;\n  /* starting code */\n\n  sym = 0;\n  /* starting code symbol */\n\n  len = min;\n  /* starting code length */\n\n  next = table_index;\n  /* current table to fill in */\n\n  curr = root;\n  /* current table index bits */\n\n  drop = 0;\n  /* current bits to drop from code for index */\n\n  low = -1;\n  /* trigger new sub-table when len > root */\n\n  used = 1 << root;\n  /* use root table entries */\n\n  mask = used - 1;\n  /* mask for comparing low */\n\n  /* check available table space */\n\n  if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {\n    return 1;\n  }\n  /* process all codes and make table entries */\n\n\n  for (;;) {\n    /* create table entry */\n    here_bits = len - drop;\n\n    if (work[sym] < end) {\n      here_op = 0;\n      here_val = work[sym];\n    } else if (work[sym] > end) {\n      here_op = extra[extra_index + work[sym]];\n      here_val = base[base_index + work[sym]];\n    } else {\n      here_op = 32 + 64;\n      /* end of block */\n\n      here_val = 0;\n    }\n    /* replicate for those indices with low len bits equal to huff */\n\n\n    incr = 1 << len - drop;\n    fill = 1 << curr;\n    min = fill;\n    /* save offset to next table */\n\n    do {\n      fill -= incr;\n      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;\n    } while (fill !== 0);\n    /* backwards increment the len-bit code huff */\n\n\n    incr = 1 << len - 1;\n\n    while (huff & incr) {\n      incr >>= 1;\n    }\n\n    if (incr !== 0) {\n      huff &= incr - 1;\n      huff += incr;\n    } else {\n      huff = 0;\n    }\n    /* go to next symbol, update count, len */\n\n\n    sym++;\n\n    if (--count[len] === 0) {\n      if (len === max) {\n        break;\n      }\n\n      len = lens[lens_index + work[sym]];\n    }\n    /* create new sub-table if needed */\n\n\n    if (len > root && (huff & mask) !== low) {\n      /* if first time, transition to sub-tables */\n      if (drop === 0) {\n        drop = root;\n      }\n      /* increment past last table */\n\n\n      next += min;\n      /* here min is 1 << curr */\n\n      /* determine length of next table */\n\n      curr = len - drop;\n      left = 1 << curr;\n\n      while (curr + drop < max) {\n        left -= count[curr + drop];\n\n        if (left <= 0) {\n          break;\n        }\n\n        curr++;\n        left <<= 1;\n      }\n      /* check for enough space */\n\n\n      used += 1 << curr;\n\n      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {\n        return 1;\n      }\n      /* point entry in root table to sub-table */\n\n\n      low = huff & mask;\n      /*table.op[low] = curr;\n      table.bits[low] = root;\n      table.val[low] = next - opts.table_index;*/\n\n      table[low] = root << 24 | curr << 16 | next - table_index | 0;\n    }\n  }\n  /* fill in remaining table entry if code is incomplete (guaranteed to have\n   at most one remaining entry, since if the code is incomplete, the\n   maximum code length that was allowed to get this far is one bit) */\n\n\n  if (huff !== 0) {\n    //table.op[next + huff] = 64;            /* invalid code marker */\n    //table.bits[next + huff] = len - drop;\n    //table.val[next + huff] = 0;\n    table[next + huff] = len - drop << 24 | 64 << 16 | 0;\n  }\n  /* set return parameters */\n  //opts.table_index += used;\n\n\n  opts.bits = root;\n  return 0;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZ0cmVlcy5qcz82ODUzIl0sIm5hbWVzIjpbInV0aWxzIiwiTUFYQklUUyIsIkVOT1VHSF9MRU5TIiwiRU5PVUdIX0RJU1RTIiwiQ09ERVMiLCJMRU5TIiwiRElTVFMiLCJsYmFzZSIsImxleHQiLCJkYmFzZSIsImRleHQiLCJtb2R1bGUiLCJleHBvcnRzIiwiaW5mbGF0ZV90YWJsZSIsInR5cGUiLCJsZW5zIiwibGVuc19pbmRleCIsImNvZGVzIiwidGFibGUiLCJ0YWJsZV9pbmRleCIsIndvcmsiLCJvcHRzIiwiYml0cyIsImxlbiIsInN5bSIsIm1pbiIsIm1heCIsInJvb3QiLCJjdXJyIiwiZHJvcCIsImxlZnQiLCJ1c2VkIiwiaHVmZiIsImluY3IiLCJmaWxsIiwibG93IiwibWFzayIsIm5leHQiLCJiYXNlIiwiYmFzZV9pbmRleCIsImVuZCIsImNvdW50IiwiQnVmMTYiLCJvZmZzIiwiZXh0cmEiLCJleHRyYV9pbmRleCIsImhlcmVfYml0cyIsImhlcmVfb3AiLCJoZXJlX3ZhbCJdLCJtYXBwaW5ncyI6IkNBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUlBLEtBQUssR0FBRyxtQkFBTyxDQUFDLGdFQUFELENBQW5COztBQUVBLElBQUlDLE9BQU8sR0FBRyxFQUFkO0FBQ0EsSUFBSUMsV0FBVyxHQUFHLEdBQWxCO0FBQ0EsSUFBSUMsWUFBWSxHQUFHLEdBQW5CLEMsQ0FDQTs7QUFFQSxJQUFJQyxLQUFLLEdBQUcsQ0FBWjtBQUNBLElBQUlDLElBQUksR0FBRyxDQUFYO0FBQ0EsSUFBSUMsS0FBSyxHQUFHLENBQVo7QUFFQSxJQUFJQyxLQUFLLEdBQUc7QUFBRTtBQUNaLENBRFUsRUFDUCxDQURPLEVBQ0osQ0FESSxFQUNELENBREMsRUFDRSxDQURG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R0FBbUMsQ0FBeEQ7QUFDRDtBQUVEO0FBQ0E7OztBQUNBUixNQUFJLENBQUNDLElBQUwsR0FBWUssSUFBWjtBQUNBLFNBQU8sQ0FBUDtBQUNELENBaFNEIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mdHJlZXMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cbnZhciBNQVhCSVRTID0gMTU7XG52YXIgRU5PVUdIX0xFTlMgPSA4NTI7XG52YXIgRU5PVUdIX0RJU1RTID0gNTkyO1xuLy92YXIgRU5PVUdIID0gKEVOT1VHSF9MRU5TK0VOT1VHSF9ESVNUUyk7XG5cbnZhciBDT0RFUyA9IDA7XG52YXIgTEVOUyA9IDE7XG52YXIgRElTVFMgPSAyO1xuXG52YXIgbGJhc2UgPSBbIC8qIExlbmd0aCBjb2RlcyAyNTcuLjI4NSBiYXNlICovXG4gIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTMsIDE1LCAxNywgMTksIDIzLCAyNywgMzEsXG4gIDM1LCA0MywgNTEsIDU5LCA2NywgODMsIDk5LCAxMTUsIDEzMSwgMTYzLCAxOTUsIDIyNywgMjU4LCAwLCAwXG5dO1xuXG52YXIgbGV4dCA9IFsgLyogTGVuZ3RoIGNvZGVzIDI1Ny4uMjg1IGV4dHJhICovXG4gIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxNywgMTcsIDE4LCAxOCwgMTgsIDE4LFxuICAxOSwgMTksIDE5LCAxOSwgMjAsIDIwLCAyMCwgMjAsIDIxLCAyMSwgMjEsIDIxLCAxNiwgNzIsIDc4XG5dO1xuXG52YXIgZGJhc2UgPSBbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGJhc2UgKi9cbiAgMSwgMiwgMywgNCwgNSwgNywgOSwgMTMsIDE3LCAyNSwgMzMsIDQ5LCA2NSwgOTcsIDEyOSwgMTkzLFxuICAyNTcsIDM4NSwgNTEzLCA3NjksIDEwMjUsIDE1MzcsIDIwNDksIDMwNzMsIDQwOTcsIDYxNDUsXG4gIDgxOTMsIDEyMjg5LCAxNjM4NSwgMjQ1NzcsIDAsIDBcbl07XG5cbnZhciBkZXh0ID0gWyAvKiBEaXN0YW5jZSBjb2RlcyAwLi4yOSBleHRyYSAqL1xuICAxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxOCwgMTgsIDE5LCAxOSwgMjAsIDIwLCAyMSwgMjEsIDIyLCAyMixcbiAgMjMsIDIzLCAyNCwgMjQsIDI1LCAyNSwgMjYsIDI2LCAyNywgMjcsXG4gIDI4LCAyOCwgMjksIDI5LCA2NCwgNjRcbl07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5mbGF0ZV90YWJsZSh0eXBlLCBsZW5zLCBsZW5zX2luZGV4LCBjb2RlcywgdGFibGUsIHRhYmxlX2luZGV4LCB3b3JrLCBvcHRzKVxue1xuICB2YXIgYml0cyA9IG9wdHMuYml0cztcbiAgICAgIC8vaGVyZSA9IG9wdHMuaGVyZTsgLyogdGFibGUgZW50cnkgZm9yIGR1cGxpY2F0aW9uICovXG5cbiAgdmFyIGxlbiA9IDA7ICAgICAgICAgICAgICAgLyogYSBjb2RlJ3MgbGVuZ3RoIGluIGJpdHMgKi9cbiAgdmFyIHN5bSA9IDA7ICAgICAgICAgICAgICAgLyogaW5kZXggb2YgY29kZSBzeW1ib2xzICovXG4gIHZhciBtaW4gPSAwLCBtYXggPSAwOyAgICAgICAgICAvKiBtaW5pbXVtIGFuZCBtYXhpbXVtIGNvZGUgbGVuZ3RocyAqL1xuICB2YXIgcm9vdCA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3Igcm9vdCB0YWJsZSAqL1xuICB2YXIgY3VyciA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3IgY3VycmVudCB0YWJsZSAqL1xuICB2YXIgZHJvcCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGJpdHMgdG8gZHJvcCBmb3Igc3ViLXRhYmxlICovXG4gIHZhciBsZWZ0ID0gMDsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHByZWZpeCBjb2RlcyBhdmFpbGFibGUgKi9cbiAgdmFyIHVzZWQgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBlbnRyaWVzIGluIHRhYmxlIHVzZWQgKi9cbiAgdmFyIGh1ZmYgPSAwOyAgICAgICAgICAgICAgLyogSHVmZm1hbiBjb2RlICovXG4gIHZhciBpbmNyOyAgICAgICAgICAgICAgLyogZm9yIGluY3JlbWVudGluZyBjb2RlLCBpbmRleCAqL1xuICB2YXIgZmlsbDsgICAgICAgICAgICAgIC8qIGluZGV4IGZvciByZXBsaWNhdGluZyBlbnRyaWVzICovXG4gIHZhciBsb3c7ICAgICAgICAgICAgICAgLyogbG93IGJpdHMgZm9yIGN1cnJlbnQgcm9vdCBlbnRyeSAqL1xuICB2YXIgbWFzazsgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGxvdyByb290IGJpdHMgKi9cbiAgdmFyIG5leHQ7ICAgICAgICAgICAgIC8qIG5leHQgYXZhaWxhYmxlIHNwYWNlIGluIHRhYmxlICovXG4gIHZhciBiYXNlID0gbnVsbDsgICAgIC8qIGJhc2UgdmFsdWUgdGFibGUgdG8gdXNlICovXG4gIHZhciBiYXNlX2luZGV4ID0gMDtcbi8vICB2YXIgc2hvZXh0cmE7ICAgIC8qIGV4dHJhIGJpdHMgdGFibGUgdG8gdXNlICovXG4gIHZhciBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB1c2UgYmFzZSBhbmQgZXh0cmEgZm9yIHN5bWJvbCA+IGVuZCAqL1xuICB2YXIgY291bnQgPSBuZXcgdXRpbHMuQnVmMTYoTUFYQklUUyArIDEpOyAvL1tNQVhCSVRTKzFdOyAgICAvKiBudW1iZXIgb2YgY29kZXMgb2YgZWFjaCBsZW5ndGggKi9cbiAgdmFyIG9mZnMgPSBuZXcgdXRpbHMuQnVmMTYoTUFYQklUUyArIDEpOyAvL1tNQVhCSVRTKzFdOyAgICAgLyogb2Zmc2V0cyBpbiB0YWJsZSBmb3IgZWFjaCBsZW5ndGggKi9cbiAgdmFyIGV4dHJhID0gbnVsbDtcbiAgdmFyIGV4dHJhX2luZGV4ID0gMDtcblxuICB2YXIgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDtcblxuICAvKlxuICAgUHJvY2VzcyBhIHNldCBvZiBjb2RlIGxlbmd0aHMgdG8gY3JlYXRlIGEgY2Fub25pY2FsIEh1ZmZtYW4gY29kZS4gIFRoZVxuICAgY29kZSBsZW5ndGhzIGFyZSBsZW5zWzAuLmNvZGVzLTFdLiAgRWFjaCBsZW5ndGggY29ycmVzcG9uZHMgdG8gdGhlXG4gICBzeW1ib2xzIDAuLmNvZGVzLTEuICBUaGUgSHVmZm1hbiBjb2RlIGlzIGdlbmVyYXRlZCBieSBmaXJzdCBzb3J0aW5nIHRoZVxuICAgc3ltYm9scyBieSBsZW5ndGggZnJvbSBzaG9ydCB0byBsb25nLCBhbmQgcmV0YWluaW5nIHRoZSBzeW1ib2wgb3JkZXJcbiAgIGZvciBjb2RlcyB3aXRoIGVxdWFsIGxlbmd0aHMuICBUaGVuIHRoZSBjb2RlIHN0YXJ0cyB3aXRoIGFsbCB6ZXJvIGJpdHNcbiAgIGZvciB0aGUgZmlyc3QgY29kZSBvZiB0aGUgc2hvcnRlc3QgbGVuZ3RoLCBhbmQgdGhlIGNvZGVzIGFyZSBpbnRlZ2VyXG4gICBpbmNyZW1lbnRzIGZvciB0aGUgc2FtZSBsZW5ndGgsIGFuZCB6ZXJvcyBhcmUgYXBwZW5kZWQgYXMgdGhlIGxlbmd0aFxuICAgaW5jcmVhc2VzLiAgRm9yIHRoZSBkZWZsYXRlIGZvcm1hdCwgdGhlc2UgYml0cyBhcmUgc3RvcmVkIGJhY2t3YXJkc1xuICAgZnJvbSB0aGVpciBtb3JlIG5hdHVyYWwgaW50ZWdlciBpbmNyZW1lbnQgb3JkZXJpbmcsIGFuZCBzbyB3aGVuIHRoZVxuICAgZGVjb2RpbmcgdGFibGVzIGFyZSBidWlsdCBpbiB0aGUgbGFyZ2UgbG9vcCBiZWxvdywgdGhlIGludGVnZXIgY29kZXNcbiAgIGFyZSBpbmNyZW1lbnRlZCBiYWNrd2FyZHMuXG5cbiAgIFRoaXMgcm91dGluZSBhc3N1bWVzLCBidXQgZG9lcyBub3QgY2hlY2ssIHRoYXQgYWxsIG9mIHRoZSBlbnRyaWVzIGluXG4gICBsZW5zW10gYXJlIGluIHRoZSByYW5nZSAwLi5NQVhCSVRTLiAgVGhlIGNhbGxlciBtdXN0IGFzc3VyZSB0aGlzLlxuICAgMS4uTUFYQklUUyBpcyBpbnRlcnByZXRlZCBhcyB0aGF0IGNvZGUgbGVuZ3RoLiAgemVybyBtZWFucyB0aGF0IHRoYXRcbiAgIHN5bWJvbCBkb2VzIG5vdCBvY2N1ciBpbiB0aGlzIGNvZGUuXG5cbiAgIFRoZSBjb2RlcyBhcmUgc29ydGVkIGJ5IGNvbXB1dGluZyBhIGNvdW50IG9mIGNvZGVzIGZvciBlYWNoIGxlbmd0aCxcbiAgIGNyZWF0aW5nIGZyb20gdGhhdCBhIHRhYmxlIG9mIHN0YXJ0aW5nIGluZGljZXMgZm9yIGVhY2ggbGVuZ3RoIGluIHRoZVxuICAgc29ydGVkIHRhYmxlLCBhbmQgdGhlbiBlbnRlcmluZyB0aGUgc3ltYm9scyBpbiBvcmRlciBpbiB0aGUgc29ydGVkXG4gICB0YWJsZS4gIFRoZSBzb3J0ZWQgdGFibGUgaXMgd29ya1tdLCB3aXRoIHRoYXQgc3BhY2UgYmVpbmcgcHJvdmlkZWQgYnlcbiAgIHRoZSBjYWxsZXIuXG5cbiAgIFRoZSBsZW5ndGggY291bnRzIGFyZSB1c2VkIGZvciBvdGhlciBwdXJwb3NlcyBhcyB3ZWxsLCBpLmUuIGZpbmRpbmdcbiAgIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGxlbmd0aCBjb2RlcywgZGV0ZXJtaW5pbmcgaWYgdGhlcmUgYXJlIGFueVxuICAgY29kZXMgYXQgYWxsLCBjaGVja2luZyBmb3IgYSB2YWxpZCBzZXQgb2YgbGVuZ3RocywgYW5kIGxvb2tpbmcgYWhlYWRcbiAgIGF0IGxlbmd0aCBjb3VudHMgdG8gZGV0ZXJtaW5lIHN1Yi10YWJsZSBzaXplcyB3aGVuIGJ1aWxkaW5nIHRoZVxuICAgZGVjb2RpbmcgdGFibGVzLlxuICAgKi9cblxuICAvKiBhY2N1bXVsYXRlIGxlbmd0aHMgZm9yIGNvZGVzIChhc3N1bWVzIGxlbnNbXSBhbGwgaW4gMC4uTUFYQklUUykgKi9cbiAgZm9yIChsZW4gPSAwOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHtcbiAgICBjb3VudFtsZW5dID0gMDtcbiAgfVxuICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykge1xuICAgIGNvdW50W2xlbnNbbGVuc19pbmRleCArIHN5bV1dKys7XG4gIH1cblxuICAvKiBib3VuZCBjb2RlIGxlbmd0aHMsIGZvcmNlIHJvb3QgdG8gYmUgd2l0aGluIGNvZGUgbGVuZ3RocyAqL1xuICByb290ID0gYml0cztcbiAgZm9yIChtYXggPSBNQVhCSVRTOyBtYXggPj0gMTsgbWF4LS0pIHtcbiAgICBpZiAoY291bnRbbWF4XSAhPT0gMCkgeyBicmVhazsgfVxuICB9XG4gIGlmIChyb290ID4gbWF4KSB7XG4gICAgcm9vdCA9IG1heDtcbiAgfVxuICBpZiAobWF4ID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgLyogbm8gc3ltYm9scyB0byBjb2RlIGF0IGFsbCAqL1xuICAgIC8vdGFibGUub3Bbb3B0cy50YWJsZV9pbmRleF0gPSA2NDsgIC8vaGVyZS5vcCA9ICh2YXIgY2hhcik2NDsgICAgLyogaW52YWxpZCBjb2RlIG1hcmtlciAqL1xuICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7ICAgLy9oZXJlLmJpdHMgPSAodmFyIGNoYXIpMTtcbiAgICAvL3RhYmxlLnZhbFtvcHRzLnRhYmxlX2luZGV4KytdID0gMDsgICAvL2hlcmUudmFsID0gKHZhciBzaG9ydCkwO1xuICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gKDEgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG5cblxuICAgIC8vdGFibGUub3Bbb3B0cy50YWJsZV9pbmRleF0gPSA2NDtcbiAgICAvL3RhYmxlLmJpdHNbb3B0cy50YWJsZV9pbmRleF0gPSAxO1xuICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwO1xuICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gKDEgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG5cbiAgICBvcHRzLmJpdHMgPSAxO1xuICAgIHJldHVybiAwOyAgICAgLyogbm8gc3ltYm9scywgYnV0IHdhaXQgZm9yIGRlY29kaW5nIHRvIHJlcG9ydCBlcnJvciAqL1xuICB9XG4gIGZvciAobWluID0gMTsgbWluIDwgbWF4OyBtaW4rKykge1xuICAgIGlmIChjb3VudFttaW5dICE9PSAwKSB7IGJyZWFrOyB9XG4gIH1cbiAgaWYgKHJvb3QgPCBtaW4pIHtcbiAgICByb290ID0gbWluO1xuICB9XG5cbiAgLyogY2hlY2sgZm9yIGFuIG92ZXItc3Vic2NyaWJlZCBvciBpbmNvbXBsZXRlIHNldCBvZiBsZW5ndGhzICovXG4gIGxlZnQgPSAxO1xuICBmb3IgKGxlbiA9IDE7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykge1xuICAgIGxlZnQgPDw9IDE7XG4gICAgbGVmdCAtPSBjb3VudFtsZW5dO1xuICAgIGlmIChsZWZ0IDwgMCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gICAgICAgIC8qIG92ZXItc3Vic2NyaWJlZCAqL1xuICB9XG4gIGlmIChsZWZ0ID4gMCAmJiAodHlwZSA9PT0gQ09ERVMgfHwgbWF4ICE9PSAxKSkge1xuICAgIHJldHVybiAtMTsgICAgICAgICAgICAgICAgICAgICAgLyogaW5jb21wbGV0ZSBzZXQgKi9cbiAgfVxuXG4gIC8qIGdlbmVyYXRlIG9mZnNldHMgaW50byBzeW1ib2wgdGFibGUgZm9yIGVhY2ggbGVuZ3RoIGZvciBzb3J0aW5nICovXG4gIG9mZnNbMV0gPSAwO1xuICBmb3IgKGxlbiA9IDE7IGxlbiA8IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgb2Zmc1tsZW4gKyAxXSA9IG9mZnNbbGVuXSArIGNvdW50W2xlbl07XG4gIH1cblxuICAvKiBzb3J0IHN5bWJvbHMgYnkgbGVuZ3RoLCBieSBzeW1ib2wgb3JkZXIgd2l0aGluIGVhY2ggbGVuZ3RoICovXG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgaWYgKGxlbnNbbGVuc19pbmRleCArIHN5bV0gIT09IDApIHtcbiAgICAgIHdvcmtbb2Zmc1tsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrXSA9IHN5bTtcbiAgICB9XG4gIH1cblxuICAvKlxuICAgQ3JlYXRlIGFuZCBmaWxsIGluIGRlY29kaW5nIHRhYmxlcy4gIEluIHRoaXMgbG9vcCwgdGhlIHRhYmxlIGJlaW5nXG4gICBmaWxsZWQgaXMgYXQgbmV4dCBhbmQgaGFzIGN1cnIgaW5kZXggYml0cy4gIFRoZSBjb2RlIGJlaW5nIHVzZWQgaXMgaHVmZlxuICAgd2l0aCBsZW5ndGggbGVuLiAgVGhhdCBjb2RlIGlzIGNvbnZlcnRlZCB0byBhbiBpbmRleCBieSBkcm9wcGluZyBkcm9wXG4gICBiaXRzIG9mZiBvZiB0aGUgYm90dG9tLiAgRm9yIGNvZGVzIHdoZXJlIGxlbiBpcyBsZXNzIHRoYW4gZHJvcCArIGN1cnIsXG4gICB0aG9zZSB0b3AgZHJvcCArIGN1cnIgLSBsZW4gYml0cyBhcmUgaW5jcmVtZW50ZWQgdGhyb3VnaCBhbGwgdmFsdWVzIHRvXG4gICBmaWxsIHRoZSB0YWJsZSB3aXRoIHJlcGxpY2F0ZWQgZW50cmllcy5cblxuICAgcm9vdCBpcyB0aGUgbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIHRoZSByb290IHRhYmxlLiAgV2hlbiBsZW4gZXhjZWVkc1xuICAgcm9vdCwgc3ViLXRhYmxlcyBhcmUgY3JlYXRlZCBwb2ludGVkIHRvIGJ5IHRoZSByb290IGVudHJ5IHdpdGggYW4gaW5kZXhcbiAgIG9mIHRoZSBsb3cgcm9vdCBiaXRzIG9mIGh1ZmYuICBUaGlzIGlzIHNhdmVkIGluIGxvdyB0byBjaGVjayBmb3Igd2hlbiBhXG4gICBuZXcgc3ViLXRhYmxlIHNob3VsZCBiZSBzdGFydGVkLiAgZHJvcCBpcyB6ZXJvIHdoZW4gdGhlIHJvb3QgdGFibGUgaXNcbiAgIGJlaW5nIGZpbGxlZCwgYW5kIGRyb3AgaXMgcm9vdCB3aGVuIHN1Yi10YWJsZXMgYXJlIGJlaW5nIGZpbGxlZC5cblxuICAgV2hlbiBhIG5ldyBzdWItdGFibGUgaXMgbmVlZGVkLCBpdCBpcyBuZWNlc3NhcnkgdG8gbG9vayBhaGVhZCBpbiB0aGVcbiAgIGNvZGUgbGVuZ3RocyB0byBkZXRlcm1pbmUgd2hhdCBzaXplIHN1Yi10YWJsZSBpcyBuZWVkZWQuICBUaGUgbGVuZ3RoXG4gICBjb3VudHMgYXJlIHVzZWQgZm9yIHRoaXMsIGFuZCBzbyBjb3VudFtdIGlzIGRlY3JlbWVudGVkIGFzIGNvZGVzIGFyZVxuICAgZW50ZXJlZCBpbiB0aGUgdGFibGVzLlxuXG4gICB1c2VkIGtlZXBzIHRyYWNrIG9mIGhvdyBtYW55IHRhYmxlIGVudHJpZXMgaGF2ZSBiZWVuIGFsbG9jYXRlZCBmcm9tIHRoZVxuICAgcHJvdmlkZWQgKnRhYmxlIHNwYWNlLiAgSXQgaXMgY2hlY2tlZCBmb3IgTEVOUyBhbmQgRElTVCB0YWJsZXMgYWdhaW5zdFxuICAgdGhlIGNvbnN0YW50cyBFTk9VR0hfTEVOUyBhbmQgRU5PVUdIX0RJU1RTIHRvIGd1YXJkIGFnYWluc3QgY2hhbmdlcyBpblxuICAgdGhlIGluaXRpYWwgcm9vdCB0YWJsZSBzaXplIGNvbnN0YW50cy4gIFNlZSB0aGUgY29tbWVudHMgaW4gaW5mdHJlZXMuaFxuICAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cbiAgIHN5bSBpbmNyZW1lbnRzIHRocm91Z2ggYWxsIHN5bWJvbHMsIGFuZCB0aGUgbG9vcCB0ZXJtaW5hdGVzIHdoZW5cbiAgIGFsbCBjb2RlcyBvZiBsZW5ndGggbWF4LCBpLmUuIGFsbCBjb2RlcywgaGF2ZSBiZWVuIHByb2Nlc3NlZC4gIFRoaXNcbiAgIHJvdXRpbmUgcGVybWl0cyBpbmNvbXBsZXRlIGNvZGVzLCBzbyBhbm90aGVyIGxvb3AgYWZ0ZXIgdGhpcyBvbmUgZmlsbHNcbiAgIGluIHRoZSByZXN0IG9mIHRoZSBkZWNvZGluZyB0YWJsZXMgd2l0aCBpbnZhbGlkIGNvZGUgbWFya2Vycy5cbiAgICovXG5cbiAgLyogc2V0IHVwIGZvciBjb2RlIHR5cGUgKi9cbiAgLy8gcG9vciBtYW4gb3B0aW1pemF0aW9uIC0gdXNlIGlmLWVsc2UgaW5zdGVhZCBvZiBzd2l0Y2gsXG4gIC8vIHRvIGF2b2lkIGRlb3B0cyBpbiBvbGQgdjhcbiAgaWYgKHR5cGUgPT09IENPREVTKSB7XG4gICAgYmFzZSA9IGV4dHJhID0gd29yazsgICAgLyogZHVtbXkgdmFsdWUtLW5vdCB1c2VkICovXG4gICAgZW5kID0gMTk7XG5cbiAgfSBlbHNlIGlmICh0eXBlID09PSBMRU5TKSB7XG4gICAgYmFzZSA9IGxiYXNlO1xuICAgIGJhc2VfaW5kZXggLT0gMjU3O1xuICAgIGV4dHJhID0gbGV4dDtcbiAgICBleHRyYV9pbmRleCAtPSAyNTc7XG4gICAgZW5kID0gMjU2O1xuXG4gIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAvKiBESVNUUyAqL1xuICAgIGJhc2UgPSBkYmFzZTtcbiAgICBleHRyYSA9IGRleHQ7XG4gICAgZW5kID0gLTE7XG4gIH1cblxuICAvKiBpbml0aWFsaXplIG9wdHMgZm9yIGxvb3AgKi9cbiAgaHVmZiA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgKi9cbiAgc3ltID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgc3ltYm9sICovXG4gIGxlbiA9IG1pbjsgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlIGxlbmd0aCAqL1xuICBuZXh0ID0gdGFibGVfaW5kZXg7ICAgICAgICAgICAgICAvKiBjdXJyZW50IHRhYmxlIHRvIGZpbGwgaW4gKi9cbiAgY3VyciA9IHJvb3Q7ICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgaW5kZXggYml0cyAqL1xuICBkcm9wID0gMDsgICAgICAgICAgICAgICAgICAgLyogY3VycmVudCBiaXRzIHRvIGRyb3AgZnJvbSBjb2RlIGZvciBpbmRleCAqL1xuICBsb3cgPSAtMTsgICAgICAgICAgICAgICAgICAgLyogdHJpZ2dlciBuZXcgc3ViLXRhYmxlIHdoZW4gbGVuID4gcm9vdCAqL1xuICB1c2VkID0gMSA8PCByb290OyAgICAgICAgICAvKiB1c2Ugcm9vdCB0YWJsZSBlbnRyaWVzICovXG4gIG1hc2sgPSB1c2VkIC0gMTsgICAgICAgICAgICAvKiBtYXNrIGZvciBjb21wYXJpbmcgbG93ICovXG5cbiAgLyogY2hlY2sgYXZhaWxhYmxlIHRhYmxlIHNwYWNlICovXG4gIGlmICgodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMpIHx8XG4gICAgKHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICAvKiBwcm9jZXNzIGFsbCBjb2RlcyBhbmQgbWFrZSB0YWJsZSBlbnRyaWVzICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBjcmVhdGUgdGFibGUgZW50cnkgKi9cbiAgICBoZXJlX2JpdHMgPSBsZW4gLSBkcm9wO1xuICAgIGlmICh3b3JrW3N5bV0gPCBlbmQpIHtcbiAgICAgIGhlcmVfb3AgPSAwO1xuICAgICAgaGVyZV92YWwgPSB3b3JrW3N5bV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHdvcmtbc3ltXSA+IGVuZCkge1xuICAgICAgaGVyZV9vcCA9IGV4dHJhW2V4dHJhX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICAgIGhlcmVfdmFsID0gYmFzZVtiYXNlX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBoZXJlX29wID0gMzIgKyA2NDsgICAgICAgICAvKiBlbmQgb2YgYmxvY2sgKi9cbiAgICAgIGhlcmVfdmFsID0gMDtcbiAgICB9XG5cbiAgICAvKiByZXBsaWNhdGUgZm9yIHRob3NlIGluZGljZXMgd2l0aCBsb3cgbGVuIGJpdHMgZXF1YWwgdG8gaHVmZiAqL1xuICAgIGluY3IgPSAxIDw8IChsZW4gLSBkcm9wKTtcbiAgICBmaWxsID0gMSA8PCBjdXJyO1xuICAgIG1pbiA9IGZpbGw7ICAgICAgICAgICAgICAgICAvKiBzYXZlIG9mZnNldCB0byBuZXh0IHRhYmxlICovXG4gICAgZG8ge1xuICAgICAgZmlsbCAtPSBpbmNyO1xuICAgICAgdGFibGVbbmV4dCArIChodWZmID4+IGRyb3ApICsgZmlsbF0gPSAoaGVyZV9iaXRzIDw8IDI0KSB8IChoZXJlX29wIDw8IDE2KSB8IGhlcmVfdmFsIHwwO1xuICAgIH0gd2hpbGUgKGZpbGwgIT09IDApO1xuXG4gICAgLyogYmFja3dhcmRzIGluY3JlbWVudCB0aGUgbGVuLWJpdCBjb2RlIGh1ZmYgKi9cbiAgICBpbmNyID0gMSA8PCAobGVuIC0gMSk7XG4gICAgd2hpbGUgKGh1ZmYgJiBpbmNyKSB7XG4gICAgICBpbmNyID4+PSAxO1xuICAgIH1cbiAgICBpZiAoaW5jciAhPT0gMCkge1xuICAgICAgaHVmZiAmPSBpbmNyIC0gMTtcbiAgICAgIGh1ZmYgKz0gaW5jcjtcbiAgICB9IGVsc2Uge1xuICAgICAgaHVmZiA9IDA7XG4gICAgfVxuXG4gICAgLyogZ28gdG8gbmV4dCBzeW1ib2wsIHVwZGF0ZSBjb3VudCwgbGVuICovXG4gICAgc3ltKys7XG4gICAgaWYgKC0tY291bnRbbGVuXSA9PT0gMCkge1xuICAgICAgaWYgKGxlbiA9PT0gbWF4KSB7IGJyZWFrOyB9XG4gICAgICBsZW4gPSBsZW5zW2xlbnNfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgIH1cblxuICAgIC8qIGNyZWF0ZSBuZXcgc3ViLXRhYmxlIGlmIG5lZWRlZCAqL1xuICAgIGlmIChsZW4gPiByb290ICYmIChodWZmICYgbWFzaykgIT09IGxvdykge1xuICAgICAgLyogaWYgZmlyc3QgdGltZSwgdHJhbnNpdGlvbiB0byBzdWItdGFibGVzICovXG4gICAgICBpZiAoZHJvcCA9PT0gMCkge1xuICAgICAgICBkcm9wID0gcm9vdDtcbiAgICAgIH1cblxuICAgICAgLyogaW5jcmVtZW50IHBhc3QgbGFzdCB0YWJsZSAqL1xuICAgICAgbmV4dCArPSBtaW47ICAgICAgICAgICAgLyogaGVyZSBtaW4gaXMgMSA8PCBjdXJyICovXG5cbiAgICAgIC8qIGRldGVybWluZSBsZW5ndGggb2YgbmV4dCB0YWJsZSAqL1xuICAgICAgY3VyciA9IGxlbiAtIGRyb3A7XG4gICAgICBsZWZ0ID0gMSA8PCBjdXJyO1xuICAgICAgd2hpbGUgKGN1cnIgKyBkcm9wIDwgbWF4KSB7XG4gICAgICAgIGxlZnQgLT0gY291bnRbY3VyciArIGRyb3BdO1xuICAgICAgICBpZiAobGVmdCA8PSAwKSB7IGJyZWFrOyB9XG4gICAgICAgIGN1cnIrKztcbiAgICAgICAgbGVmdCA8PD0gMTtcbiAgICAgIH1cblxuICAgICAgLyogY2hlY2sgZm9yIGVub3VnaCBzcGFjZSAqL1xuICAgICAgdXNlZCArPSAxIDw8IGN1cnI7XG4gICAgICBpZiAoKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TKSB8fFxuICAgICAgICAodHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIC8qIHBvaW50IGVudHJ5IGluIHJvb3QgdGFibGUgdG8gc3ViLXRhYmxlICovXG4gICAgICBsb3cgPSBodWZmICYgbWFzaztcbiAgICAgIC8qdGFibGUub3BbbG93XSA9IGN1cnI7XG4gICAgICB0YWJsZS5iaXRzW2xvd10gPSByb290O1xuICAgICAgdGFibGUudmFsW2xvd10gPSBuZXh0IC0gb3B0cy50YWJsZV9pbmRleDsqL1xuICAgICAgdGFibGVbbG93XSA9IChyb290IDw8IDI0KSB8IChjdXJyIDw8IDE2KSB8IChuZXh0IC0gdGFibGVfaW5kZXgpIHwwO1xuICAgIH1cbiAgfVxuXG4gIC8qIGZpbGwgaW4gcmVtYWluaW5nIHRhYmxlIGVudHJ5IGlmIGNvZGUgaXMgaW5jb21wbGV0ZSAoZ3VhcmFudGVlZCB0byBoYXZlXG4gICBhdCBtb3N0IG9uZSByZW1haW5pbmcgZW50cnksIHNpbmNlIGlmIHRoZSBjb2RlIGlzIGluY29tcGxldGUsIHRoZVxuICAgbWF4aW11bSBjb2RlIGxlbmd0aCB0aGF0IHdhcyBhbGxvd2VkIHRvIGdldCB0aGlzIGZhciBpcyBvbmUgYml0KSAqL1xuICBpZiAoaHVmZiAhPT0gMCkge1xuICAgIC8vdGFibGUub3BbbmV4dCArIGh1ZmZdID0gNjQ7ICAgICAgICAgICAgLyogaW52YWxpZCBjb2RlIG1hcmtlciAqL1xuICAgIC8vdGFibGUuYml0c1tuZXh0ICsgaHVmZl0gPSBsZW4gLSBkcm9wO1xuICAgIC8vdGFibGUudmFsW25leHQgKyBodWZmXSA9IDA7XG4gICAgdGFibGVbbmV4dCArIGh1ZmZdID0gKChsZW4gLSBkcm9wKSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwwO1xuICB9XG5cbiAgLyogc2V0IHJldHVybiBwYXJhbWV0ZXJzICovXG4gIC8vb3B0cy50YWJsZV9pbmRleCArPSB1c2VkO1xuICBvcHRzLmJpdHMgPSByb290O1xuICByZXR1cm4gMDtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/pako/lib/zlib/inftrees.js\n");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/messages.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/messages.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(" // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n  2: 'need dictionary',\n\n  /* Z_NEED_DICT       2  */\n  1: 'stream end',\n\n  /* Z_STREAM_END      1  */\n  0: '',\n\n  /* Z_OK              0  */\n  '-1': 'file error',\n\n  /* Z_ERRNO         (-1) */\n  '-2': 'stream error',\n\n  /* Z_STREAM_ERROR  (-2) */\n  '-3': 'data error',\n\n  /* Z_DATA_ERROR    (-3) */\n  '-4': 'insufficient memory',\n\n  /* Z_MEM_ERROR     (-4) */\n  '-5': 'buffer error',\n\n  /* Z_BUF_ERROR     (-5) */\n  '-6': 'incompatible version'\n  /* Z_VERSION_ERROR (-6) */\n\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9tZXNzYWdlcy5qcz80ZGM2Il0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJDQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQUEsTUFBTSxDQUFDQyxPQUFQLEdBQWlCO0FBQ2YsS0FBUSxpQkFETzs7QUFDZ0I7QUFDL0IsS0FBUSxZQUZPOztBQUVnQjtBQUMvQixLQUFRLEVBSE87O0FBR2dCO0FBQy9CLFFBQVEsWUFKTzs7QUFJZ0I7QUFDL0IsUUFBUSxjQUxPOztBQUtnQjtBQUMvQixRQUFRLFlBTk87O0FBTWdCO0FBQy9CLFFBQVEscUJBUE87O0FBT2dCO0FBQy9CLFFBQVEsY0FSTzs7QUFRZ0I7QUFDL0IsUUFBUTtBQUF1Qjs7QUFUaEIsQ0FBakIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9tZXNzYWdlcy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgMjogICAgICAnbmVlZCBkaWN0aW9uYXJ5JywgICAgIC8qIFpfTkVFRF9ESUNUICAgICAgIDIgICovXG4gIDE6ICAgICAgJ3N0cmVhbSBlbmQnLCAgICAgICAgICAvKiBaX1NUUkVBTV9FTkQgICAgICAxICAqL1xuICAwOiAgICAgICcnLCAgICAgICAgICAgICAgICAgICAgLyogWl9PSyAgICAgICAgICAgICAgMCAgKi9cbiAgJy0xJzogICAnZmlsZSBlcnJvcicsICAgICAgICAgIC8qIFpfRVJSTk8gICAgICAgICAoLTEpICovXG4gICctMic6ICAgJ3N0cmVhbSBlcnJvcicsICAgICAgICAvKiBaX1NUUkVBTV9FUlJPUiAgKC0yKSAqL1xuICAnLTMnOiAgICdkYXRhIGVycm9yJywgICAgICAgICAgLyogWl9EQVRBX0VSUk9SICAgICgtMykgKi9cbiAgJy00JzogICAnaW5zdWZmaWNpZW50IG1lbW9yeScsIC8qIFpfTUVNX0VSUk9SICAgICAoLTQpICovXG4gICctNSc6ICAgJ2J1ZmZlciBlcnJvcicsICAgICAgICAvKiBaX0JVRl9FUlJPUiAgICAgKC01KSAqL1xuICAnLTYnOiAgICdpbmNvbXBhdGlibGUgdmVyc2lvbicgLyogWl9WRVJTSU9OX0VSUk9SICgtNikgKi9cbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/pako/lib/zlib/messages.js\n");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/trees.js":
/*!*********************************************!*\
  !*** ./node_modules/pako/lib/zlib/trees.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(" // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils = __webpack_require__(/*! ../utils/common */ \"./node_modules/pako/lib/utils/common.js\");\n/* Public constants ==========================================================*/\n\n/* ===========================================================================*/\n//var Z_FILTERED          = 1;\n//var Z_HUFFMAN_ONLY      = 2;\n//var Z_RLE               = 3;\n\n\nvar Z_FIXED = 4; //var Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\n\nvar Z_BINARY = 0;\nvar Z_TEXT = 1; //var Z_ASCII             = 1; // = Z_TEXT\n\nvar Z_UNKNOWN = 2;\n/*============================================================================*/\n\nfunction zero(buf) {\n  var len = buf.length;\n\n  while (--len >= 0) {\n    buf[len] = 0;\n  }\n} // From zutil.h\n\n\nvar STORED_BLOCK = 0;\nvar STATIC_TREES = 1;\nvar DYN_TREES = 2;\n/* The three kinds of block type */\n\nvar MIN_MATCH = 3;\nvar MAX_MATCH = 258;\n/* The minimum and maximum match lengths */\n// From deflate.h\n\n/* ===========================================================================\n * Internal compression state.\n */\n\nvar LENGTH_CODES = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nvar LITERALS = 256;\n/* number of literal bytes 0..255 */\n\nvar L_CODES = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nvar D_CODES = 30;\n/* number of distance codes */\n\nvar BL_CODES = 19;\n/* number of codes used to transfer the bit lengths */\n\nvar HEAP_SIZE = 2 * L_CODES + 1;\n/* maximum heap size */\n\nvar MAX_BITS = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar Buf_size = 16;\n/* size of bit buffer in bi_buf */\n\n/* ===========================================================================\n * Constants\n */\n\nvar MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nvar END_BLOCK = 256;\n/* end of block literal code */\n\nvar REP_3_6 = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nvar REPZ_3_10 = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nvar REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\n\nvar extra_lbits =\n/* extra bits for each length code */\n[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];\nvar extra_dbits =\n/* extra bits for each distance code */\n[0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];\nvar extra_blbits =\n/* extra bits for each bit length code */\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];\nvar bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nvar DIST_CODE_LEN = 512;\n/* see definition of array dist_code below */\n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\n\nvar static_ltree = new Array((L_CODES + 2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nvar static_dtree = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nvar _dist_code = new Array(DIST_CODE_LEN);\n\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nvar _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);\n\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nvar base_length = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nvar base_dist = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n  this.static_tree = static_tree;\n  /* static tree or NULL */\n\n  this.extra_bits = extra_bits;\n  /* extra bits for each code or NULL */\n\n  this.extra_base = extra_base;\n  /* base index for extra_bits */\n\n  this.elems = elems;\n  /* max number of elements in the tree */\n\n  this.max_length = max_length;\n  /* max bit length for the codes */\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n\n  this.has_stree = static_tree && static_tree.length;\n}\n\nvar static_l_desc;\nvar static_d_desc;\nvar static_bl_desc;\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;\n  /* the dynamic tree */\n\n  this.max_code = 0;\n  /* largest code with non zero frequency */\n\n  this.stat_desc = stat_desc;\n  /* the corresponding static tree */\n}\n\nfunction d_code(dist) {\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n}\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\n\n\nfunction put_short(s, w) {\n  //    put_byte(s, (uch)((w) & 0xff));\n  //    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = w & 0xff;\n  s.pending_buf[s.pending++] = w >>> 8 & 0xff;\n}\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\n\n\nfunction send_bits(s, value, length) {\n  if (s.bi_valid > Buf_size - length) {\n    s.bi_buf |= value << s.bi_valid & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> Buf_size - s.bi_valid;\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= value << s.bi_valid & 0xffff;\n    s.bi_valid += length;\n  }\n}\n\nfunction send_code(s, c, tree) {\n  send_bits(s, tree[c * 2]\n  /*.Code*/\n  , tree[c * 2 + 1]\n  /*.Len*/\n  );\n}\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\n\n\nfunction bi_reverse(code, len) {\n  var res = 0;\n\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n\n  return res >>> 1;\n}\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\n\n\nfunction bi_flush(s) {\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n}\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\n\n\nfunction gen_bitlen(s, desc) //    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n  var tree = desc.dyn_tree;\n  var max_code = desc.max_code;\n  var stree = desc.stat_desc.static_tree;\n  var has_stree = desc.stat_desc.has_stree;\n  var extra = desc.stat_desc.extra_bits;\n  var base = desc.stat_desc.extra_base;\n  var max_length = desc.stat_desc.max_length;\n  var h;\n  /* heap index */\n\n  var n, m;\n  /* iterate over the tree elements */\n\n  var bits;\n  /* bit length */\n\n  var xbits;\n  /* extra bits */\n\n  var f;\n  /* frequency */\n\n  var overflow = 0;\n  /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    s.bl_count[bits] = 0;\n  }\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n\n\n  tree[s.heap[s.heap_max] * 2 + 1]\n  /*.Len*/\n  = 0;\n  /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]\n    /*.Dad*/\n    * 2 + 1]\n    /*.Len*/\n    + 1;\n\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n\n    tree[n * 2 + 1]\n    /*.Len*/\n    = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) {\n      continue;\n    }\n    /* not a leaf node */\n\n\n    s.bl_count[bits]++;\n    xbits = 0;\n\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n\n    f = tree[n * 2]\n    /*.Freq*/\n    ;\n    s.opt_len += f * (bits + xbits);\n\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]\n      /*.Len*/\n      + xbits);\n    }\n  }\n\n  if (overflow === 0) {\n    return;\n  } // Trace((stderr,\"\\nbit length overflow\\n\"));\n\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n\n\n  do {\n    bits = max_length - 1;\n\n    while (s.bl_count[bits] === 0) {\n      bits--;\n    }\n\n    s.bl_count[bits]--;\n    /* move one leaf down the tree */\n\n    s.bl_count[bits + 1] += 2;\n    /* move one overflow item as its brother */\n\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n\n    overflow -= 2;\n  } while (overflow > 0);\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n\n\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n\n    while (n !== 0) {\n      m = s.heap[--h];\n\n      if (m > max_code) {\n        continue;\n      }\n\n      if (tree[m * 2 + 1]\n      /*.Len*/\n      !== bits) {\n        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]\n        /*.Len*/\n        ) * tree[m * 2]\n        /*.Freq*/\n        ;\n        tree[m * 2 + 1]\n        /*.Len*/\n        = bits;\n      }\n\n      n--;\n    }\n  }\n}\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\n\n\nfunction gen_codes(tree, max_code, bl_count) //    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n  var next_code = new Array(MAX_BITS + 1);\n  /* next code value for each bit length */\n\n  var code = 0;\n  /* running code value */\n\n  var bits;\n  /* bit index */\n\n  var n;\n  /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    next_code[bits] = code = code + bl_count[bits - 1] << 1;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n\n  for (n = 0; n <= max_code; n++) {\n    var len = tree[n * 2 + 1]\n    /*.Len*/\n    ;\n\n    if (len === 0) {\n      continue;\n    }\n    /* Now reverse the bits */\n\n\n    tree[n * 2]\n    /*.Code*/\n    = bi_reverse(next_code[len]++, len); //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n}\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\n\n\nfunction tr_static_init() {\n  var n;\n  /* iterates over tree elements */\n\n  var bits;\n  /* bit counter */\n\n  var length;\n  /* length value */\n\n  var code;\n  /* code value */\n\n  var dist;\n  /* distance index */\n\n  var bl_count = new Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n\n  /*#ifdef NO_INIT_GLOBAL_POINTERS\n    static_l_desc.static_tree = static_ltree;\n    static_l_desc.extra_bits = extra_lbits;\n    static_d_desc.static_tree = static_dtree;\n    static_d_desc.extra_bits = extra_dbits;\n    static_bl_desc.extra_bits = extra_blbits;\n  #endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n\n  length = 0;\n\n  for (code = 0; code < LENGTH_CODES - 1; code++) {\n    base_length[code] = length;\n\n    for (n = 0; n < 1 << extra_lbits[code]; n++) {\n      _length_code[length++] = code;\n    }\n  } //Assert (length == 256, \"tr_static_init: length != 256\");\n\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n\n\n  _length_code[length - 1] = code;\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n\n  dist = 0;\n\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n\n    for (n = 0; n < 1 << extra_dbits[code]; n++) {\n      _dist_code[dist++] = code;\n    }\n  } //Assert (dist == 256, \"tr_static_init: dist != 256\");\n\n\n  dist >>= 7;\n  /* from now on, all distances are divided by 128 */\n\n  for (; code < D_CODES; code++) {\n    base_dist[code] = dist << 7;\n\n    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  } //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]\n    /*.Len*/\n    = 8;\n    n++;\n    bl_count[8]++;\n  }\n\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]\n    /*.Len*/\n    = 9;\n    n++;\n    bl_count[9]++;\n  }\n\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]\n    /*.Len*/\n    = 7;\n    n++;\n    bl_count[7]++;\n  }\n\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]\n    /*.Len*/\n    = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n\n\n  gen_codes(static_ltree, L_CODES + 1, bl_count);\n  /* The static distance tree is trivial: */\n\n  for (n = 0; n < D_CODES; n++) {\n    static_dtree[n * 2 + 1]\n    /*.Len*/\n    = 5;\n    static_dtree[n * 2]\n    /*.Code*/\n    = bi_reverse(n, 5);\n  } // Now data ready and we can init static trees\n\n\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS); //static_init_done = true;\n}\n/* ===========================================================================\n * Initialize a new block.\n */\n\n\nfunction init_block(s) {\n  var n;\n  /* iterates over tree elements */\n\n  /* Initialize the trees. */\n\n  for (n = 0; n < L_CODES; n++) {\n    s.dyn_ltree[n * 2]\n    /*.Freq*/\n    = 0;\n  }\n\n  for (n = 0; n < D_CODES; n++) {\n    s.dyn_dtree[n * 2]\n    /*.Freq*/\n    = 0;\n  }\n\n  for (n = 0; n < BL_CODES; n++) {\n    s.bl_tree[n * 2]\n    /*.Freq*/\n    = 0;\n  }\n\n  s.dyn_ltree[END_BLOCK * 2]\n  /*.Freq*/\n  = 1;\n  s.opt_len = s.static_len = 0;\n  s.last_lit = s.matches = 0;\n}\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\n\n\nfunction bi_windup(s) {\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n}\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\n\n\nfunction copy_block(s, buf, len, header) //DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n  bi_windup(s);\n  /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len);\n    put_short(s, ~len);\n  } //  while (len--) {\n  //    put_byte(s, *buf++);\n  //  }\n\n\n  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n  s.pending += len;\n}\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\n\n\nfunction smaller(tree, n, m, depth) {\n  var _n2 = n * 2;\n\n  var _m2 = m * 2;\n\n  return tree[_n2]\n  /*.Freq*/\n  < tree[_m2]\n  /*.Freq*/\n  || tree[_n2]\n  /*.Freq*/\n  === tree[_m2]\n  /*.Freq*/\n  && depth[n] <= depth[m];\n}\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\n\n\nfunction pqdownheap(s, tree, k) //    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n  var v = s.heap[k];\n  var j = k << 1;\n  /* left son of k */\n\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n\n\n    if (smaller(tree, v, s.heap[j], s.depth)) {\n      break;\n    }\n    /* Exchange v with the smallest son */\n\n\n    s.heap[k] = s.heap[j];\n    k = j;\n    /* And continue down the tree, setting j to the left son of k */\n\n    j <<= 1;\n  }\n\n  s.heap[k] = v;\n} // inlined manually\n// var SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\n\n\nfunction compress_block(s, ltree, dtree) //    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n  var dist;\n  /* distance of matched string */\n\n  var lc;\n  /* match length or unmatched char (if dist == 0) */\n\n  var lx = 0;\n  /* running index in l_buf */\n\n  var code;\n  /* the code to send */\n\n  var extra;\n  /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];\n      lc = s.pending_buf[s.l_buf + lx];\n      lx++;\n\n      if (dist === 0) {\n        send_code(s, lc, ltree);\n        /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS + 1, ltree);\n        /* send the length code */\n\n        extra = extra_lbits[code];\n\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);\n          /* send the extra length bits */\n        }\n\n        dist--;\n        /* dist is now the match distance - 1 */\n\n        code = d_code(dist); //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);\n        /* send the distance code */\n\n        extra = extra_dbits[code];\n\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);\n          /* send the extra distance bits */\n        }\n      }\n      /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       \"pendingBuf overflow\");\n\n    } while (lx < s.last_lit);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n}\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\n\n\nfunction build_tree(s, desc) //    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n  var tree = desc.dyn_tree;\n  var stree = desc.stat_desc.static_tree;\n  var has_stree = desc.stat_desc.has_stree;\n  var elems = desc.stat_desc.elems;\n  var n, m;\n  /* iterate over heap elements */\n\n  var max_code = -1;\n  /* largest code with non zero frequency */\n\n  var node;\n  /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]\n    /*.Freq*/\n    !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n    } else {\n      tree[n * 2 + 1]\n      /*.Len*/\n      = 0;\n    }\n  }\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n\n\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;\n    tree[node * 2]\n    /*.Freq*/\n    = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]\n      /*.Len*/\n      ;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n\n  }\n\n  desc.max_code = max_code;\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n\n  for (n = s.heap_len >> 1\n  /*int /2*/\n  ; n >= 1; n--) {\n    pqdownheap(s, tree, n);\n  }\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n\n\n  node = elems;\n  /* next internal node of the tree */\n\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n\n    /*** pqremove ***/\n    n = s.heap[1\n    /*SMALLEST*/\n    ];\n    s.heap[1\n    /*SMALLEST*/\n    ] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1\n    /*SMALLEST*/\n    );\n    /***/\n\n    m = s.heap[1\n    /*SMALLEST*/\n    ];\n    /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n;\n    /* keep the nodes sorted by frequency */\n\n    s.heap[--s.heap_max] = m;\n    /* Create a new node father of n and m */\n\n    tree[node * 2]\n    /*.Freq*/\n    = tree[n * 2]\n    /*.Freq*/\n    + tree[m * 2]\n    /*.Freq*/\n    ;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]\n    /*.Dad*/\n    = tree[m * 2 + 1]\n    /*.Dad*/\n    = node;\n    /* and insert the new node in the heap */\n\n    s.heap[1\n    /*SMALLEST*/\n    ] = node++;\n    pqdownheap(s, tree, 1\n    /*SMALLEST*/\n    );\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1\n  /*SMALLEST*/\n  ];\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n\n  gen_bitlen(s, desc);\n  /* The field len is now set, we can generate the bit codes */\n\n  gen_codes(tree, max_code, s.bl_count);\n}\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\n\n\nfunction scan_tree(s, tree, max_code) //    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n  var n;\n  /* iterates over all tree elements */\n\n  var prevlen = -1;\n  /* last emitted length */\n\n  var curlen;\n  /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]\n  /*.Len*/\n  ;\n  /* length of next code */\n\n  var count = 0;\n  /* repeat count of the current code */\n\n  var max_count = 7;\n  /* max repeat count */\n\n  var min_count = 4;\n  /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  tree[(max_code + 1) * 2 + 1]\n  /*.Len*/\n  = 0xffff;\n  /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]\n    /*.Len*/\n    ;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]\n      /*.Freq*/\n      += count;\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        s.bl_tree[curlen * 2] /*.Freq*/++;\n      }\n\n      s.bl_tree[REP_3_6 * 2] /*.Freq*/++;\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2] /*.Freq*/++;\n    } else {\n      s.bl_tree[REPZ_11_138 * 2] /*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\n\n\nfunction send_tree(s, tree, max_code) //    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n  var n;\n  /* iterates over all tree elements */\n\n  var prevlen = -1;\n  /* last emitted length */\n\n  var curlen;\n  /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]\n  /*.Len*/\n  ;\n  /* length of next code */\n\n  var count = 0;\n  /* repeat count of the current code */\n\n  var max_count = 7;\n  /* max repeat count */\n\n  var min_count = 4;\n  /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */\n\n  /* guard already set */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]\n    /*.Len*/\n    ;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n    } else if (count < min_count) {\n      do {\n        send_code(s, curlen, s.bl_tree);\n      } while (--count !== 0);\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      } //Assert(count >= 3 && count <= 6, \" 3_6?\");\n\n\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\n\n\nfunction build_bl_tree(s) {\n  var max_blindex;\n  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n  /* Build the bit length tree: */\n\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n\n  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]\n    /*.Len*/\n    !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n\n\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4; //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n}\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\n\n\nfunction send_all_trees(s, lcodes, dcodes, blcodes) //    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n  var rank;\n  /* index in bl_order */\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n\n  send_bits(s, lcodes - 257, 5);\n  /* not +255 as stated in appnote.txt */\n\n  send_bits(s, dcodes - 1, 5);\n  send_bits(s, blcodes - 4, 4);\n  /* not -3 as stated in appnote.txt */\n\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]\n    /*.Len*/\n    , 3);\n  } //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n\n  send_tree(s, s.dyn_ltree, lcodes - 1);\n  /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1);\n  /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\n\n\nfunction detect_data_type(s) {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  var black_mask = 0xf3ffc07f;\n  var n;\n  /* Check for non-textual (\"black-listed\") bytes. */\n\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if (black_mask & 1 && s.dyn_ltree[n * 2]\n    /*.Freq*/\n    !== 0) {\n      return Z_BINARY;\n    }\n  }\n  /* Check for textual (\"white-listed\") bytes. */\n\n\n  if (s.dyn_ltree[9 * 2]\n  /*.Freq*/\n  !== 0 || s.dyn_ltree[10 * 2]\n  /*.Freq*/\n  !== 0 || s.dyn_ltree[13 * 2]\n  /*.Freq*/\n  !== 0) {\n    return Z_TEXT;\n  }\n\n  for (n = 32; n < LITERALS; n++) {\n    if (s.dyn_ltree[n * 2]\n    /*.Freq*/\n    !== 0) {\n      return Z_TEXT;\n    }\n  }\n  /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n\n\n  return Z_BINARY;\n}\n\nvar static_init_done = false;\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\n\nfunction _tr_init(s) {\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n  /* Initialize the first block of the first file: */\n\n  init_block(s);\n}\n/* ===========================================================================\n * Send a stored block\n */\n\n\nfunction _tr_stored_block(s, buf, stored_len, last) //DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);\n  /* send block type */\n\n  copy_block(s, buf, stored_len, true);\n  /* with header */\n}\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\n\n\nfunction _tr_align(s) {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n}\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\n\n\nfunction _tr_flush_block(s, buf, stored_len, last) //DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  var opt_lenb, static_lenb;\n  /* opt_len and static_len in bytes */\n\n  var max_blindex = 0;\n  /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n\n  if (s.level > 0) {\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN) {\n      s.strm.data_type = detect_data_type(s);\n    }\n    /* Construct the literal and distance trees */\n\n\n    build_tree(s, s.l_desc); // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc); // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n\n    max_blindex = build_bl_tree(s);\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n\n    opt_lenb = s.opt_len + 3 + 7 >>> 3;\n    static_lenb = s.static_len + 3 + 7 >>> 3; // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) {\n      opt_lenb = static_lenb;\n    }\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5;\n    /* force a stored block */\n  }\n\n  if (stored_len + 4 <= opt_lenb && buf !== -1) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last);\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  } // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n\n\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  } // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n\n}\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\n\n\nfunction _tr_tally(s, dist, lc) //    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n  //var out_length, in_length, dcode;\n  s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 0xff;\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n  s.last_lit++;\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2] /*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n\n    dist--;\n    /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2] /*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2] /*.Freq*/++;\n  } // (!) This block is disabled in zlib defaults,\n  // don't enable it for binary compatibility\n  //#ifdef TRUNCATE_BLOCK\n  //  /* Try to guess if it is profitable to stop the current block here */\n  //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n  //    /* Compute an upper bound for the compressed length */\n  //    out_length = s.last_lit*8;\n  //    in_length = s.strstart - s.block_start;\n  //\n  //    for (dcode = 0; dcode < D_CODES; dcode++) {\n  //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n  //    }\n  //    out_length >>>= 3;\n  //    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n  //    //       s->last_lit, in_length, out_length,\n  //    //       100L - out_length*100L/in_length));\n  //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n  //      return true;\n  //    }\n  //  }\n  //#endif\n\n\n  return s.last_lit === s.lit_bufsize - 1;\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n}\n\nexports._tr_init = _tr_init;\nexports._tr_stored_block = _tr_stored_block;\nexports._tr_flush_block = _tr_flush_block;\nexports._tr_tally = _tr_tally;\nexports._tr_align = _tr_align;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi90cmVlcy5qcz8wN2Y0Il0sIm5hbWVzIjpbInV0aWxzIiwiWl9GSVhFRCIsIlpfQklOQVJZIiwiWl9URVhUIiwiWl9VTktOT1dOIiwiemVybyIsImJ1ZiIsImxlbiIsImxlbmd0aCIsIlNUT1JFRF9CTE9DSyIsIlNUQVRJQ19UUkVFUyIsIkRZTl9UUkVFUyIsIk1JTl9NQVRDSCIsIk1BWF9NQVRDSCIsIkxFTkdUSF9DT0RFUyIsIkxJVEVSQUxTIiwiTF9DT0RFUyIsIkRfQ09ERVMiLCJCTF9DT0RFUyIsIkhFQVBfU0laRSIsIk1BWF9CSVRTIiwiQnVmX3NpemUiLCJNQVhfQkxfQklUUyIsIkVORF9CTE9DSyIsIlJFUF8zXzYiLCJSRVBaXzNfMTAiLCJSRVBaXzExXzEzOCIsImV4dHJhX2xiaXRzIiwiZXh0cmFfZGJpdHMiLCJleHRyYV9ibGJpdHMiLCJibF9vcmRlciIsIkRJU1RfQ09ERV9MRU4iLCJzdGF0aWNfbHRyZWUiLCJBcnJheSIsInN0YXRpY19kdHJlZSIsIl9kaXN0X2NvZGUiLCJfbGVuZ3RoX2NvZGUiLCJiYXNlX2xlbmd0aCIsImJhc2VfZGlzdCIsIlN0YXRpY1RyZWVEZXNjIiwic3RhdGljX3RyZWUiLCJleHRyYV9iaXRzIiwiZXh0cmFfYmFzZSIsImVsZW1zIiwibWF4X2xlbmd0aCIsImhhc19zdHJlZSIsInN0YXRpY19sX2Rlc2MiLCJzdGF0aWNfZF9kZXNjIiwic3RhdGljX2JsX2Rlc2MiLCJUcmVlRGVzYyIsImR5bl90cmVlIiwic3RhdF9kZXNjIiwibWF4X2NvZGUiLCJkX2NvZGUiLCJkaXN0IiwicHV0X3Nob3J0IiwicyIsInciLCJwZW5kaW5nX2J1ZiIsInBlbmRpbmciLCJzZW5kX2JpdHMiLCJ2YWx1ZSIsImJpX3ZhbGlkIiwiYmlfYnVmIiwic2VuZF9jb2RlIiwiYyIsInRyZWUiLCJiaV9yZXZlcnNlIiwiY29kZSIsInJlcyIsImJpX2ZsdXNoIiwiZ2VuX2JpdGxlbiIsImRlc2MiLCJzdHJlZSIsImV4dHJhIiwiYmFzZSIsImgiLCJuIiwibSIsImJpdHMiLCJ4Yml0cyIsImYiLCJvdmVyZmxvdyIsImJsX2NvdW50IiwiaGVhcCIsImhlYXBfbWF4Iiwib3B0X2xlbiIsInN0YXRpY19sZW4iLCJnZW5fY29kZXMiLCJuZXh0X2NvZGUiLCJ0cl9zdGF0aWNfaW5pdCIsImluaXRfYmxvY2siLCJkeW5fbHRyZWUiLCJkeW5fZHRyZWUiLCJibF90cmVlIiwibGFzdF9saXQiLCJtYXRjaGVzIiwiYmlfd2luZHVwIiwiY29weV9ibG9jayIsImhlYWRlciIsImFycmF5U2V0Iiwid2luZG93Iiwic21hbGxlciIsImRlcHRoIiwiX24yIiwiX20yIiwicHFkb3duaGVhcCIsImsiLCJ2IiwiaiIsImhlYXBfbGVuIiwiY29tcHJlc3NfYmxvY2siLCJsdHJlZSIsImR0cmVlIiwibGMiLCJseCIsImRfYnVmIiwibF9idWYiLCJidWlsZF90cmVlIiwibm9kZSIsInNjYW5fdHJlZSIsInByZXZsZW4iLCJjdXJsZW4iLCJuZXh0bGVuIiwiY291bnQiLCJtYXhfY291bnQiLCJtaW5fY291bnQiLCJzZW5kX3RyZWUiLCJidWlsZF9ibF90cmVlIiwibWF4X2JsaW5kZXgiLCJsX2Rlc2MiLCJkX2Rlc2MiLCJibF9kZXNjIiwic2VuZF9hbGxfdHJlZXMiLCJsY29kZXMiLCJkY29kZXMiLCJibGNvZGVzIiwicmFuayIsImRldGVjdF9kYXRhX3R5cGUiLCJibGFja19tYXNrIiwic3RhdGljX2luaXRfZG9uZSIsIl90cl9pbml0IiwiX3RyX3N0b3JlZF9ibG9jayIsInN0b3JlZF9sZW4iLCJsYXN0IiwiX3RyX2FsaWduIiwiX3RyX2ZsdXNoX2Jsb2NrIiwib3B0X2xlbmIiLCJzdGF0aWNfbGVuYiIsImxldmVsIiwic3RybSIsImRhdGFfdHlwZSIsInN0cmF0ZWd5IiwiX3RyX3RhbGx5IiwibGl0X2J1ZnNpemUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQ0FFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSUEsS0FBSyxHQUFHLG1CQUFPLENBQUMsZ0VBQUQsQ0FBbkI7QUFFQTs7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7O0FBQ0EsSUFBSUMsT0FBTyxHQUFpQixDQUE1QixDLENBQ0E7O0FBRUE7O0FBQ0EsSUFBSUMsUUFBUSxHQUFnQixDQUE1QjtBQUNBLElBQUlDLE1BQU0sR0FBa0IsQ0FBNUIsQyxDQUNBOztBQUNBLElBQUlDLFNBQVMsR0FBZSxDQUE1QjtBQUVBOztBQUdBLFNBQVNDLElBQVQsQ0FBY0MsR0FBZCxFQUFtQjtBQUFFLE1BQUlDLEdBQUcsR0FBR0QsR0FBRyxDQUFDRSxNQUFkOztBQUFzQixTQUFPLEVBQUVELEdBQUYsSUFBUyxDQUFoQixFQUFtQjtBQUFFRCxPQUFHLENBQUNDLEdBQUQsQ0FBSCxHQUFXLENBQVg7QUFBZTtBQUFFLEMsQ0FFakY7OztBQUVBLElBQUlFLFlBQVksR0FBRyxDQUFuQjtBQUNBLElBQUlDLFlBQVksR0FBRyxDQUFuQjtBQUNBLElBQUlDLFNBQVMsR0FBTSxDQUFuQjtBQUNBOztBQUVBLElBQUlDLFNBQVMsR0FBTSxDQUFuQjtBQUNBLElBQUlDLFNBQVMsR0FBTSxHQUFuQjtBQUNBO0FBRUE7O0FBQ0E7Ozs7QUFJQSxJQUFJQyxZQUFZLEdBQUksRUFBcEI7QUFDQTs7QUFFQSxJQUFJQyxRQUFRLEdBQVEsR0FBcEI7QUFDQTs7QUFFQSxJQUFJQyxPQUFPLEdBQVNELFFBQVEsR0FBRyxDQUFYLEdBQWVELFlBQW5DO0FBQ0E7O0FBRUEsSUFBSUcsT0FBTyxHQUFTLEVBQXBCO0FBQ0E7O0FBRUEsSUFBSUMsUUFBUSxHQUFRLEVBQXBCO0FBQ0E7O0FBRUEsSUFBSUMsU0FBUyxHQUFPLElBQUlILE9BQUosR0FBYyxDQUFsQztBQUNBOztBQUVBLElBQUlJLFFBQVEsR0FBUSxFQUFwQjtBQUNBOztBQUVBLElBQUlDLFFBQVEsR0FBUSxFQUFwQjtBQUNBOztBQUdBOzs7O0FBSUEsSUFBSUMsV0FBVyxHQUFHLENBQWxCO0FBQ0E7O0FBRUEsSUFBSUMsU0FBUyxHQUFLLEdBQWxCO0FBQ0E7O0FBRUEsSUFBSUMsT0FBTyxHQUFPLEVBQWxCO0FBQ0E7O0FBRUEsSUFBSUMsU0FBUyxHQUFLLEVBQWxCO0FBQ0E7O0FBRUEsSUFBSUMsV0FBVyxHQUFHLEVBQWxCO0FBQ0E7O0FBRUE7O0FBQ0EsSUFBSUMsV0FBVztBQUFLO0FBQ2xCLENBQUMsQ0FBRCxFQUFHLENBQUgsRUFBSyxDQUFMLEVBQU8sQ0FBUCxFQUFTLENBQVQsRUFBVyxDQUFYLEVBQWEsQ0FBYixFQUFlLENBQWYsRUFBaUIsQ0FBakIsRUFBbUIsQ0FBbkIsRUFBcUIsQ0FBckIsRUFBdUIsQ0FBdkIsRUFBeUIsQ0FBekIsRUFBMkIsQ0FBM0IsRUFBNkIsQ0FBN0IsRUFBK0IsQ0FBL0IsRUFBaUMsQ0FBakMsRUFBbUMsQ0FBbkMsRUFBcUMsQ0FBckMsRUFBdUMsQ0FBdkMsRUFBeUMsQ0FBekMsRUFBMkMsQ0FBM0MsRUFBNkMsQ0FBN0MsRUFBK0MsQ0FBL0MsRUFBaUQsQ0FBakQsRUFBbUQsQ0FBbkQsRUFBcUQsQ0FBckQsRUFBdUQsQ0FBdkQsRUFBeUQsQ0FBekQsQ0FERjtBQUdBLElBQUlDLFdBQVc7QUFBSztBQUNsQixDQUFDLENBQUQsRUFBRyxDQUFILEVBQUssQ0FBTCxFQUFPLENBQVAsRUFBUyxDQUFULEVBQVcsQ0FBWCxFQUFhLENBQWIsRUFBZSxDQUFmLEVBQWlCLENBQWpCLEVBQW1CLENBQW5CLEVBQXFCLENBQXJCLEVBQXVCLENBQXZCLEVBQXlCLENBQXpCLEVBQTJCLENBQTNCLEVBQTZCLENBQTdCLEVBQStCLENBQS9CLEVBQWlDLENBQWpDLEVBQW1DLENBQW5DLEVBQXFDLENBQXJDLEVBQXVDLENBQXZDLEVBQXlDLENBQXpDLEVBQTJDLENBQTNDLEVBQTZDLEVBQTdDLEVBQWdELEVBQWhELEVBQW1ELEVBQW5ELEVBQXNELEVBQXRELEVBQXlELEVBQXpELEVBQTRELEVBQTVELEVBQStELEVBQS9ELEVBQWtFLEVBQWxFLENBREY7QUFHQSxJQUFJQyxZQUFZO0FBQUk7QUFDbEIsQ0FBQyxDQUFELEVBQUcsQ0FBSCxFQUFLLENBQUwsRUFBTyxDQUFQLEVBQVMsQ0FBVCxFQUFXLENBQVgsRUFBYSxDQUFiLEVBQWUsQ0FBZixFQUFpQixDQUFqQixFQUFtQixDQUFuQixFQUFxQixDQUFyQixFQUF1QixDQUF2QixFQUF5QixDQUF6QixFQUEyQixDQUEzQixFQUE2QixDQUE3QixFQUErQixDQUEvQixFQUFpQyxDQUFqQyxFQUFtQyxDQUFuQyxFQUFxQyxDQUFyQyxDQURGO0FBR0EsSUFBSUMsUUFBUSxHQUNWLENBQUMsRUFBRCxFQUFJLEVBQUosRUFBTyxFQUFQLEVBQVUsQ0FBVixFQUFZLENBQVosRUFBYyxDQUFkLEVBQWdCLENBQWhCLEVBQWtCLENBQWxCLEVBQW9CLEVBQXBCLEVBQXVCLENBQXZCLEVBQXlCLEVBQXpCLEVBQTRCLENBQTVCLEVBQThCLEVBQTlCLEVBQWlDLENBQWpDLEVBQW1DLEVBQW5DLEVBQXNDLENBQXRDLEVBQXdDLEVBQXhDLEVBQTJDLENBQTNDLEVBQTZDLEVBQTdDLENBREY7QUFFQTs7QUFFQTs7OztBQUlBOzs7QUFJQTs7QUFFQSxJQUFJQyxhQUFhLEdBQUcsR0FBcEI7QUFBeUI7QUFFekI7O0FBQ0EsSUFBSUMsWUFBWSxHQUFJLElBQUlDLEtBQUosQ0FBVSxDQUFDakIsT0FBTyxHQUFHLENBQVgsSUFBZ0IsQ0FBMUIsQ0FBcEI7QUFDQVgsSUFBSSxDQUFDMkIsWUFBRCxDQUFKO0FBQ0E7Ozs7OztBQU1BLElBQUlFLFlBQVksR0FBSSxJQUFJRCxLQUFKLENBQVVoQixPQUFPLEdBQUcsQ0FBcEIsQ0FBcEI7QUFDQVosSUFBSSxDQUFDNkIsWUFBRCxDQUFKO0FBQ0E7Ozs7QUFJQSxJQUFJQyxVQUFVLEdBQU0sSUFBSUYsS0FBSixDQUFVRixhQUFWLENBQXBCOztBQUNBMUIsSUFBSSxDQUFDOEIsVUFBRCxDQUFKO0FBQ0E7Ozs7O0FBS0EsSUFBSUMsWUFBWSxHQUFJLElBQUlILEtBQUosQ0FBVXBCLFNBQVMsR0FBR0QsU0FBWixHQUF3QixDQUFsQyxDQUFwQjs7QUFDQVAsSUFBSSxDQUFDK0IsWUFBRCxDQUFKO0FBQ0E7O0FBRUEsSUFBSUMsV0FBVyxHQUFLLElBQUlKLEtBQUosQ0FBVW5CLFlBQVYsQ0FBcEI7QUFDQVQsSUFBSSxDQUFDZ0MsV0FBRCxDQUFKO0FBQ0E7O0FBRUEsSUFBSUMsU0FBUyxHQUFPLElBQUlMLEtBQUosQ0FBVWhCLE9BQVYsQ0FBcEI7QUFDQVosSUFBSSxDQUFDaUMsU0FBRCxDQUFKO0FBQ0E7O0FBR0EsU0FBU0MsY0FBVCxDQUF3QkMsV0FBeEIsRUFBcUNDLFVBQXJDLEVBQWlEQyxVQUFqRCxFQUE2REMsS0FBN0QsRUFBb0VDLFVBQXBFLEVBQWdGO0FBRTlFLE9BQUtKLFdBQUwsR0FBb0JBLFdBQXBCO0FBQWtDOztBQUNsQyxPQUFLQyxVQUFMLEdBQW9CQSxVQUFwQjtBQUFrQzs7QUFDbEMsT0FBS0MsVUFBTCxHQUFvQkEsVUFBcEI7QUFBa0M7O0FBQ2xDLE9BQUtDLEtBQUwsR0FBb0JBLEtBQXBCO0FBQWtDOztBQUNsQyxPQUFLQyxVQUFMLEdBQW9CQSxVQUFwQjtBQUFrQztBQUVsQzs7QUFDQSxPQUFLQyxTQUFMLEdBQW9CTCxXQUFXLElBQUlBLFdBQVcsQ0FBQ2hDLE1BQS9DO0FBQ0Q7O0FBR0QsSUFBSXNDLGFBQUo7QUFDQSxJQUFJQyxhQUFKO0FBQ0EsSUFBSUMsY0FBSjs7QUFHQSxTQUFTQyxRQUFULENBQWtCQyxRQUFsQixFQUE0QkMsU0FBNUIsRUFBdUM7QUFDckMsT0FBS0QsUUFBTCxHQUFnQkEsUUFBaEI7QUFBOEI7O0FBQzlCLE9BQUtFLFFBQUwsR0FBZ0IsQ0FBaEI7QUFBOEI7O0FBQzlCLE9BQUtELFNBQUwsR0FBaUJBLFNBQWpCO0FBQThCO0FBQy9COztBQUlELFNBQVNFLE1BQVQsQ0FBZ0JDLElBQWhCLEVBQXNCO0FBQ3BCLFNBQU9BLElBQUksR0FBRyxHQUFQLEdBQWFuQixVQUFVLENBQUNtQixJQUFELENBQXZCLEdBQWdDbkIsVUFBVSxDQUFDLE9BQU9tQixJQUFJLEtBQUssQ0FBaEIsQ0FBRCxDQUFqRDtBQUNEO0FBR0Q7Ozs7OztBQUlBLFNBQVNDLFNBQVQsQ0FBbUJDLENBQW5CLEVBQXNCQyxDQUF0QixFQUF5QjtBQUN6QjtBQUNBO0FBQ0VELEdBQUMsQ0FBQ0UsV0FBRixDQUFjRixDQUFDLENBQUNHLE9BQUYsRUFBZCxJQUE4QkYsQ0FBRCxHQUFNLElBQW5DO0FBQ0FELEdBQUMsQ0FBQ0UsV0FBRixDQUFjRixDQUFDLENBQUNHLE9BQUYsRUFBZCxJQUE4QkYsQ0FBQyxLQUFLLENBQVAsR0FBWSxJQUF6QztBQUNEO0FBR0Q7Ozs7OztBQUlBLFNBQVNHLFNBQVQsQ0FBbUJKLENBQW5CLEVBQXNCSyxLQUF0QixFQUE2QnJELE1BQTdCLEVBQXFDO0FBQ25DLE1BQUlnRCxDQUFDLENBQUNNLFFBQUYsR0FBY3pDLFFBQVEsR0FBR2IsTUFBN0IsRUFBc0M7QUFDcENnRCxLQUFDLENBQUNPLE1BQUYsSUFBYUYsS0FBSyxJQUFJTCxDQUFDLENBQUNNLFFBQVosR0FBd0IsTUFBcEM7QUFDQVAsYUFBUyxDQUFDQyxDQUFELEVBQUlBLENBQUMsQ0FBQ08sTUFBTixDQUFUO0FBQ0FQLEtBQUMsQ0FBQ08sTUFBRixHQUFXRixLQUFLLElBQUt4QyxRQUFRLEdBQUdtQyxDQUFDLENBQUNNLFFBQWxDO0FBQ0FOLEtBQUMsQ0FBQ00sUUFBRixJQUFjdEQsTUFBTSxHQUFHYSxRQUF2QjtBQUNELEdBTEQsTUFLTztBQUNMbUMsS0FBQyxDQUFDTyxNQUFGLElBQWFGLEtBQUssSUFBSUwsQ0FBQyxDQUFDTSxRQUFaLEdBQXdCLE1BQXBDO0FBQ0FOLEtBQUMsQ0FBQ00sUUFBRixJQUFjdEQsTUFBZDtBQUNEO0FBQ0Y7O0FBR0QsU0FBU3dELFNBQVQsQ0FBbUJSLENBQW5CLEVBQXNCUyxDQUF0QixFQUF5QkMsSUFBekIsRUFBK0I7QUFDN0JOLFdBQVMsQ0FBQ0osQ0FBRCxFQUFJVSxJQUFJLENBQUNELENBQUMsR0FBRyxDQUFMO0FBQU87QUFBZixJQUEwQkMsSUFBSSxDQUFDRCxDQUFDLEdBQUcsQ0FBSixHQUFRLENBQVQ7QUFBVztBQUF6QyxHQUFUO0FBQ0Q7QUFHRDs7Ozs7OztBQUtBLFNBQVNFLFVBQVQsQ0FBb0JDLElBQXBCLEVBQTBCN0QsR0FBMUIsRUFBK0I7QUFDN0IsTUFBSThELEdBQUcsR0FBRyxDQUFWOztBQUNBLEtBQUc7QUFDREEsT0FBRyxJQUFJRCxJQUFJLEdBQUcsQ0FBZDtBQUNBQSxRQUFJLE1BQU0sQ0FBVjtBQUNBQyxPQUFHLEtBQUssQ0FBUjtBQUNELEdBSkQsUUFJUyxFQUFFOUQsR0FBRixHQUFRLENBSmpCOztBQUtBLFNBQU84RCxHQUFHLEtBQUssQ0FBZjtBQUNEO0FBR0Q7Ozs7O0FBR0EsU0FBU0MsUUFBVCxDQUFrQmQsQ0FBbEIsRUFBcUI7QUFDbkIsTUFBSUEsQ0FBQyxDQUFDTSxRQUFGLEtBQWUsRUFBbkIsRUFBdUI7QUFDckJQLGFBQVMsQ0FBQ0MsQ0FBRCxFQUFJQSxDQUFDLENBQUNPLE1BQU4sQ0FBVDtBQUNBUCxLQUFDLENBQUNPLE1BQUYsR0FBVyxDQUFYO0FBQ0FQLEtBQUMsQ0FBQ00sUUFBRixHQUFhLENBQWI7QUFFRCxHQUxELE1BS08sSUFBSU4sQ0FBQyxDQUFDTSxRQUFGLElBQWMsQ0FBbEIsRUFBcUI7QUFDMUJOLEtBQUMsQ0FBQ0UsV0FBRixDQUFjRixDQUFDLENBQUNHLE9BQUYsRUFBZCxJQUE2QkgsQ0FBQyxDQUFDTyxNQUFGLEdBQVcsSUFBeEM7QUFDQVAsS0FBQyxDQUFDTyxNQUFGLEtBQWEsQ0FBYjtBQUNBUCxLQUFDLENBQUNNLFFBQUYsSUFBYyxDQUFkO0FBQ0Q7QUFDRjtBQUdEOzs7Ozs7Ozs7Ozs7QUFVQSxTQUFTUyxVQUFULENBQW9CZixDQUFwQixFQUF1QmdCLElBQXZCLEVBQ0E7QUFDQTtBQUNBO0FBQ0UsTUFBSU4sSUFBSSxHQUFjTSxJQUFJLENBQUN0QixRQUEzQjtBQUNBLE1BQUlFLFFBQVEsR0FBVW9CLElBQUksQ0FBQ3BCLFFBQTNCO0FBQ0EsTUFBSXFCLEtBQUssR0FBYUQsSUFBSSxDQUFDckIsU0FBTCxDQUFlWCxXQUFyQztBQUNBLE1BQUlLLFNBQVMsR0FBUzJCLElBQUksQ0FBQ3JCLFNBQUwsQ0FBZU4sU0FBckM7QUFDQSxNQUFJNkIsS0FBSyxHQUFhRixJQUFJLENBQUNyQixTQUFMLENBQWVWLFVBQXJDO0FBQ0EsTUFBSWtDLElBQUksR0FBY0gsSUFBSSxDQUFDckIsU0FBTCxDQUFlVCxVQUFyQztBQUNBLE1BQUlFLFVBQVUsR0FBUTRCLElBQUksQ0FBQ3JCLFNBQUwsQ0FBZVAsVUFBckM7QUFDQSxNQUFJZ0MsQ0FBSjtBQUFvQjs7QUFDcEIsTUFBSUMsQ0FBSixFQUFPQyxDQUFQO0FBQW9COztBQUNwQixNQUFJQyxJQUFKO0FBQW9COztBQUNwQixNQUFJQyxLQUFKO0FBQW9COztBQUNwQixNQUFJQyxDQUFKO0FBQW9COztBQUNwQixNQUFJQyxRQUFRLEdBQUcsQ0FBZjtBQUFvQjs7QUFFcEIsT0FBS0gsSUFBSSxHQUFHLENBQVosRUFBZUEsSUFBSSxJQUFJM0QsUUFBdkIsRUFBaUMyRCxJQUFJLEVBQXJDLEVBQXlDO0FBQ3ZDdkIsS0FBQyxDQUFDMkIsUUFBRixDQUFXSixJQUFYLElBQW1CLENBQW5CO0FBQ0Q7QUFFRDs7Ozs7QUFHQWIsTUFBSSxDQUFDVixDQUFDLENBQUM0QixJQUFGLENBQU81QixDQUFDLENBQUM2QixRQUFULElBQXFCLENBQXJCLEdBQXlCLENBQTFCO0FBQTRCO0FBQWhDLElBQTJDLENBQTNDO0FBQThDOztBQUU5QyxPQUFLVCxDQUFDLEdBQUdwQixDQUFDLENBQUM2QixRQUFGLEdBQWEsQ0FBdEIsRUFBeUJULENBQUMsR0FBR3pELFNBQTdCLEVBQXdDeUQsQ0FBQyxFQUF6QyxFQUE2QztBQUMzQ0MsS0FBQyxHQUFHckIsQ0FBQyxDQUFDNEIsSUFBRixDQUFPUixDQUFQLENBQUo7QUFDQUcsUUFBSSxHQUFHYixJQUFJLENBQUNBLElBQUksQ0FBQ1csQ0FBQyxHQUFHLENBQUosR0FBUSxDQUFUO0FBQVc7QUFBZixNQUEwQixDQUExQixHQUE4QixDQUEvQjtBQUFpQztBQUFyQyxNQUFnRCxDQUF2RDs7QUFDQSxRQUFJRSxJQUFJLEdBQUduQyxVQUFYLEVBQXVCO0FBQ3JCbUMsVUFBSSxHQUFHbkMsVUFBUDtBQUNBc0MsY0FBUTtBQUNUOztBQUNEaEIsUUFBSSxDQUFDVyxDQUFDLEdBQUcsQ0FBSixHQUFRLENBQVQ7QUFBVztBQUFmLE1BQTBCRSxJQUExQjtBQUNBOztBQUVBLFFBQUlGLENBQUMsR0FBR3pCLFFBQVIsRUFBa0I7QUFBRTtBQUFXO0FBQUM7OztBQUVoQ0ksS0FBQyxDQUFDMkIsUUFBRixDQUFXSixJQUFYO0FBQ0FDLFNBQUssR0FBRyxDQUFSOztBQUNBLFFBQUlILENBQUMsSUFBSUYsSUFBVCxFQUFlO0FBQ2JLLFdBQUssR0FBR04sS0FBSyxDQUFDRyxDQUFDLEdBQUdGLElBQUwsQ0FBYjtBQUNEOztBQUNETSxLQUFDLEdBQUdmLElBQUksQ0FBQ1csQ0FBQyxHQUFHLENBQUw7QUFBTztBQUFmO0FBQ0FyQixLQUFDLENBQUM4QixPQUFGLElBQWFMLENBQUMsSUFBSUYsSUFBSSxHQUFHQyxLQUFYLENBQWQ7O0FBQ0EsUUFBSW5DLFNBQUosRUFBZTtBQUNiVyxPQUFDLENBQUMrQixVQUFGLElBQWdCTixDQUFDLElBQUlSLEtBQUssQ0FBQ0ksQ0FBQyxHQUFHLENBQUosR0FBUSxDQUFUO0FBQVc7QUFBaEIsUUFBMkJHLEtBQS9CLENBQWpCO0FBQ0Q7QUFDRjs7QUFDRCxNQUFJRSxRQUFRLEtBQUssQ0FBakIsRUFBb0I7QUFBRTtBQUFTLEdBL0NqQyxDQWlERTs7QUFDQTs7QUFFQTs7O0FBQ0EsS0FBRztBQUNESCxRQUFJLEdBQUduQyxVQUFVLEdBQUcsQ0FBcEI7O0FBQ0EsV0FBT1ksQ0FBQyxDQUFDMkIsUUFBRixDQUFXSixJQUFYLE1BQXFCLENBQTVCLEVBQStCO0FBQUVBLFVBQUk7QUFBSzs7QUFDMUN2QixLQUFDLENBQUMyQixRQUFGLENBQVdKLElBQVg7QUFBeUI7O0FBQ3pCdkIsS0FBQyxDQUFDMkIsUUFBRixDQUFXSixJQUFJLEdBQUcsQ0FBbEIsS0FBd0IsQ0FBeEI7QUFBMkI7O0FBQzNCdkIsS0FBQyxDQUFDMkIsUUFBRixDQUFXdkMsVUFBWDtBQUNBOzs7O0FBR0FzQyxZQUFRLElBQUksQ0FBWjtBQUNELEdBVkQsUUFVU0EsUUFBUSxHQUFHLENBVnBCO0FBWUE7Ozs7Ozs7QUFLQSxPQUFLSCxJQUFJLEdBQUduQyxVQUFaLEVBQXdCbUMsSUFBSSxLQUFLLENBQWpDLEVBQW9DQSxJQUFJLEVBQXhDLEVBQTRDO0FBQzFDRixLQUFDLEdBQUdyQixDQUFDLENBQUMyQixRQUFGLENBQVdKLElBQVgsQ0FBSjs7QUFDQSxXQUFPRixDQUFDLEtBQUssQ0FBYixFQUFnQjtBQUNkQyxPQUFDLEdBQUd0QixDQUFDLENBQUM0QixJQUFGLENBQU8sRUFBRVIsQ0FBVCxDQUFKOztBQUNBLFVBQUlFLENBQUMsR0FBRzFCLFFBQVIsRUFBa0I7QUFBRTtBQUFXOztBQUMvQixVQUFJYyxJQUFJLENBQUNZLENBQUMsR0FBRyxDQUFKLEdBQVEsQ0FBVDtBQUFXO0FBQWYsVUFBNEJDLElBQWhDLEVBQXNDO0FBQ3BDO0FBQ0F2QixTQUFDLENBQUM4QixPQUFGLElBQWEsQ0FBQ1AsSUFBSSxHQUFHYixJQUFJLENBQUNZLENBQUMsR0FBRyxDQUFKLEdBQVEsQ0FBVDtBQUFXO0FBQXZCLFlBQW1DWixJQUFJLENBQUNZLENBQUMsR0FBRyxDQUFMO0FBQU87QUFBM0Q7QUFDQVosWUFBSSxDQUFDWSxDQUFDLEdBQUcsQ0FBSixHQUFRLENBQVQ7QUFBVztBQUFmLFVBQTBCQyxJQUExQjtBQUNEOztBQUNERixPQUFDO0FBQ0Y7QUFDRjtBQUNGO0FBR0Q7Ozs7Ozs7Ozs7QUFRQSxTQUFTVyxTQUFULENBQW1CdEIsSUFBbkIsRUFBeUJkLFFBQXpCLEVBQW1DK0IsUUFBbkMsRUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFLE1BQUlNLFNBQVMsR0FBRyxJQUFJeEQsS0FBSixDQUFVYixRQUFRLEdBQUcsQ0FBckIsQ0FBaEI7QUFBeUM7O0FBQ3pDLE1BQUlnRCxJQUFJLEdBQUcsQ0FBWDtBQUEyQjs7QUFDM0IsTUFBSVcsSUFBSjtBQUEyQjs7QUFDM0IsTUFBSUYsQ0FBSjtBQUEyQjs7QUFFM0I7Ozs7QUFHQSxPQUFLRSxJQUFJLEdBQUcsQ0FBWixFQUFlQSxJQUFJLElBQUkzRCxRQUF2QixFQUFpQzJELElBQUksRUFBckMsRUFBeUM7QUFDdkNVLGFBQVMsQ0FBQ1YsSUFBRCxDQUFULEdBQWtCWCxJQUFJLEdBQUlBLElBQUksR0FBR2UsUUFBUSxDQUFDSixJQUFJLEdBQUcsQ0FBUixDQUFoQixJQUErQixDQUF4RDtBQUNEO0FBQ0Q7OztBQUdBO0FBQ0E7QUFDQTs7O0FBRUEsT0FBS0YsQ0FBQyxHQUFHLENBQVQsRUFBYUEsQ0FBQyxJQUFJekIsUUFBbEIsRUFBNEJ5QixDQUFDLEVBQTdCLEVBQWlDO0FBQy9CLFFBQUl0RSxHQUFHLEdBQUcyRCxJQUFJLENBQUNXLENBQUMsR0FBRyxDQUFKLEdBQVEsQ0FBVDtBQUFXO0FBQXpCOztBQUNBLFFBQUl0RSxHQUFHLEtBQUssQ0FBWixFQUFlO0FBQUU7QUFBVztBQUM1Qjs7O0FBQ0EyRCxRQUFJLENBQUNXLENBQUMsR0FBRyxDQUFMO0FBQU87QUFBWCxNQUF1QlYsVUFBVSxDQUFDc0IsU0FBUyxDQUFDbEYsR0FBRCxDQUFULEVBQUQsRUFBbUJBLEdBQW5CLENBQWpDLENBSitCLENBTS9CO0FBQ0E7QUFDRDtBQUNGO0FBR0Q7Ozs7O0FBR0EsU0FBU21GLGNBQVQsR0FBMEI7QUFDeEIsTUFBSWIsQ0FBSjtBQUFjOztBQUNkLE1BQUlFLElBQUo7QUFBYzs7QUFDZCxNQUFJdkUsTUFBSjtBQUFjOztBQUNkLE1BQUk0RCxJQUFKO0FBQWM7O0FBQ2QsTUFBSWQsSUFBSjtBQUFjOztBQUNkLE1BQUk2QixRQUFRLEdBQUcsSUFBSWxELEtBQUosQ0FBVWIsUUFBUSxHQUFHLENBQXJCLENBQWY7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7O0FBQ0Y7Ozs7Ozs7O0FBUUU7O0FBQ0FaLFFBQU0sR0FBRyxDQUFUOztBQUNBLE9BQUs0RCxJQUFJLEdBQUcsQ0FBWixFQUFlQSxJQUFJLEdBQUd0RCxZQUFZLEdBQUcsQ0FBckMsRUFBd0NzRCxJQUFJLEVBQTVDLEVBQWdEO0FBQzlDL0IsZUFBVyxDQUFDK0IsSUFBRCxDQUFYLEdBQW9CNUQsTUFBcEI7O0FBQ0EsU0FBS3FFLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBSSxLQUFLbEQsV0FBVyxDQUFDeUMsSUFBRCxDQUFqQyxFQUEwQ1MsQ0FBQyxFQUEzQyxFQUErQztBQUM3Q3pDLGtCQUFZLENBQUM1QixNQUFNLEVBQVAsQ0FBWixHQUF5QjRELElBQXpCO0FBQ0Q7QUFDRixHQTVCdUIsQ0E2QnhCOztBQUNBOzs7Ozs7QUFJQWhDLGNBQVksQ0FBQzVCLE1BQU0sR0FBRyxDQUFWLENBQVosR0FBMkI0RCxJQUEzQjtBQUVBOztBQUNBZCxNQUFJLEdBQUcsQ0FBUDs7QUFDQSxPQUFLYyxJQUFJLEdBQUcsQ0FBWixFQUFlQSxJQUFJLEdBQUcsRUFBdEIsRUFBMEJBLElBQUksRUFBOUIsRUFBa0M7QUFDaEM5QixhQUFTLENBQUM4QixJQUFELENBQVQsR0FBa0JkLElBQWxCOztBQUNBLFNBQUt1QixDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUksS0FBS2pELFdBQVcsQ0FBQ3dDLElBQUQsQ0FBakMsRUFBMENTLENBQUMsRUFBM0MsRUFBK0M7QUFDN0MxQyxnQkFBVSxDQUFDbUIsSUFBSSxFQUFMLENBQVYsR0FBcUJjLElBQXJCO0FBQ0Q7QUFDRixHQTNDdUIsQ0E0Q3hCOzs7QUFDQWQsTUFBSSxLQUFLLENBQVQ7QUFBWTs7QUFDWixTQUFPYyxJQUFJLEdBQUduRCxPQUFkLEVBQXVCbUQsSUFBSSxFQUEzQixFQUErQjtBQUM3QjlCLGFBQVMsQ0FBQzhCLElBQUQsQ0FBVCxHQUFrQmQsSUFBSSxJQUFJLENBQTFCOztBQUNBLFNBQUt1QixDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUksS0FBTWpELFdBQVcsQ0FBQ3dDLElBQUQsQ0FBWCxHQUFvQixDQUEzQyxFQUFnRFMsQ0FBQyxFQUFqRCxFQUFxRDtBQUNuRDFDLGdCQUFVLENBQUMsTUFBTW1CLElBQUksRUFBWCxDQUFWLEdBQTJCYyxJQUEzQjtBQUNEO0FBQ0YsR0FuRHVCLENBb0R4Qjs7QUFFQTs7O0FBQ0EsT0FBS1csSUFBSSxHQUFHLENBQVosRUFBZUEsSUFBSSxJQUFJM0QsUUFBdkIsRUFBaUMyRCxJQUFJLEVBQXJDLEVBQXlDO0FBQ3ZDSSxZQUFRLENBQUNKLElBQUQsQ0FBUixHQUFpQixDQUFqQjtBQUNEOztBQUVERixHQUFDLEdBQUcsQ0FBSjs7QUFDQSxTQUFPQSxDQUFDLElBQUksR0FBWixFQUFpQjtBQUNmN0MsZ0JBQVksQ0FBQzZDLENBQUMsR0FBRyxDQUFKLEdBQVEsQ0FBVDtBQUFXO0FBQXZCLE1BQWtDLENBQWxDO0FBQ0FBLEtBQUM7QUFDRE0sWUFBUSxDQUFDLENBQUQsQ0FBUjtBQUNEOztBQUNELFNBQU9OLENBQUMsSUFBSSxHQUFaLEVBQWlCO0FBQ2Y3QyxnQkFBWSxDQUFDNkMsQ0FBQyxHQUFHLENBQUosR0FBUSxDQUFUO0FBQVc7QUFBdkIsTUFBa0MsQ0FBbEM7QUFDQUEsS0FBQztBQUNETSxZQUFRLENBQUMsQ0FBRCxDQUFSO0FBQ0Q7O0FBQ0QsU0FBT04sQ0FBQyxJQUFJLEdBQVosRUFBaUI7QUFDZjdDLGdCQUFZLENBQUM2QyxDQUFDLEdBQUcsQ0FBSixHQUFRLENBQVQ7QUFBVztBQUF2QixNQUFrQyxDQUFsQztBQUNBQSxLQUFDO0FBQ0RNLFlBQVEsQ0FBQyxDQUFELENBQVI7QUFDRDs7QUFDRCxTQUFPTixDQUFDLElBQUksR0FBWixFQUFpQjtBQUNmN0MsZ0JBQVksQ0FBQzZDLENBQUMsR0FBRyxDQUFKLEdBQVEsQ0FBVDtBQUFXO0FBQXZCLE1BQWtDLENBQWxDO0FBQ0FBLEtBQUM7QUFDRE0sWUFBUSxDQUFDLENBQUQsQ0FBUjtBQUNEO0FBQ0Q7Ozs7OztBQUlBSyxXQUFTLENBQUN4RCxZQUFELEVBQWVoQixPQUFPLEdBQUcsQ0FBekIsRUFBNEJtRSxRQUE1QixDQUFUO0FBRUE7O0FBQ0EsT0FBS04sQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHNUQsT0FBaEIsRUFBeUI0RCxDQUFDLEVBQTFCLEVBQThCO0FBQzVCM0MsZ0JBQVksQ0FBQzJDLENBQUMsR0FBRyxDQUFKLEdBQVEsQ0FBVDtBQUFXO0FBQXZCLE1BQWtDLENBQWxDO0FBQ0EzQyxnQkFBWSxDQUFDMkMsQ0FBQyxHQUFHLENBQUw7QUFBTztBQUFuQixNQUErQlYsVUFBVSxDQUFDVSxDQUFELEVBQUksQ0FBSixDQUF6QztBQUNELEdBMUZ1QixDQTRGeEI7OztBQUNBL0IsZUFBYSxHQUFHLElBQUlQLGNBQUosQ0FBbUJQLFlBQW5CLEVBQWlDTCxXQUFqQyxFQUE4Q1osUUFBUSxHQUFHLENBQXpELEVBQTREQyxPQUE1RCxFQUFxRUksUUFBckUsQ0FBaEI7QUFDQTJCLGVBQWEsR0FBRyxJQUFJUixjQUFKLENBQW1CTCxZQUFuQixFQUFpQ04sV0FBakMsRUFBOEMsQ0FBOUMsRUFBMERYLE9BQTFELEVBQW1FRyxRQUFuRSxDQUFoQjtBQUNBNEIsZ0JBQWMsR0FBRyxJQUFJVCxjQUFKLENBQW1CLElBQUlOLEtBQUosQ0FBVSxDQUFWLENBQW5CLEVBQWlDSixZQUFqQyxFQUErQyxDQUEvQyxFQUEwRFgsUUFBMUQsRUFBb0VJLFdBQXBFLENBQWpCLENBL0Z3QixDQWlHeEI7QUFDRDtBQUdEOzs7OztBQUdBLFNBQVNxRSxVQUFULENBQW9CbkMsQ0FBcEIsRUFBdUI7QUFDckIsTUFBSXFCLENBQUo7QUFBTzs7QUFFUDs7QUFDQSxPQUFLQSxDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUc3RCxPQUFoQixFQUEwQjZELENBQUMsRUFBM0IsRUFBK0I7QUFBRXJCLEtBQUMsQ0FBQ29DLFNBQUYsQ0FBWWYsQ0FBQyxHQUFHLENBQWhCO0FBQWtCO0FBQWxCLE1BQThCLENBQTlCO0FBQWtDOztBQUNuRSxPQUFLQSxDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUc1RCxPQUFoQixFQUEwQjRELENBQUMsRUFBM0IsRUFBK0I7QUFBRXJCLEtBQUMsQ0FBQ3FDLFNBQUYsQ0FBWWhCLENBQUMsR0FBRyxDQUFoQjtBQUFrQjtBQUFsQixNQUE4QixDQUE5QjtBQUFrQzs7QUFDbkUsT0FBS0EsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHM0QsUUFBaEIsRUFBMEIyRCxDQUFDLEVBQTNCLEVBQStCO0FBQUVyQixLQUFDLENBQUNzQyxPQUFGLENBQVVqQixDQUFDLEdBQUcsQ0FBZDtBQUFnQjtBQUFoQixNQUE0QixDQUE1QjtBQUFnQzs7QUFFakVyQixHQUFDLENBQUNvQyxTQUFGLENBQVlyRSxTQUFTLEdBQUcsQ0FBeEI7QUFBMEI7QUFBMUIsSUFBc0MsQ0FBdEM7QUFDQWlDLEdBQUMsQ0FBQzhCLE9BQUYsR0FBWTlCLENBQUMsQ0FBQytCLFVBQUYsR0FBZSxDQUEzQjtBQUNBL0IsR0FBQyxDQUFDdUMsUUFBRixHQUFhdkMsQ0FBQyxDQUFDd0MsT0FBRixHQUFZLENBQXpCO0FBQ0Q7QUFHRDs7Ozs7QUFHQSxTQUFTQyxTQUFULENBQW1CekMsQ0FBbkIsRUFDQTtBQUNFLE1BQUlBLENBQUMsQ0FBQ00sUUFBRixHQUFhLENBQWpCLEVBQW9CO0FBQ2xCUCxhQUFTLENBQUNDLENBQUQsRUFBSUEsQ0FBQyxDQUFDTyxNQUFOLENBQVQ7QUFDRCxHQUZELE1BRU8sSUFBSVAsQ0FBQyxDQUFDTSxRQUFGLEdBQWEsQ0FBakIsRUFBb0I7QUFDekI7QUFDQU4sS0FBQyxDQUFDRSxXQUFGLENBQWNGLENBQUMsQ0FBQ0csT0FBRixFQUFkLElBQTZCSCxDQUFDLENBQUNPLE1BQS9CO0FBQ0Q7O0FBQ0RQLEdBQUMsQ0FBQ08sTUFBRixHQUFXLENBQVg7QUFDQVAsR0FBQyxDQUFDTSxRQUFGLEdBQWEsQ0FBYjtBQUNEO0FBRUQ7Ozs7OztBQUlBLFNBQVNvQyxVQUFULENBQW9CMUMsQ0FBcEIsRUFBdUJsRCxHQUF2QixFQUE0QkMsR0FBNUIsRUFBaUM0RixNQUFqQyxFQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRUYsV0FBUyxDQUFDekMsQ0FBRCxDQUFUO0FBQXFCOztBQUVyQixNQUFJMkMsTUFBSixFQUFZO0FBQ1Y1QyxhQUFTLENBQUNDLENBQUQsRUFBSWpELEdBQUosQ0FBVDtBQUNBZ0QsYUFBUyxDQUFDQyxDQUFELEVBQUksQ0FBQ2pELEdBQUwsQ0FBVDtBQUNELEdBTkgsQ0FPQTtBQUNBO0FBQ0E7OztBQUNFUCxPQUFLLENBQUNvRyxRQUFOLENBQWU1QyxDQUFDLENBQUNFLFdBQWpCLEVBQThCRixDQUFDLENBQUM2QyxNQUFoQyxFQUF3Qy9GLEdBQXhDLEVBQTZDQyxHQUE3QyxFQUFrRGlELENBQUMsQ0FBQ0csT0FBcEQ7QUFDQUgsR0FBQyxDQUFDRyxPQUFGLElBQWFwRCxHQUFiO0FBQ0Q7QUFFRDs7Ozs7O0FBSUEsU0FBUytGLE9BQVQsQ0FBaUJwQyxJQUFqQixFQUF1QlcsQ0FBdkIsRUFBMEJDLENBQTFCLEVBQTZCeUIsS0FBN0IsRUFBb0M7QUFDbEMsTUFBSUMsR0FBRyxHQUFHM0IsQ0FBQyxHQUFHLENBQWQ7O0FBQ0EsTUFBSTRCLEdBQUcsR0FBRzNCLENBQUMsR0FBRyxDQUFkOztBQUNBLFNBQVFaLElBQUksQ0FBQ3NDLEdBQUQ7QUFBSztBQUFULElBQXFCdEMsSUFBSSxDQUFDdUMsR0FBRDtBQUFLO0FBQTlCLEtBQ0F2QyxJQUFJLENBQUNzQyxHQUFEO0FBQUs7QUFBVCxNQUF1QnRDLElBQUksQ0FBQ3VDLEdBQUQ7QUFBSztBQUFoQyxLQUE2Q0YsS0FBSyxDQUFDMUIsQ0FBRCxDQUFMLElBQVkwQixLQUFLLENBQUN6QixDQUFELENBRHRFO0FBRUQ7QUFFRDs7Ozs7Ozs7QUFNQSxTQUFTNEIsVUFBVCxDQUFvQmxELENBQXBCLEVBQXVCVSxJQUF2QixFQUE2QnlDLENBQTdCLEVBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRSxNQUFJQyxDQUFDLEdBQUdwRCxDQUFDLENBQUM0QixJQUFGLENBQU91QixDQUFQLENBQVI7QUFDQSxNQUFJRSxDQUFDLEdBQUdGLENBQUMsSUFBSSxDQUFiO0FBQWlCOztBQUNqQixTQUFPRSxDQUFDLElBQUlyRCxDQUFDLENBQUNzRCxRQUFkLEVBQXdCO0FBQ3RCO0FBQ0EsUUFBSUQsQ0FBQyxHQUFHckQsQ0FBQyxDQUFDc0QsUUFBTixJQUNGUixPQUFPLENBQUNwQyxJQUFELEVBQU9WLENBQUMsQ0FBQzRCLElBQUYsQ0FBT3lCLENBQUMsR0FBRyxDQUFYLENBQVAsRUFBc0JyRCxDQUFDLENBQUM0QixJQUFGLENBQU95QixDQUFQLENBQXRCLEVBQWlDckQsQ0FBQyxDQUFDK0MsS0FBbkMsQ0FEVCxFQUNvRDtBQUNsRE0sT0FBQztBQUNGO0FBQ0Q7OztBQUNBLFFBQUlQLE9BQU8sQ0FBQ3BDLElBQUQsRUFBTzBDLENBQVAsRUFBVXBELENBQUMsQ0FBQzRCLElBQUYsQ0FBT3lCLENBQVAsQ0FBVixFQUFxQnJELENBQUMsQ0FBQytDLEtBQXZCLENBQVgsRUFBMEM7QUFBRTtBQUFRO0FBRXBEOzs7QUFDQS9DLEtBQUMsQ0FBQzRCLElBQUYsQ0FBT3VCLENBQVAsSUFBWW5ELENBQUMsQ0FBQzRCLElBQUYsQ0FBT3lCLENBQVAsQ0FBWjtBQUNBRixLQUFDLEdBQUdFLENBQUo7QUFFQTs7QUFDQUEsS0FBQyxLQUFLLENBQU47QUFDRDs7QUFDRHJELEdBQUMsQ0FBQzRCLElBQUYsQ0FBT3VCLENBQVAsSUFBWUMsQ0FBWjtBQUNELEMsQ0FHRDtBQUNBOztBQUVBOzs7OztBQUdBLFNBQVNHLGNBQVQsQ0FBd0J2RCxDQUF4QixFQUEyQndELEtBQTNCLEVBQWtDQyxLQUFsQyxFQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0UsTUFBSTNELElBQUo7QUFBb0I7O0FBQ3BCLE1BQUk0RCxFQUFKO0FBQW9COztBQUNwQixNQUFJQyxFQUFFLEdBQUcsQ0FBVDtBQUFvQjs7QUFDcEIsTUFBSS9DLElBQUo7QUFBb0I7O0FBQ3BCLE1BQUlNLEtBQUo7QUFBb0I7O0FBRXBCLE1BQUlsQixDQUFDLENBQUN1QyxRQUFGLEtBQWUsQ0FBbkIsRUFBc0I7QUFDcEIsT0FBRztBQUNEekMsVUFBSSxHQUFJRSxDQUFDLENBQUNFLFdBQUYsQ0FBY0YsQ0FBQyxDQUFDNEQsS0FBRixHQUFVRCxFQUFFLEdBQUcsQ0FBN0IsS0FBbUMsQ0FBcEMsR0FBMEMzRCxDQUFDLENBQUNFLFdBQUYsQ0FBY0YsQ0FBQyxDQUFDNEQsS0FBRixHQUFVRCxFQUFFLEdBQUcsQ0FBZixHQUFtQixDQUFqQyxDQUFqRDtBQUNBRCxRQUFFLEdBQUcxRCxDQUFDLENBQUNFLFdBQUYsQ0FBY0YsQ0FBQyxDQUFDNkQsS0FBRixHQUFVRixFQUF4QixDQUFMO0FBQ0FBLFFBQUU7O0FBRUYsVUFBSTdELElBQUksS0FBSyxDQUFiLEVBQWdCO0FBQ2RVLGlCQUFTLENBQUNSLENBQUQsRUFBSTBELEVBQUosRUFBUUYsS0FBUixDQUFUO0FBQXlCO0FBQ3pCO0FBQ0QsT0FIRCxNQUdPO0FBQ0w7QUFDQTVDLFlBQUksR0FBR2hDLFlBQVksQ0FBQzhFLEVBQUQsQ0FBbkI7QUFDQWxELGlCQUFTLENBQUNSLENBQUQsRUFBSVksSUFBSSxHQUFHckQsUUFBUCxHQUFrQixDQUF0QixFQUF5QmlHLEtBQXpCLENBQVQ7QUFBMEM7O0FBQzFDdEMsYUFBSyxHQUFHL0MsV0FBVyxDQUFDeUMsSUFBRCxDQUFuQjs7QUFDQSxZQUFJTSxLQUFLLEtBQUssQ0FBZCxFQUFpQjtBQUNmd0MsWUFBRSxJQUFJN0UsV0FBVyxDQUFDK0IsSUFBRCxDQUFqQjtBQUNBUixtQkFBUyxDQUFDSixDQUFELEVBQUkwRCxFQUFKLEVBQVF4QyxLQUFSLENBQVQ7QUFBK0I7QUFDaEM7O0FBQ0RwQixZQUFJO0FBQUk7O0FBQ1JjLFlBQUksR0FBR2YsTUFBTSxDQUFDQyxJQUFELENBQWIsQ0FWSyxDQVdMOztBQUVBVSxpQkFBUyxDQUFDUixDQUFELEVBQUlZLElBQUosRUFBVTZDLEtBQVYsQ0FBVDtBQUFpQzs7QUFDakN2QyxhQUFLLEdBQUc5QyxXQUFXLENBQUN3QyxJQUFELENBQW5COztBQUNBLFlBQUlNLEtBQUssS0FBSyxDQUFkLEVBQWlCO0FBQ2ZwQixjQUFJLElBQUloQixTQUFTLENBQUM4QixJQUFELENBQWpCO0FBQ0FSLG1CQUFTLENBQUNKLENBQUQsRUFBSUYsSUFBSixFQUFVb0IsS0FBVixDQUFUO0FBQTZCO0FBQzlCO0FBQ0Y7QUFBQzs7QUFFRjtBQUNBO0FBQ0E7O0FBRUQsS0FqQ0QsUUFpQ1N5QyxFQUFFLEdBQUczRCxDQUFDLENBQUN1QyxRQWpDaEI7QUFrQ0Q7O0FBRUQvQixXQUFTLENBQUNSLENBQUQsRUFBSWpDLFNBQUosRUFBZXlGLEtBQWYsQ0FBVDtBQUNEO0FBR0Q7Ozs7Ozs7Ozs7QUFRQSxTQUFTTSxVQUFULENBQW9COUQsQ0FBcEIsRUFBdUJnQixJQUF2QixFQUNBO0FBQ0E7QUFDQTtBQUNFLE1BQUlOLElBQUksR0FBT00sSUFBSSxDQUFDdEIsUUFBcEI7QUFDQSxNQUFJdUIsS0FBSyxHQUFNRCxJQUFJLENBQUNyQixTQUFMLENBQWVYLFdBQTlCO0FBQ0EsTUFBSUssU0FBUyxHQUFHMkIsSUFBSSxDQUFDckIsU0FBTCxDQUFlTixTQUEvQjtBQUNBLE1BQUlGLEtBQUssR0FBTTZCLElBQUksQ0FBQ3JCLFNBQUwsQ0FBZVIsS0FBOUI7QUFDQSxNQUFJa0MsQ0FBSixFQUFPQyxDQUFQO0FBQW1COztBQUNuQixNQUFJMUIsUUFBUSxHQUFHLENBQUMsQ0FBaEI7QUFBbUI7O0FBQ25CLE1BQUltRSxJQUFKO0FBQW1COztBQUVuQjs7Ozs7QUFJQS9ELEdBQUMsQ0FBQ3NELFFBQUYsR0FBYSxDQUFiO0FBQ0F0RCxHQUFDLENBQUM2QixRQUFGLEdBQWFsRSxTQUFiOztBQUVBLE9BQUswRCxDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUdsQyxLQUFoQixFQUF1QmtDLENBQUMsRUFBeEIsRUFBNEI7QUFDMUIsUUFBSVgsSUFBSSxDQUFDVyxDQUFDLEdBQUcsQ0FBTDtBQUFPO0FBQVgsUUFBeUIsQ0FBN0IsRUFBZ0M7QUFDOUJyQixPQUFDLENBQUM0QixJQUFGLENBQU8sRUFBRTVCLENBQUMsQ0FBQ3NELFFBQVgsSUFBdUIxRCxRQUFRLEdBQUd5QixDQUFsQztBQUNBckIsT0FBQyxDQUFDK0MsS0FBRixDQUFRMUIsQ0FBUixJQUFhLENBQWI7QUFFRCxLQUpELE1BSU87QUFDTFgsVUFBSSxDQUFDVyxDQUFDLEdBQUcsQ0FBSixHQUFRLENBQVQ7QUFBVztBQUFmLFFBQTBCLENBQTFCO0FBQ0Q7QUFDRjtBQUVEOzs7Ozs7O0FBS0EsU0FBT3JCLENBQUMsQ0FBQ3NELFFBQUYsR0FBYSxDQUFwQixFQUF1QjtBQUNyQlMsUUFBSSxHQUFHL0QsQ0FBQyxDQUFDNEIsSUFBRixDQUFPLEVBQUU1QixDQUFDLENBQUNzRCxRQUFYLElBQXdCMUQsUUFBUSxHQUFHLENBQVgsR0FBZSxFQUFFQSxRQUFqQixHQUE0QixDQUEzRDtBQUNBYyxRQUFJLENBQUNxRCxJQUFJLEdBQUcsQ0FBUjtBQUFVO0FBQWQsTUFBMEIsQ0FBMUI7QUFDQS9ELEtBQUMsQ0FBQytDLEtBQUYsQ0FBUWdCLElBQVIsSUFBZ0IsQ0FBaEI7QUFDQS9ELEtBQUMsQ0FBQzhCLE9BQUY7O0FBRUEsUUFBSXpDLFNBQUosRUFBZTtBQUNiVyxPQUFDLENBQUMrQixVQUFGLElBQWdCZCxLQUFLLENBQUM4QyxJQUFJLEdBQUcsQ0FBUCxHQUFXLENBQVo7QUFBYztBQUFuQztBQUNEO0FBQ0Q7O0FBQ0Q7O0FBQ0QvQyxNQUFJLENBQUNwQixRQUFMLEdBQWdCQSxRQUFoQjtBQUVBOzs7O0FBR0EsT0FBS3lCLENBQUMsR0FBSXJCLENBQUMsQ0FBQ3NELFFBQUYsSUFBYztBQUFDO0FBQXpCLElBQXNDakMsQ0FBQyxJQUFJLENBQTNDLEVBQThDQSxDQUFDLEVBQS9DLEVBQW1EO0FBQUU2QixjQUFVLENBQUNsRCxDQUFELEVBQUlVLElBQUosRUFBVVcsQ0FBVixDQUFWO0FBQXlCO0FBRTlFOzs7OztBQUdBMEMsTUFBSSxHQUFHNUUsS0FBUDtBQUEyQjs7QUFDM0IsS0FBRztBQUNEOztBQUNBO0FBQ0FrQyxLQUFDLEdBQUdyQixDQUFDLENBQUM0QixJQUFGLENBQU87QUFBQztBQUFSLEtBQUo7QUFDQTVCLEtBQUMsQ0FBQzRCLElBQUYsQ0FBTztBQUFDO0FBQVIsUUFBd0I1QixDQUFDLENBQUM0QixJQUFGLENBQU81QixDQUFDLENBQUNzRCxRQUFGLEVBQVAsQ0FBeEI7QUFDQUosY0FBVSxDQUFDbEQsQ0FBRCxFQUFJVSxJQUFKLEVBQVU7QUFBQztBQUFYLEtBQVY7QUFDQTs7QUFFQVksS0FBQyxHQUFHdEIsQ0FBQyxDQUFDNEIsSUFBRixDQUFPO0FBQUM7QUFBUixLQUFKO0FBQTJCOztBQUUzQjVCLEtBQUMsQ0FBQzRCLElBQUYsQ0FBTyxFQUFFNUIsQ0FBQyxDQUFDNkIsUUFBWCxJQUF1QlIsQ0FBdkI7QUFBMEI7O0FBQzFCckIsS0FBQyxDQUFDNEIsSUFBRixDQUFPLEVBQUU1QixDQUFDLENBQUM2QixRQUFYLElBQXVCUCxDQUF2QjtBQUVBOztBQUNBWixRQUFJLENBQUNxRCxJQUFJLEdBQUcsQ0FBUjtBQUFVO0FBQWQsTUFBMEJyRCxJQUFJLENBQUNXLENBQUMsR0FBRyxDQUFMO0FBQU87QUFBWCxNQUF1QlgsSUFBSSxDQUFDWSxDQUFDLEdBQUcsQ0FBTDtBQUFPO0FBQTVEO0FBQ0F0QixLQUFDLENBQUMrQyxLQUFGLENBQVFnQixJQUFSLElBQWdCLENBQUMvRCxDQUFDLENBQUMrQyxLQUFGLENBQVExQixDQUFSLEtBQWNyQixDQUFDLENBQUMrQyxLQUFGLENBQVF6QixDQUFSLENBQWQsR0FBMkJ0QixDQUFDLENBQUMrQyxLQUFGLENBQVExQixDQUFSLENBQTNCLEdBQXdDckIsQ0FBQyxDQUFDK0MsS0FBRixDQUFRekIsQ0FBUixDQUF6QyxJQUF1RCxDQUF2RTtBQUNBWixRQUFJLENBQUNXLENBQUMsR0FBRyxDQUFKLEdBQVEsQ0FBVDtBQUFXO0FBQWYsTUFBMEJYLElBQUksQ0FBQ1ksQ0FBQyxHQUFHLENBQUosR0FBUSxDQUFUO0FBQVc7QUFBZixNQUEwQnlDLElBQXBEO0FBRUE7O0FBQ0EvRCxLQUFDLENBQUM0QixJQUFGLENBQU87QUFBQztBQUFSLFFBQXdCbUMsSUFBSSxFQUE1QjtBQUNBYixjQUFVLENBQUNsRCxDQUFELEVBQUlVLElBQUosRUFBVTtBQUFDO0FBQVgsS0FBVjtBQUVELEdBdEJELFFBc0JTVixDQUFDLENBQUNzRCxRQUFGLElBQWMsQ0F0QnZCOztBQXdCQXRELEdBQUMsQ0FBQzRCLElBQUYsQ0FBTyxFQUFFNUIsQ0FBQyxDQUFDNkIsUUFBWCxJQUF1QjdCLENBQUMsQ0FBQzRCLElBQUYsQ0FBTztBQUFDO0FBQVIsR0FBdkI7QUFFQTs7OztBQUdBYixZQUFVLENBQUNmLENBQUQsRUFBSWdCLElBQUosQ0FBVjtBQUVBOztBQUNBZ0IsV0FBUyxDQUFDdEIsSUFBRCxFQUFPZCxRQUFQLEVBQWlCSSxDQUFDLENBQUMyQixRQUFuQixDQUFUO0FBQ0Q7QUFHRDs7Ozs7O0FBSUEsU0FBU3FDLFNBQVQsQ0FBbUJoRSxDQUFuQixFQUFzQlUsSUFBdEIsRUFBNEJkLFFBQTVCLEVBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRSxNQUFJeUIsQ0FBSjtBQUEyQjs7QUFDM0IsTUFBSTRDLE9BQU8sR0FBRyxDQUFDLENBQWY7QUFBMkI7O0FBQzNCLE1BQUlDLE1BQUo7QUFBMkI7O0FBRTNCLE1BQUlDLE9BQU8sR0FBR3pELElBQUksQ0FBQyxJQUFJLENBQUosR0FBUSxDQUFUO0FBQVc7QUFBN0I7QUFBdUM7O0FBRXZDLE1BQUkwRCxLQUFLLEdBQUcsQ0FBWjtBQUEyQjs7QUFDM0IsTUFBSUMsU0FBUyxHQUFHLENBQWhCO0FBQTJCOztBQUMzQixNQUFJQyxTQUFTLEdBQUcsQ0FBaEI7QUFBMkI7O0FBRTNCLE1BQUlILE9BQU8sS0FBSyxDQUFoQixFQUFtQjtBQUNqQkUsYUFBUyxHQUFHLEdBQVo7QUFDQUMsYUFBUyxHQUFHLENBQVo7QUFDRDs7QUFDRDVELE1BQUksQ0FBQyxDQUFDZCxRQUFRLEdBQUcsQ0FBWixJQUFpQixDQUFqQixHQUFxQixDQUF0QjtBQUF3QjtBQUE1QixJQUF1QyxNQUF2QztBQUErQzs7QUFFL0MsT0FBS3lCLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsSUFBSXpCLFFBQWpCLEVBQTJCeUIsQ0FBQyxFQUE1QixFQUFnQztBQUM5QjZDLFVBQU0sR0FBR0MsT0FBVDtBQUNBQSxXQUFPLEdBQUd6RCxJQUFJLENBQUMsQ0FBQ1csQ0FBQyxHQUFHLENBQUwsSUFBVSxDQUFWLEdBQWMsQ0FBZjtBQUFpQjtBQUEvQjs7QUFFQSxRQUFJLEVBQUUrQyxLQUFGLEdBQVVDLFNBQVYsSUFBdUJILE1BQU0sS0FBS0MsT0FBdEMsRUFBK0M7QUFDN0M7QUFFRCxLQUhELE1BR08sSUFBSUMsS0FBSyxHQUFHRSxTQUFaLEVBQXVCO0FBQzVCdEUsT0FBQyxDQUFDc0MsT0FBRixDQUFVNEIsTUFBTSxHQUFHLENBQW5CO0FBQXFCO0FBQXJCLFNBQWtDRSxLQUFsQztBQUVELEtBSE0sTUFHQSxJQUFJRixNQUFNLEtBQUssQ0FBZixFQUFrQjtBQUV2QixVQUFJQSxNQUFNLEtBQUtELE9BQWYsRUFBd0I7QUFBRWpFLFNBQUMsQ0FBQ3NDLE9BQUYsQ0FBVTRCLE1BQU0sR0FBRyxDQUFuQixFQUFxQixTQUFyQjtBQUFtQzs7QUFDN0RsRSxPQUFDLENBQUNzQyxPQUFGLENBQVV0RSxPQUFPLEdBQUcsQ0FBcEIsRUFBc0IsU0FBdEI7QUFFRCxLQUxNLE1BS0EsSUFBSW9HLEtBQUssSUFBSSxFQUFiLEVBQWlCO0FBQ3RCcEUsT0FBQyxDQUFDc0MsT0FBRixDQUFVckUsU0FBUyxHQUFHLENBQXRCLEVBQXdCLFNBQXhCO0FBRUQsS0FITSxNQUdBO0FBQ0wrQixPQUFDLENBQUNzQyxPQUFGLENBQVVwRSxXQUFXLEdBQUcsQ0FBeEIsRUFBMEIsU0FBMUI7QUFDRDs7QUFFRGtHLFNBQUssR0FBRyxDQUFSO0FBQ0FILFdBQU8sR0FBR0MsTUFBVjs7QUFFQSxRQUFJQyxPQUFPLEtBQUssQ0FBaEIsRUFBbUI7QUFDakJFLGVBQVMsR0FBRyxHQUFaO0FBQ0FDLGVBQVMsR0FBRyxDQUFaO0FBRUQsS0FKRCxNQUlPLElBQUlKLE1BQU0sS0FBS0MsT0FBZixFQUF3QjtBQUM3QkUsZUFBUyxHQUFHLENBQVo7QUFDQUMsZUFBUyxHQUFHLENBQVo7QUFFRCxLQUpNLE1BSUE7QUFDTEQsZUFBUyxHQUFHLENBQVo7QUFDQUMsZUFBUyxHQUFHLENBQVo7QUFDRDtBQUNGO0FBQ0Y7QUFHRDs7Ozs7O0FBSUEsU0FBU0MsU0FBVCxDQUFtQnZFLENBQW5CLEVBQXNCVSxJQUF0QixFQUE0QmQsUUFBNUIsRUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFLE1BQUl5QixDQUFKO0FBQTJCOztBQUMzQixNQUFJNEMsT0FBTyxHQUFHLENBQUMsQ0FBZjtBQUEyQjs7QUFDM0IsTUFBSUMsTUFBSjtBQUEyQjs7QUFFM0IsTUFBSUMsT0FBTyxHQUFHekQsSUFBSSxDQUFDLElBQUksQ0FBSixHQUFRLENBQVQ7QUFBVztBQUE3QjtBQUF1Qzs7QUFFdkMsTUFBSTBELEtBQUssR0FBRyxDQUFaO0FBQTJCOztBQUMzQixNQUFJQyxTQUFTLEdBQUcsQ0FBaEI7QUFBMkI7O0FBQzNCLE1BQUlDLFNBQVMsR0FBRyxDQUFoQjtBQUEyQjs7QUFFM0I7O0FBQWtDOztBQUNsQyxNQUFJSCxPQUFPLEtBQUssQ0FBaEIsRUFBbUI7QUFDakJFLGFBQVMsR0FBRyxHQUFaO0FBQ0FDLGFBQVMsR0FBRyxDQUFaO0FBQ0Q7O0FBRUQsT0FBS2pELENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsSUFBSXpCLFFBQWpCLEVBQTJCeUIsQ0FBQyxFQUE1QixFQUFnQztBQUM5QjZDLFVBQU0sR0FBR0MsT0FBVDtBQUNBQSxXQUFPLEdBQUd6RCxJQUFJLENBQUMsQ0FBQ1csQ0FBQyxHQUFHLENBQUwsSUFBVSxDQUFWLEdBQWMsQ0FBZjtBQUFpQjtBQUEvQjs7QUFFQSxRQUFJLEVBQUUrQyxLQUFGLEdBQVVDLFNBQVYsSUFBdUJILE1BQU0sS0FBS0MsT0FBdEMsRUFBK0M7QUFDN0M7QUFFRCxLQUhELE1BR08sSUFBSUMsS0FBSyxHQUFHRSxTQUFaLEVBQXVCO0FBQzVCLFNBQUc7QUFBRTlELGlCQUFTLENBQUNSLENBQUQsRUFBSWtFLE1BQUosRUFBWWxFLENBQUMsQ0FBQ3NDLE9BQWQsQ0FBVDtBQUFrQyxPQUF2QyxRQUErQyxFQUFFOEIsS0FBRixLQUFZLENBQTNEO0FBRUQsS0FITSxNQUdBLElBQUlGLE1BQU0sS0FBSyxDQUFmLEVBQWtCO0FBQ3ZCLFVBQUlBLE1BQU0sS0FBS0QsT0FBZixFQUF3QjtBQUN0QnpELGlCQUFTLENBQUNSLENBQUQsRUFBSWtFLE1BQUosRUFBWWxFLENBQUMsQ0FBQ3NDLE9BQWQsQ0FBVDtBQUNBOEIsYUFBSztBQUNOLE9BSnNCLENBS3ZCOzs7QUFDQTVELGVBQVMsQ0FBQ1IsQ0FBRCxFQUFJaEMsT0FBSixFQUFhZ0MsQ0FBQyxDQUFDc0MsT0FBZixDQUFUO0FBQ0FsQyxlQUFTLENBQUNKLENBQUQsRUFBSW9FLEtBQUssR0FBRyxDQUFaLEVBQWUsQ0FBZixDQUFUO0FBRUQsS0FUTSxNQVNBLElBQUlBLEtBQUssSUFBSSxFQUFiLEVBQWlCO0FBQ3RCNUQsZUFBUyxDQUFDUixDQUFELEVBQUkvQixTQUFKLEVBQWUrQixDQUFDLENBQUNzQyxPQUFqQixDQUFUO0FBQ0FsQyxlQUFTLENBQUNKLENBQUQsRUFBSW9FLEtBQUssR0FBRyxDQUFaLEVBQWUsQ0FBZixDQUFUO0FBRUQsS0FKTSxNQUlBO0FBQ0w1RCxlQUFTLENBQUNSLENBQUQsRUFBSTlCLFdBQUosRUFBaUI4QixDQUFDLENBQUNzQyxPQUFuQixDQUFUO0FBQ0FsQyxlQUFTLENBQUNKLENBQUQsRUFBSW9FLEtBQUssR0FBRyxFQUFaLEVBQWdCLENBQWhCLENBQVQ7QUFDRDs7QUFFREEsU0FBSyxHQUFHLENBQVI7QUFDQUgsV0FBTyxHQUFHQyxNQUFWOztBQUNBLFFBQUlDLE9BQU8sS0FBSyxDQUFoQixFQUFtQjtBQUNqQkUsZUFBUyxHQUFHLEdBQVo7QUFDQUMsZUFBUyxHQUFHLENBQVo7QUFFRCxLQUpELE1BSU8sSUFBSUosTUFBTSxLQUFLQyxPQUFmLEVBQXdCO0FBQzdCRSxlQUFTLEdBQUcsQ0FBWjtBQUNBQyxlQUFTLEdBQUcsQ0FBWjtBQUVELEtBSk0sTUFJQTtBQUNMRCxlQUFTLEdBQUcsQ0FBWjtBQUNBQyxlQUFTLEdBQUcsQ0FBWjtBQUNEO0FBQ0Y7QUFDRjtBQUdEOzs7Ozs7QUFJQSxTQUFTRSxhQUFULENBQXVCeEUsQ0FBdkIsRUFBMEI7QUFDeEIsTUFBSXlFLFdBQUo7QUFBa0I7O0FBRWxCOztBQUNBVCxXQUFTLENBQUNoRSxDQUFELEVBQUlBLENBQUMsQ0FBQ29DLFNBQU4sRUFBaUJwQyxDQUFDLENBQUMwRSxNQUFGLENBQVM5RSxRQUExQixDQUFUO0FBQ0FvRSxXQUFTLENBQUNoRSxDQUFELEVBQUlBLENBQUMsQ0FBQ3FDLFNBQU4sRUFBaUJyQyxDQUFDLENBQUMyRSxNQUFGLENBQVMvRSxRQUExQixDQUFUO0FBRUE7O0FBQ0FrRSxZQUFVLENBQUM5RCxDQUFELEVBQUlBLENBQUMsQ0FBQzRFLE9BQU4sQ0FBVjtBQUNBOzs7O0FBSUE7Ozs7O0FBSUEsT0FBS0gsV0FBVyxHQUFHL0csUUFBUSxHQUFHLENBQTlCLEVBQWlDK0csV0FBVyxJQUFJLENBQWhELEVBQW1EQSxXQUFXLEVBQTlELEVBQWtFO0FBQ2hFLFFBQUl6RSxDQUFDLENBQUNzQyxPQUFGLENBQVVoRSxRQUFRLENBQUNtRyxXQUFELENBQVIsR0FBd0IsQ0FBeEIsR0FBNEIsQ0FBdEM7QUFBd0M7QUFBeEMsUUFBcUQsQ0FBekQsRUFBNEQ7QUFDMUQ7QUFDRDtBQUNGO0FBQ0Q7OztBQUNBekUsR0FBQyxDQUFDOEIsT0FBRixJQUFhLEtBQUsyQyxXQUFXLEdBQUcsQ0FBbkIsSUFBd0IsQ0FBeEIsR0FBNEIsQ0FBNUIsR0FBZ0MsQ0FBN0MsQ0F2QndCLENBd0J4QjtBQUNBOztBQUVBLFNBQU9BLFdBQVA7QUFDRDtBQUdEOzs7Ozs7O0FBS0EsU0FBU0ksY0FBVCxDQUF3QjdFLENBQXhCLEVBQTJCOEUsTUFBM0IsRUFBbUNDLE1BQW5DLEVBQTJDQyxPQUEzQyxFQUNBO0FBQ0E7QUFDQTtBQUNFLE1BQUlDLElBQUo7QUFBNkI7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E3RSxXQUFTLENBQUNKLENBQUQsRUFBSThFLE1BQU0sR0FBRyxHQUFiLEVBQWtCLENBQWxCLENBQVQ7QUFBK0I7O0FBQy9CMUUsV0FBUyxDQUFDSixDQUFELEVBQUkrRSxNQUFNLEdBQUcsQ0FBYixFQUFrQixDQUFsQixDQUFUO0FBQ0EzRSxXQUFTLENBQUNKLENBQUQsRUFBSWdGLE9BQU8sR0FBRyxDQUFkLEVBQWtCLENBQWxCLENBQVQ7QUFBK0I7O0FBQy9CLE9BQUtDLElBQUksR0FBRyxDQUFaLEVBQWVBLElBQUksR0FBR0QsT0FBdEIsRUFBK0JDLElBQUksRUFBbkMsRUFBdUM7QUFDckM7QUFDQTdFLGFBQVMsQ0FBQ0osQ0FBRCxFQUFJQSxDQUFDLENBQUNzQyxPQUFGLENBQVVoRSxRQUFRLENBQUMyRyxJQUFELENBQVIsR0FBaUIsQ0FBakIsR0FBcUIsQ0FBL0I7QUFBaUM7QUFBckMsTUFBK0MsQ0FBL0MsQ0FBVDtBQUNELEdBYkgsQ0FjRTs7O0FBRUFWLFdBQVMsQ0FBQ3ZFLENBQUQsRUFBSUEsQ0FBQyxDQUFDb0MsU0FBTixFQUFpQjBDLE1BQU0sR0FBRyxDQUExQixDQUFUO0FBQXVDO0FBQ3ZDOztBQUVBUCxXQUFTLENBQUN2RSxDQUFELEVBQUlBLENBQUMsQ0FBQ3FDLFNBQU4sRUFBaUIwQyxNQUFNLEdBQUcsQ0FBMUIsQ0FBVDtBQUF1QztBQUN2QztBQUNEO0FBR0Q7Ozs7Ozs7Ozs7Ozs7OztBQWFBLFNBQVNHLGdCQUFULENBQTBCbEYsQ0FBMUIsRUFBNkI7QUFDM0I7Ozs7QUFJQSxNQUFJbUYsVUFBVSxHQUFHLFVBQWpCO0FBQ0EsTUFBSTlELENBQUo7QUFFQTs7QUFDQSxPQUFLQSxDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLElBQUksRUFBakIsRUFBcUJBLENBQUMsSUFBSThELFVBQVUsTUFBTSxDQUExQyxFQUE2QztBQUMzQyxRQUFLQSxVQUFVLEdBQUcsQ0FBZCxJQUFxQm5GLENBQUMsQ0FBQ29DLFNBQUYsQ0FBWWYsQ0FBQyxHQUFHLENBQWhCO0FBQWtCO0FBQWxCLFFBQWdDLENBQXpELEVBQTZEO0FBQzNELGFBQU8zRSxRQUFQO0FBQ0Q7QUFDRjtBQUVEOzs7QUFDQSxNQUFJc0QsQ0FBQyxDQUFDb0MsU0FBRixDQUFZLElBQUksQ0FBaEI7QUFBa0I7QUFBbEIsTUFBZ0MsQ0FBaEMsSUFBcUNwQyxDQUFDLENBQUNvQyxTQUFGLENBQVksS0FBSyxDQUFqQjtBQUFtQjtBQUFuQixNQUFpQyxDQUF0RSxJQUNBcEMsQ0FBQyxDQUFDb0MsU0FBRixDQUFZLEtBQUssQ0FBakI7QUFBbUI7QUFBbkIsTUFBaUMsQ0FEckMsRUFDd0M7QUFDdEMsV0FBT3pGLE1BQVA7QUFDRDs7QUFDRCxPQUFLMEUsQ0FBQyxHQUFHLEVBQVQsRUFBYUEsQ0FBQyxHQUFHOUQsUUFBakIsRUFBMkI4RCxDQUFDLEVBQTVCLEVBQWdDO0FBQzlCLFFBQUlyQixDQUFDLENBQUNvQyxTQUFGLENBQVlmLENBQUMsR0FBRyxDQUFoQjtBQUFrQjtBQUFsQixRQUFnQyxDQUFwQyxFQUF1QztBQUNyQyxhQUFPMUUsTUFBUDtBQUNEO0FBQ0Y7QUFFRDs7Ozs7QUFHQSxTQUFPRCxRQUFQO0FBQ0Q7O0FBR0QsSUFBSTBJLGdCQUFnQixHQUFHLEtBQXZCO0FBRUE7Ozs7QUFHQSxTQUFTQyxRQUFULENBQWtCckYsQ0FBbEIsRUFDQTtBQUVFLE1BQUksQ0FBQ29GLGdCQUFMLEVBQXVCO0FBQ3JCbEQsa0JBQWM7QUFDZGtELG9CQUFnQixHQUFHLElBQW5CO0FBQ0Q7O0FBRURwRixHQUFDLENBQUMwRSxNQUFGLEdBQVksSUFBSWpGLFFBQUosQ0FBYU8sQ0FBQyxDQUFDb0MsU0FBZixFQUEwQjlDLGFBQTFCLENBQVo7QUFDQVUsR0FBQyxDQUFDMkUsTUFBRixHQUFZLElBQUlsRixRQUFKLENBQWFPLENBQUMsQ0FBQ3FDLFNBQWYsRUFBMEI5QyxhQUExQixDQUFaO0FBQ0FTLEdBQUMsQ0FBQzRFLE9BQUYsR0FBWSxJQUFJbkYsUUFBSixDQUFhTyxDQUFDLENBQUNzQyxPQUFmLEVBQXdCOUMsY0FBeEIsQ0FBWjtBQUVBUSxHQUFDLENBQUNPLE1BQUYsR0FBVyxDQUFYO0FBQ0FQLEdBQUMsQ0FBQ00sUUFBRixHQUFhLENBQWI7QUFFQTs7QUFDQTZCLFlBQVUsQ0FBQ25DLENBQUQsQ0FBVjtBQUNEO0FBR0Q7Ozs7O0FBR0EsU0FBU3NGLGdCQUFULENBQTBCdEYsQ0FBMUIsRUFBNkJsRCxHQUE3QixFQUFrQ3lJLFVBQWxDLEVBQThDQyxJQUE5QyxFQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRXBGLFdBQVMsQ0FBQ0osQ0FBRCxFQUFJLENBQUMvQyxZQUFZLElBQUksQ0FBakIsS0FBdUJ1SSxJQUFJLEdBQUcsQ0FBSCxHQUFPLENBQWxDLENBQUosRUFBMEMsQ0FBMUMsQ0FBVDtBQUEwRDs7QUFDMUQ5QyxZQUFVLENBQUMxQyxDQUFELEVBQUlsRCxHQUFKLEVBQVN5SSxVQUFULEVBQXFCLElBQXJCLENBQVY7QUFBc0M7QUFDdkM7QUFHRDs7Ozs7O0FBSUEsU0FBU0UsU0FBVCxDQUFtQnpGLENBQW5CLEVBQXNCO0FBQ3BCSSxXQUFTLENBQUNKLENBQUQsRUFBSTlDLFlBQVksSUFBSSxDQUFwQixFQUF1QixDQUF2QixDQUFUO0FBQ0FzRCxXQUFTLENBQUNSLENBQUQsRUFBSWpDLFNBQUosRUFBZVMsWUFBZixDQUFUO0FBQ0FzQyxVQUFRLENBQUNkLENBQUQsQ0FBUjtBQUNEO0FBR0Q7Ozs7OztBQUlBLFNBQVMwRixlQUFULENBQXlCMUYsQ0FBekIsRUFBNEJsRCxHQUE1QixFQUFpQ3lJLFVBQWpDLEVBQTZDQyxJQUE3QyxFQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRSxNQUFJRyxRQUFKLEVBQWNDLFdBQWQ7QUFBNEI7O0FBQzVCLE1BQUluQixXQUFXLEdBQUcsQ0FBbEI7QUFBNEI7O0FBRTVCOztBQUNBLE1BQUl6RSxDQUFDLENBQUM2RixLQUFGLEdBQVUsQ0FBZCxFQUFpQjtBQUVmO0FBQ0EsUUFBSTdGLENBQUMsQ0FBQzhGLElBQUYsQ0FBT0MsU0FBUCxLQUFxQm5KLFNBQXpCLEVBQW9DO0FBQ2xDb0QsT0FBQyxDQUFDOEYsSUFBRixDQUFPQyxTQUFQLEdBQW1CYixnQkFBZ0IsQ0FBQ2xGLENBQUQsQ0FBbkM7QUFDRDtBQUVEOzs7QUFDQThELGNBQVUsQ0FBQzlELENBQUQsRUFBSUEsQ0FBQyxDQUFDMEUsTUFBTixDQUFWLENBUmUsQ0FTZjtBQUNBOztBQUVBWixjQUFVLENBQUM5RCxDQUFELEVBQUlBLENBQUMsQ0FBQzJFLE1BQU4sQ0FBVixDQVplLENBYWY7QUFDQTs7QUFDQTs7OztBQUlBOzs7O0FBR0FGLGVBQVcsR0FBR0QsYUFBYSxDQUFDeEUsQ0FBRCxDQUEzQjtBQUVBOztBQUNBMkYsWUFBUSxHQUFJM0YsQ0FBQyxDQUFDOEIsT0FBRixHQUFZLENBQVosR0FBZ0IsQ0FBakIsS0FBd0IsQ0FBbkM7QUFDQThELGVBQVcsR0FBSTVGLENBQUMsQ0FBQytCLFVBQUYsR0FBZSxDQUFmLEdBQW1CLENBQXBCLEtBQTJCLENBQXpDLENBMUJlLENBNEJmO0FBQ0E7QUFDQTs7QUFFQSxRQUFJNkQsV0FBVyxJQUFJRCxRQUFuQixFQUE2QjtBQUFFQSxjQUFRLEdBQUdDLFdBQVg7QUFBeUI7QUFFekQsR0FsQ0QsTUFrQ087QUFDTDtBQUNBRCxZQUFRLEdBQUdDLFdBQVcsR0FBR0wsVUFBVSxHQUFHLENBQXRDO0FBQXlDO0FBQzFDOztBQUVELE1BQUtBLFVBQVUsR0FBRyxDQUFiLElBQWtCSSxRQUFuQixJQUFpQzdJLEdBQUcsS0FBSyxDQUFDLENBQTlDLEVBQWtEO0FBQ2hEOztBQUVBOzs7Ozs7QUFNQXdJLG9CQUFnQixDQUFDdEYsQ0FBRCxFQUFJbEQsR0FBSixFQUFTeUksVUFBVCxFQUFxQkMsSUFBckIsQ0FBaEI7QUFFRCxHQVhELE1BV08sSUFBSXhGLENBQUMsQ0FBQ2dHLFFBQUYsS0FBZXZKLE9BQWYsSUFBMEJtSixXQUFXLEtBQUtELFFBQTlDLEVBQXdEO0FBRTdEdkYsYUFBUyxDQUFDSixDQUFELEVBQUksQ0FBQzlDLFlBQVksSUFBSSxDQUFqQixLQUF1QnNJLElBQUksR0FBRyxDQUFILEdBQU8sQ0FBbEMsQ0FBSixFQUEwQyxDQUExQyxDQUFUO0FBQ0FqQyxrQkFBYyxDQUFDdkQsQ0FBRCxFQUFJeEIsWUFBSixFQUFrQkUsWUFBbEIsQ0FBZDtBQUVELEdBTE0sTUFLQTtBQUNMMEIsYUFBUyxDQUFDSixDQUFELEVBQUksQ0FBQzdDLFNBQVMsSUFBSSxDQUFkLEtBQW9CcUksSUFBSSxHQUFHLENBQUgsR0FBTyxDQUEvQixDQUFKLEVBQXVDLENBQXZDLENBQVQ7QUFDQVgsa0JBQWMsQ0FBQzdFLENBQUQsRUFBSUEsQ0FBQyxDQUFDMEUsTUFBRixDQUFTOUUsUUFBVCxHQUFvQixDQUF4QixFQUEyQkksQ0FBQyxDQUFDMkUsTUFBRixDQUFTL0UsUUFBVCxHQUFvQixDQUEvQyxFQUFrRDZFLFdBQVcsR0FBRyxDQUFoRSxDQUFkO0FBQ0FsQixrQkFBYyxDQUFDdkQsQ0FBRCxFQUFJQSxDQUFDLENBQUNvQyxTQUFOLEVBQWlCcEMsQ0FBQyxDQUFDcUMsU0FBbkIsQ0FBZDtBQUNELEdBaEVILENBaUVFOztBQUNBOzs7OztBQUdBRixZQUFVLENBQUNuQyxDQUFELENBQVY7O0FBRUEsTUFBSXdGLElBQUosRUFBVTtBQUNSL0MsYUFBUyxDQUFDekMsQ0FBRCxDQUFUO0FBQ0QsR0F6RUgsQ0EwRUU7QUFDQTs7QUFDRDtBQUVEOzs7Ozs7QUFJQSxTQUFTaUcsU0FBVCxDQUFtQmpHLENBQW5CLEVBQXNCRixJQUF0QixFQUE0QjRELEVBQTVCLEVBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUVBMUQsR0FBQyxDQUFDRSxXQUFGLENBQWNGLENBQUMsQ0FBQzRELEtBQUYsR0FBVTVELENBQUMsQ0FBQ3VDLFFBQUYsR0FBYSxDQUFyQyxJQUErQ3pDLElBQUksS0FBSyxDQUFWLEdBQWUsSUFBN0Q7QUFDQUUsR0FBQyxDQUFDRSxXQUFGLENBQWNGLENBQUMsQ0FBQzRELEtBQUYsR0FBVTVELENBQUMsQ0FBQ3VDLFFBQUYsR0FBYSxDQUF2QixHQUEyQixDQUF6QyxJQUE4Q3pDLElBQUksR0FBRyxJQUFyRDtBQUVBRSxHQUFDLENBQUNFLFdBQUYsQ0FBY0YsQ0FBQyxDQUFDNkQsS0FBRixHQUFVN0QsQ0FBQyxDQUFDdUMsUUFBMUIsSUFBc0NtQixFQUFFLEdBQUcsSUFBM0M7QUFDQTFELEdBQUMsQ0FBQ3VDLFFBQUY7O0FBRUEsTUFBSXpDLElBQUksS0FBSyxDQUFiLEVBQWdCO0FBQ2Q7QUFDQUUsS0FBQyxDQUFDb0MsU0FBRixDQUFZc0IsRUFBRSxHQUFHLENBQWpCLEVBQW1CLFNBQW5CO0FBQ0QsR0FIRCxNQUdPO0FBQ0wxRCxLQUFDLENBQUN3QyxPQUFGO0FBQ0E7O0FBQ0ExQyxRQUFJO0FBQWdCO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQUUsS0FBQyxDQUFDb0MsU0FBRixDQUFZLENBQUN4RCxZQUFZLENBQUM4RSxFQUFELENBQVosR0FBbUJuRyxRQUFuQixHQUE4QixDQUEvQixJQUFvQyxDQUFoRCxFQUFrRCxTQUFsRDtBQUNBeUMsS0FBQyxDQUFDcUMsU0FBRixDQUFZeEMsTUFBTSxDQUFDQyxJQUFELENBQU4sR0FBZSxDQUEzQixFQUE2QixTQUE3QjtBQUNELEdBdEJILENBd0JBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUUsU0FBUUUsQ0FBQyxDQUFDdUMsUUFBRixLQUFldkMsQ0FBQyxDQUFDa0csV0FBRixHQUFnQixDQUF2QztBQUNBOzs7O0FBSUQ7O0FBRURDLE9BQU8sQ0FBQ2QsUUFBUixHQUFvQkEsUUFBcEI7QUFDQWMsT0FBTyxDQUFDYixnQkFBUixHQUEyQkEsZ0JBQTNCO0FBQ0FhLE9BQU8sQ0FBQ1QsZUFBUixHQUEyQkEsZUFBM0I7QUFDQVMsT0FBTyxDQUFDRixTQUFSLEdBQW9CQSxTQUFwQjtBQUNBRSxPQUFPLENBQUNWLFNBQVIsR0FBb0JBLFNBQXBCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvdHJlZXMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8vdmFyIFpfRklMVEVSRUQgICAgICAgICAgPSAxO1xuLy92YXIgWl9IVUZGTUFOX09OTFkgICAgICA9IDI7XG4vL3ZhciBaX1JMRSAgICAgICAgICAgICAgID0gMztcbnZhciBaX0ZJWEVEICAgICAgICAgICAgICAgPSA0O1xuLy92YXIgWl9ERUZBVUxUX1NUUkFURUdZICA9IDA7XG5cbi8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbnZhciBaX0JJTkFSWSAgICAgICAgICAgICAgPSAwO1xudmFyIFpfVEVYVCAgICAgICAgICAgICAgICA9IDE7XG4vL3ZhciBaX0FTQ0lJICAgICAgICAgICAgID0gMTsgLy8gPSBaX1RFWFRcbnZhciBaX1VOS05PV04gICAgICAgICAgICAgPSAyO1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbmZ1bmN0aW9uIHplcm8oYnVmKSB7IHZhciBsZW4gPSBidWYubGVuZ3RoOyB3aGlsZSAoLS1sZW4gPj0gMCkgeyBidWZbbGVuXSA9IDA7IH0gfVxuXG4vLyBGcm9tIHp1dGlsLmhcblxudmFyIFNUT1JFRF9CTE9DSyA9IDA7XG52YXIgU1RBVElDX1RSRUVTID0gMTtcbnZhciBEWU5fVFJFRVMgICAgPSAyO1xuLyogVGhlIHRocmVlIGtpbmRzIG9mIGJsb2NrIHR5cGUgKi9cblxudmFyIE1JTl9NQVRDSCAgICA9IDM7XG52YXIgTUFYX01BVENIICAgID0gMjU4O1xuLyogVGhlIG1pbmltdW0gYW5kIG1heGltdW0gbWF0Y2ggbGVuZ3RocyAqL1xuXG4vLyBGcm9tIGRlZmxhdGUuaFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbnRlcm5hbCBjb21wcmVzc2lvbiBzdGF0ZS5cbiAqL1xuXG52YXIgTEVOR1RIX0NPREVTICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG5cbnZhciBMSVRFUkFMUyAgICAgID0gMjU2O1xuLyogbnVtYmVyIG9mIGxpdGVyYWwgYnl0ZXMgMC4uMjU1ICovXG5cbnZhciBMX0NPREVTICAgICAgID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG5cbnZhciBEX0NPREVTICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cblxudmFyIEJMX0NPREVTICAgICAgPSAxOTtcbi8qIG51bWJlciBvZiBjb2RlcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSBiaXQgbGVuZ3RocyAqL1xuXG52YXIgSEVBUF9TSVpFICAgICA9IDIgKiBMX0NPREVTICsgMTtcbi8qIG1heGltdW0gaGVhcCBzaXplICovXG5cbnZhciBNQVhfQklUUyAgICAgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxudmFyIEJ1Zl9zaXplICAgICAgPSAxNjtcbi8qIHNpemUgb2YgYml0IGJ1ZmZlciBpbiBiaV9idWYgKi9cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0YW50c1xuICovXG5cbnZhciBNQVhfQkxfQklUUyA9IDc7XG4vKiBCaXQgbGVuZ3RoIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQkxfQklUUyBiaXRzICovXG5cbnZhciBFTkRfQkxPQ0sgICA9IDI1Njtcbi8qIGVuZCBvZiBibG9jayBsaXRlcmFsIGNvZGUgKi9cblxudmFyIFJFUF8zXzYgICAgID0gMTY7XG4vKiByZXBlYXQgcHJldmlvdXMgYml0IGxlbmd0aCAzLTYgdGltZXMgKDIgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbnZhciBSRVBaXzNfMTAgICA9IDE3O1xuLyogcmVwZWF0IGEgemVybyBsZW5ndGggMy0xMCB0aW1lcyAgKDMgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbnZhciBSRVBaXzExXzEzOCA9IDE4O1xuLyogcmVwZWF0IGEgemVybyBsZW5ndGggMTEtMTM4IHRpbWVzICAoNyBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxuLyogZXNsaW50LWRpc2FibGUgY29tbWEtc3BhY2luZyxhcnJheS1icmFja2V0LXNwYWNpbmcgKi9cbnZhciBleHRyYV9sYml0cyA9ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBsZW5ndGggY29kZSAqL1xuICBbMCwwLDAsMCwwLDAsMCwwLDEsMSwxLDEsMiwyLDIsMiwzLDMsMywzLDQsNCw0LDQsNSw1LDUsNSwwXTtcblxudmFyIGV4dHJhX2RiaXRzID0gICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGRpc3RhbmNlIGNvZGUgKi9cbiAgWzAsMCwwLDAsMSwxLDIsMiwzLDMsNCw0LDUsNSw2LDYsNyw3LDgsOCw5LDksMTAsMTAsMTEsMTEsMTIsMTIsMTMsMTNdO1xuXG52YXIgZXh0cmFfYmxiaXRzID0gIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggYml0IGxlbmd0aCBjb2RlICovXG4gIFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDIsMyw3XTtcblxudmFyIGJsX29yZGVyID1cbiAgWzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdO1xuLyogZXNsaW50LWVuYWJsZSBjb21tYS1zcGFjaW5nLGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xuXG4vKiBUaGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcyBhcmUgc2VudCBpbiBvcmRlciBvZiBkZWNyZWFzaW5nXG4gKiBwcm9iYWJpbGl0eSwgdG8gYXZvaWQgdHJhbnNtaXR0aW5nIHRoZSBsZW5ndGhzIGZvciB1bnVzZWQgYml0IGxlbmd0aCBjb2Rlcy5cbiAqL1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIExvY2FsIGRhdGEuIFRoZXNlIGFyZSBpbml0aWFsaXplZCBvbmx5IG9uY2UuXG4gKi9cblxuLy8gV2UgcHJlLWZpbGwgYXJyYXlzIHdpdGggMCB0byBhdm9pZCB1bmluaXRpYWxpemVkIGdhcHNcblxudmFyIERJU1RfQ09ERV9MRU4gPSA1MTI7IC8qIHNlZSBkZWZpbml0aW9uIG9mIGFycmF5IGRpc3RfY29kZSBiZWxvdyAqL1xuXG4vLyAhISEhIFVzZSBmbGF0IGFycmF5IGluc3RlYWQgb2Ygc3RydWN0dXJlLCBGcmVxID0gaSoyLCBMZW4gPSBpKjIrMVxudmFyIHN0YXRpY19sdHJlZSAgPSBuZXcgQXJyYXkoKExfQ09ERVMgKyAyKSAqIDIpO1xuemVybyhzdGF0aWNfbHRyZWUpO1xuLyogVGhlIHN0YXRpYyBsaXRlcmFsIHRyZWUuIFNpbmNlIHRoZSBiaXQgbGVuZ3RocyBhcmUgaW1wb3NlZCwgdGhlcmUgaXMgbm9cbiAqIG5lZWQgZm9yIHRoZSBMX0NPREVTIGV4dHJhIGNvZGVzIHVzZWQgZHVyaW5nIGhlYXAgY29uc3RydWN0aW9uLiBIb3dldmVyXG4gKiBUaGUgY29kZXMgMjg2IGFuZCAyODcgYXJlIG5lZWRlZCB0byBidWlsZCBhIGNhbm9uaWNhbCB0cmVlIChzZWUgX3RyX2luaXRcbiAqIGJlbG93KS5cbiAqL1xuXG52YXIgc3RhdGljX2R0cmVlICA9IG5ldyBBcnJheShEX0NPREVTICogMik7XG56ZXJvKHN0YXRpY19kdHJlZSk7XG4vKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUuIChBY3R1YWxseSBhIHRyaXZpYWwgdHJlZSBzaW5jZSBhbGwgY29kZXMgdXNlXG4gKiA1IGJpdHMuKVxuICovXG5cbnZhciBfZGlzdF9jb2RlICAgID0gbmV3IEFycmF5KERJU1RfQ09ERV9MRU4pO1xuemVybyhfZGlzdF9jb2RlKTtcbi8qIERpc3RhbmNlIGNvZGVzLiBUaGUgZmlyc3QgMjU2IHZhbHVlcyBjb3JyZXNwb25kIHRvIHRoZSBkaXN0YW5jZXNcbiAqIDMgLi4gMjU4LCB0aGUgbGFzdCAyNTYgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIHRvcCA4IGJpdHMgb2ZcbiAqIHRoZSAxNSBiaXQgZGlzdGFuY2VzLlxuICovXG5cbnZhciBfbGVuZ3RoX2NvZGUgID0gbmV3IEFycmF5KE1BWF9NQVRDSCAtIE1JTl9NQVRDSCArIDEpO1xuemVybyhfbGVuZ3RoX2NvZGUpO1xuLyogbGVuZ3RoIGNvZGUgZm9yIGVhY2ggbm9ybWFsaXplZCBtYXRjaCBsZW5ndGggKDAgPT0gTUlOX01BVENIKSAqL1xuXG52YXIgYmFzZV9sZW5ndGggICA9IG5ldyBBcnJheShMRU5HVEhfQ09ERVMpO1xuemVybyhiYXNlX2xlbmd0aCk7XG4vKiBGaXJzdCBub3JtYWxpemVkIGxlbmd0aCBmb3IgZWFjaCBjb2RlICgwID0gTUlOX01BVENIKSAqL1xuXG52YXIgYmFzZV9kaXN0ICAgICA9IG5ldyBBcnJheShEX0NPREVTKTtcbnplcm8oYmFzZV9kaXN0KTtcbi8qIEZpcnN0IG5vcm1hbGl6ZWQgZGlzdGFuY2UgZm9yIGVhY2ggY29kZSAoMCA9IGRpc3RhbmNlIG9mIDEpICovXG5cblxuZnVuY3Rpb24gU3RhdGljVHJlZURlc2Moc3RhdGljX3RyZWUsIGV4dHJhX2JpdHMsIGV4dHJhX2Jhc2UsIGVsZW1zLCBtYXhfbGVuZ3RoKSB7XG5cbiAgdGhpcy5zdGF0aWNfdHJlZSAgPSBzdGF0aWNfdHJlZTsgIC8qIHN0YXRpYyB0cmVlIG9yIE5VTEwgKi9cbiAgdGhpcy5leHRyYV9iaXRzICAgPSBleHRyYV9iaXRzOyAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggY29kZSBvciBOVUxMICovXG4gIHRoaXMuZXh0cmFfYmFzZSAgID0gZXh0cmFfYmFzZTsgICAvKiBiYXNlIGluZGV4IGZvciBleHRyYV9iaXRzICovXG4gIHRoaXMuZWxlbXMgICAgICAgID0gZWxlbXM7ICAgICAgICAvKiBtYXggbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSB0cmVlICovXG4gIHRoaXMubWF4X2xlbmd0aCAgID0gbWF4X2xlbmd0aDsgICAvKiBtYXggYml0IGxlbmd0aCBmb3IgdGhlIGNvZGVzICovXG5cbiAgLy8gc2hvdyBpZiBgc3RhdGljX3RyZWVgIGhhcyBkYXRhIG9yIGR1bW15IC0gbmVlZGVkIGZvciBtb25vbW9ycGhpYyBvYmplY3RzXG4gIHRoaXMuaGFzX3N0cmVlICAgID0gc3RhdGljX3RyZWUgJiYgc3RhdGljX3RyZWUubGVuZ3RoO1xufVxuXG5cbnZhciBzdGF0aWNfbF9kZXNjO1xudmFyIHN0YXRpY19kX2Rlc2M7XG52YXIgc3RhdGljX2JsX2Rlc2M7XG5cblxuZnVuY3Rpb24gVHJlZURlc2MoZHluX3RyZWUsIHN0YXRfZGVzYykge1xuICB0aGlzLmR5bl90cmVlID0gZHluX3RyZWU7ICAgICAvKiB0aGUgZHluYW1pYyB0cmVlICovXG4gIHRoaXMubWF4X2NvZGUgPSAwOyAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuICB0aGlzLnN0YXRfZGVzYyA9IHN0YXRfZGVzYzsgICAvKiB0aGUgY29ycmVzcG9uZGluZyBzdGF0aWMgdHJlZSAqL1xufVxuXG5cblxuZnVuY3Rpb24gZF9jb2RlKGRpc3QpIHtcbiAgcmV0dXJuIGRpc3QgPCAyNTYgPyBfZGlzdF9jb2RlW2Rpc3RdIDogX2Rpc3RfY29kZVsyNTYgKyAoZGlzdCA+Pj4gNyldO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogT3V0cHV0IGEgc2hvcnQgTFNCIGZpcnN0IG9uIHRoZSBzdHJlYW0uXG4gKiBJTiBhc3NlcnRpb246IHRoZXJlIGlzIGVub3VnaCByb29tIGluIHBlbmRpbmdCdWYuXG4gKi9cbmZ1bmN0aW9uIHB1dF9zaG9ydChzLCB3KSB7XG4vLyAgICBwdXRfYnl0ZShzLCAodWNoKSgodykgJiAweGZmKSk7XG4vLyAgICBwdXRfYnl0ZShzLCAodWNoKSgodXNoKSh3KSA+PiA4KSk7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKHcpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAodyA+Pj4gOCkgJiAweGZmO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIHZhbHVlIG9uIGEgZ2l2ZW4gbnVtYmVyIG9mIGJpdHMuXG4gKiBJTiBhc3NlcnRpb246IGxlbmd0aCA8PSAxNiBhbmQgdmFsdWUgZml0cyBpbiBsZW5ndGggYml0cy5cbiAqL1xuZnVuY3Rpb24gc2VuZF9iaXRzKHMsIHZhbHVlLCBsZW5ndGgpIHtcbiAgaWYgKHMuYmlfdmFsaWQgPiAoQnVmX3NpemUgLSBsZW5ndGgpKSB7XG4gICAgcy5iaV9idWYgfD0gKHZhbHVlIDw8IHMuYmlfdmFsaWQpICYgMHhmZmZmO1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gICAgcy5iaV9idWYgPSB2YWx1ZSA+PiAoQnVmX3NpemUgLSBzLmJpX3ZhbGlkKTtcbiAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aCAtIEJ1Zl9zaXplO1xuICB9IGVsc2Uge1xuICAgIHMuYmlfYnVmIHw9ICh2YWx1ZSA8PCBzLmJpX3ZhbGlkKSAmIDB4ZmZmZjtcbiAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aDtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHNlbmRfY29kZShzLCBjLCB0cmVlKSB7XG4gIHNlbmRfYml0cyhzLCB0cmVlW2MgKiAyXS8qLkNvZGUqLywgdHJlZVtjICogMiArIDFdLyouTGVuKi8pO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmV2ZXJzZSB0aGUgZmlyc3QgbGVuIGJpdHMgb2YgYSBjb2RlLCB1c2luZyBzdHJhaWdodGZvcndhcmQgY29kZSAoYSBmYXN0ZXJcbiAqIG1ldGhvZCB3b3VsZCB1c2UgYSB0YWJsZSlcbiAqIElOIGFzc2VydGlvbjogMSA8PSBsZW4gPD0gMTVcbiAqL1xuZnVuY3Rpb24gYmlfcmV2ZXJzZShjb2RlLCBsZW4pIHtcbiAgdmFyIHJlcyA9IDA7XG4gIGRvIHtcbiAgICByZXMgfD0gY29kZSAmIDE7XG4gICAgY29kZSA+Pj49IDE7XG4gICAgcmVzIDw8PSAxO1xuICB9IHdoaWxlICgtLWxlbiA+IDApO1xuICByZXR1cm4gcmVzID4+PiAxO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggdGhlIGJpdCBidWZmZXIsIGtlZXBpbmcgYXQgbW9zdCA3IGJpdHMgaW4gaXQuXG4gKi9cbmZ1bmN0aW9uIGJpX2ZsdXNoKHMpIHtcbiAgaWYgKHMuYmlfdmFsaWQgPT09IDE2KSB7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgICBzLmJpX2J1ZiA9IDA7XG4gICAgcy5iaV92YWxpZCA9IDA7XG5cbiAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID49IDgpIHtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmICYgMHhmZjtcbiAgICBzLmJpX2J1ZiA+Pj0gODtcbiAgICBzLmJpX3ZhbGlkIC09IDg7XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgZm9yIGEgdHJlZSBhbmQgdXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoXG4gKiBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQsIGhlYXBbaGVhcF9tYXhdIGFuZFxuICogICAgYWJvdmUgYXJlIHRoZSB0cmVlIG5vZGVzIHNvcnRlZCBieSBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cbiAqIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGQgbGVuIGlzIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoLCB0aGVcbiAqICAgICBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgZnJlcXVlbmNpZXMgZm9yIGVhY2ggYml0IGxlbmd0aC5cbiAqICAgICBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpcyBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXNcbiAqICAgICBub3QgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZ2VuX2JpdGxlbihzLCBkZXNjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHRyZWVfZGVzYyAqZGVzYzsgICAgLyogdGhlIHRyZWUgZGVzY3JpcHRvciAqL1xue1xuICB2YXIgdHJlZSAgICAgICAgICAgID0gZGVzYy5keW5fdHJlZTtcbiAgdmFyIG1heF9jb2RlICAgICAgICA9IGRlc2MubWF4X2NvZGU7XG4gIHZhciBzdHJlZSAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgdmFyIGhhc19zdHJlZSAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgdmFyIGV4dHJhICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2JpdHM7XG4gIHZhciBiYXNlICAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iYXNlO1xuICB2YXIgbWF4X2xlbmd0aCAgICAgID0gZGVzYy5zdGF0X2Rlc2MubWF4X2xlbmd0aDtcbiAgdmFyIGg7ICAgICAgICAgICAgICAvKiBoZWFwIGluZGV4ICovXG4gIHZhciBuLCBtOyAgICAgICAgICAgLyogaXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgLyogYml0IGxlbmd0aCAqL1xuICB2YXIgeGJpdHM7ICAgICAgICAgIC8qIGV4dHJhIGJpdHMgKi9cbiAgdmFyIGY7ICAgICAgICAgICAgICAvKiBmcmVxdWVuY3kgKi9cbiAgdmFyIG92ZXJmbG93ID0gMDsgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgd2l0aCBiaXQgbGVuZ3RoIHRvbyBsYXJnZSAqL1xuXG4gIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIHMuYmxfY291bnRbYml0c10gPSAwO1xuICB9XG5cbiAgLyogSW4gYSBmaXJzdCBwYXNzLCBjb21wdXRlIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhzICh3aGljaCBtYXlcbiAgICogb3ZlcmZsb3cgaW4gdGhlIGNhc2Ugb2YgdGhlIGJpdCBsZW5ndGggdHJlZSkuXG4gICAqL1xuICB0cmVlW3MuaGVhcFtzLmhlYXBfbWF4XSAqIDIgKyAxXS8qLkxlbiovID0gMDsgLyogcm9vdCBvZiB0aGUgaGVhcCAqL1xuXG4gIGZvciAoaCA9IHMuaGVhcF9tYXggKyAxOyBoIDwgSEVBUF9TSVpFOyBoKyspIHtcbiAgICBuID0gcy5oZWFwW2hdO1xuICAgIGJpdHMgPSB0cmVlW3RyZWVbbiAqIDIgKyAxXS8qLkRhZCovICogMiArIDFdLyouTGVuKi8gKyAxO1xuICAgIGlmIChiaXRzID4gbWF4X2xlbmd0aCkge1xuICAgICAgYml0cyA9IG1heF9sZW5ndGg7XG4gICAgICBvdmVyZmxvdysrO1xuICAgIH1cbiAgICB0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IGJpdHM7XG4gICAgLyogV2Ugb3ZlcndyaXRlIHRyZWVbbl0uRGFkIHdoaWNoIGlzIG5vIGxvbmdlciBuZWVkZWQgKi9cblxuICAgIGlmIChuID4gbWF4X2NvZGUpIHsgY29udGludWU7IH0gLyogbm90IGEgbGVhZiBub2RlICovXG5cbiAgICBzLmJsX2NvdW50W2JpdHNdKys7XG4gICAgeGJpdHMgPSAwO1xuICAgIGlmIChuID49IGJhc2UpIHtcbiAgICAgIHhiaXRzID0gZXh0cmFbbiAtIGJhc2VdO1xuICAgIH1cbiAgICBmID0gdHJlZVtuICogMl0vKi5GcmVxKi87XG4gICAgcy5vcHRfbGVuICs9IGYgKiAoYml0cyArIHhiaXRzKTtcbiAgICBpZiAoaGFzX3N0cmVlKSB7XG4gICAgICBzLnN0YXRpY19sZW4gKz0gZiAqIChzdHJlZVtuICogMiArIDFdLyouTGVuKi8gKyB4Yml0cyk7XG4gICAgfVxuICB9XG4gIGlmIChvdmVyZmxvdyA9PT0gMCkgeyByZXR1cm47IH1cblxuICAvLyBUcmFjZSgoc3RkZXJyLFwiXFxuYml0IGxlbmd0aCBvdmVyZmxvd1xcblwiKSk7XG4gIC8qIFRoaXMgaGFwcGVucyBmb3IgZXhhbXBsZSBvbiBvYmoyIGFuZCBwaWMgb2YgdGhlIENhbGdhcnkgY29ycHVzICovXG5cbiAgLyogRmluZCB0aGUgZmlyc3QgYml0IGxlbmd0aCB3aGljaCBjb3VsZCBpbmNyZWFzZTogKi9cbiAgZG8ge1xuICAgIGJpdHMgPSBtYXhfbGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAocy5ibF9jb3VudFtiaXRzXSA9PT0gMCkgeyBiaXRzLS07IH1cbiAgICBzLmJsX2NvdW50W2JpdHNdLS07ICAgICAgLyogbW92ZSBvbmUgbGVhZiBkb3duIHRoZSB0cmVlICovXG4gICAgcy5ibF9jb3VudFtiaXRzICsgMV0gKz0gMjsgLyogbW92ZSBvbmUgb3ZlcmZsb3cgaXRlbSBhcyBpdHMgYnJvdGhlciAqL1xuICAgIHMuYmxfY291bnRbbWF4X2xlbmd0aF0tLTtcbiAgICAvKiBUaGUgYnJvdGhlciBvZiB0aGUgb3ZlcmZsb3cgaXRlbSBhbHNvIG1vdmVzIG9uZSBzdGVwIHVwLFxuICAgICAqIGJ1dCB0aGlzIGRvZXMgbm90IGFmZmVjdCBibF9jb3VudFttYXhfbGVuZ3RoXVxuICAgICAqL1xuICAgIG92ZXJmbG93IC09IDI7XG4gIH0gd2hpbGUgKG92ZXJmbG93ID4gMCk7XG5cbiAgLyogTm93IHJlY29tcHV0ZSBhbGwgYml0IGxlbmd0aHMsIHNjYW5uaW5nIGluIGluY3JlYXNpbmcgZnJlcXVlbmN5LlxuICAgKiBoIGlzIHN0aWxsIGVxdWFsIHRvIEhFQVBfU0laRS4gKEl0IGlzIHNpbXBsZXIgdG8gcmVjb25zdHJ1Y3QgYWxsXG4gICAqIGxlbmd0aHMgaW5zdGVhZCBvZiBmaXhpbmcgb25seSB0aGUgd3Jvbmcgb25lcy4gVGhpcyBpZGVhIGlzIHRha2VuXG4gICAqIGZyb20gJ2FyJyB3cml0dGVuIGJ5IEhhcnVoaWtvIE9rdW11cmEuKVxuICAgKi9cbiAgZm9yIChiaXRzID0gbWF4X2xlbmd0aDsgYml0cyAhPT0gMDsgYml0cy0tKSB7XG4gICAgbiA9IHMuYmxfY291bnRbYml0c107XG4gICAgd2hpbGUgKG4gIT09IDApIHtcbiAgICAgIG0gPSBzLmhlYXBbLS1oXTtcbiAgICAgIGlmIChtID4gbWF4X2NvZGUpIHsgY29udGludWU7IH1cbiAgICAgIGlmICh0cmVlW20gKiAyICsgMV0vKi5MZW4qLyAhPT0gYml0cykge1xuICAgICAgICAvLyBUcmFjZSgoc3RkZXJyLFwiY29kZSAlZCBiaXRzICVkLT4lZFxcblwiLCBtLCB0cmVlW21dLkxlbiwgYml0cykpO1xuICAgICAgICBzLm9wdF9sZW4gKz0gKGJpdHMgLSB0cmVlW20gKiAyICsgMV0vKi5MZW4qLykgKiB0cmVlW20gKiAyXS8qLkZyZXEqLztcbiAgICAgICAgdHJlZVttICogMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgICAgfVxuICAgICAgbi0tO1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogR2VuZXJhdGUgdGhlIGNvZGVzIGZvciBhIGdpdmVuIHRyZWUgYW5kIGJpdCBjb3VudHMgKHdoaWNoIG5lZWQgbm90IGJlXG4gKiBvcHRpbWFsKS5cbiAqIElOIGFzc2VydGlvbjogdGhlIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBiaXQgbGVuZ3RoIHN0YXRpc3RpY3MgZm9yXG4gKiB0aGUgZ2l2ZW4gdHJlZSBhbmQgdGhlIGZpZWxkIGxlbiBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICogT1VUIGFzc2VydGlvbjogdGhlIGZpZWxkIGNvZGUgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cyBvZiBub25cbiAqICAgICB6ZXJvIGNvZGUgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIGJsX2NvdW50KVxuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAgICAgICAgICAgLyogdGhlIHRyZWUgdG8gZGVjb3JhdGUgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuLy8gICAgdXNoZiAqYmxfY291bnQ7ICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCAqL1xue1xuICB2YXIgbmV4dF9jb2RlID0gbmV3IEFycmF5KE1BWF9CSVRTICsgMSk7IC8qIG5leHQgY29kZSB2YWx1ZSBmb3IgZWFjaCBiaXQgbGVuZ3RoICovXG4gIHZhciBjb2RlID0gMDsgICAgICAgICAgICAgIC8qIHJ1bm5pbmcgY29kZSB2YWx1ZSAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAvKiBiaXQgaW5kZXggKi9cbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBpbmRleCAqL1xuXG4gIC8qIFRoZSBkaXN0cmlidXRpb24gY291bnRzIGFyZSBmaXJzdCB1c2VkIHRvIGdlbmVyYXRlIHRoZSBjb2RlIHZhbHVlc1xuICAgKiB3aXRob3V0IGJpdCByZXZlcnNhbC5cbiAgICovXG4gIGZvciAoYml0cyA9IDE7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIG5leHRfY29kZVtiaXRzXSA9IGNvZGUgPSAoY29kZSArIGJsX2NvdW50W2JpdHMgLSAxXSkgPDwgMTtcbiAgfVxuICAvKiBDaGVjayB0aGF0IHRoZSBiaXQgY291bnRzIGluIGJsX2NvdW50IGFyZSBjb25zaXN0ZW50LiBUaGUgbGFzdCBjb2RlXG4gICAqIG11c3QgYmUgYWxsIG9uZXMuXG4gICAqL1xuICAvL0Fzc2VydCAoY29kZSArIGJsX2NvdW50W01BWF9CSVRTXS0xID09ICgxPDxNQVhfQklUUyktMSxcbiAgLy8gICAgICAgIFwiaW5jb25zaXN0ZW50IGJpdCBjb3VudHNcIik7XG4gIC8vVHJhY2V2KChzdGRlcnIsXCJcXG5nZW5fY29kZXM6IG1heF9jb2RlICVkIFwiLCBtYXhfY29kZSkpO1xuXG4gIGZvciAobiA9IDA7ICBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICB2YXIgbGVuID0gdHJlZVtuICogMiArIDFdLyouTGVuKi87XG4gICAgaWYgKGxlbiA9PT0gMCkgeyBjb250aW51ZTsgfVxuICAgIC8qIE5vdyByZXZlcnNlIHRoZSBiaXRzICovXG4gICAgdHJlZVtuICogMl0vKi5Db2RlKi8gPSBiaV9yZXZlcnNlKG5leHRfY29kZVtsZW5dKyssIGxlbik7XG5cbiAgICAvL1RyYWNlY3YodHJlZSAhPSBzdGF0aWNfbHRyZWUsIChzdGRlcnIsXCJcXG5uICUzZCAlYyBsICUyZCBjICU0eCAoJXgpIFwiLFxuICAgIC8vICAgICBuLCAoaXNncmFwaChuKSA/IG4gOiAnICcpLCBsZW4sIHRyZWVbbl0uQ29kZSwgbmV4dF9jb2RlW2xlbl0tMSkpO1xuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSB2YXJpb3VzICdjb25zdGFudCcgdGFibGVzLlxuICovXG5mdW5jdGlvbiB0cl9zdGF0aWNfaW5pdCgpIHtcbiAgdmFyIG47ICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIGJpdHM7ICAgICAvKiBiaXQgY291bnRlciAqL1xuICB2YXIgbGVuZ3RoOyAgIC8qIGxlbmd0aCB2YWx1ZSAqL1xuICB2YXIgY29kZTsgICAgIC8qIGNvZGUgdmFsdWUgKi9cbiAgdmFyIGRpc3Q7ICAgICAvKiBkaXN0YW5jZSBpbmRleCAqL1xuICB2YXIgYmxfY291bnQgPSBuZXcgQXJyYXkoTUFYX0JJVFMgKyAxKTtcbiAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlICovXG5cbiAgLy8gZG8gY2hlY2sgaW4gX3RyX2luaXQoKVxuICAvL2lmIChzdGF0aWNfaW5pdF9kb25lKSByZXR1cm47XG5cbiAgLyogRm9yIHNvbWUgZW1iZWRkZWQgdGFyZ2V0cywgZ2xvYmFsIHZhcmlhYmxlcyBhcmUgbm90IGluaXRpYWxpemVkOiAqL1xuLyojaWZkZWYgTk9fSU5JVF9HTE9CQUxfUE9JTlRFUlNcbiAgc3RhdGljX2xfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19sdHJlZTtcbiAgc3RhdGljX2xfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfbGJpdHM7XG4gIHN0YXRpY19kX2Rlc2Muc3RhdGljX3RyZWUgPSBzdGF0aWNfZHRyZWU7XG4gIHN0YXRpY19kX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2RiaXRzO1xuICBzdGF0aWNfYmxfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfYmxiaXRzO1xuI2VuZGlmKi9cblxuICAvKiBJbml0aWFsaXplIHRoZSBtYXBwaW5nIGxlbmd0aCAoMC4uMjU1KSAtPiBsZW5ndGggY29kZSAoMC4uMjgpICovXG4gIGxlbmd0aCA9IDA7XG4gIGZvciAoY29kZSA9IDA7IGNvZGUgPCBMRU5HVEhfQ09ERVMgLSAxOyBjb2RlKyspIHtcbiAgICBiYXNlX2xlbmd0aFtjb2RlXSA9IGxlbmd0aDtcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgZXh0cmFfbGJpdHNbY29kZV0pOyBuKyspIHtcbiAgICAgIF9sZW5ndGhfY29kZVtsZW5ndGgrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAobGVuZ3RoID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogbGVuZ3RoICE9IDI1NlwiKTtcbiAgLyogTm90ZSB0aGF0IHRoZSBsZW5ndGggMjU1IChtYXRjaCBsZW5ndGggMjU4KSBjYW4gYmUgcmVwcmVzZW50ZWRcbiAgICogaW4gdHdvIGRpZmZlcmVudCB3YXlzOiBjb2RlIDI4NCArIDUgYml0cyBvciBjb2RlIDI4NSwgc28gd2VcbiAgICogb3ZlcndyaXRlIGxlbmd0aF9jb2RlWzI1NV0gdG8gdXNlIHRoZSBiZXN0IGVuY29kaW5nOlxuICAgKi9cbiAgX2xlbmd0aF9jb2RlW2xlbmd0aCAtIDFdID0gY29kZTtcblxuICAvKiBJbml0aWFsaXplIHRoZSBtYXBwaW5nIGRpc3QgKDAuLjMySykgLT4gZGlzdCBjb2RlICgwLi4yOSkgKi9cbiAgZGlzdCA9IDA7XG4gIGZvciAoY29kZSA9IDA7IGNvZGUgPCAxNjsgY29kZSsrKSB7XG4gICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdDtcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgZXh0cmFfZGJpdHNbY29kZV0pOyBuKyspIHtcbiAgICAgIF9kaXN0X2NvZGVbZGlzdCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogZGlzdCAhPSAyNTZcIik7XG4gIGRpc3QgPj49IDc7IC8qIGZyb20gbm93IG9uLCBhbGwgZGlzdGFuY2VzIGFyZSBkaXZpZGVkIGJ5IDEyOCAqL1xuICBmb3IgKDsgY29kZSA8IERfQ09ERVM7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3QgPDwgNztcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgKGV4dHJhX2RiaXRzW2NvZGVdIC0gNykpOyBuKyspIHtcbiAgICAgIF9kaXN0X2NvZGVbMjU2ICsgZGlzdCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogMjU2K2Rpc3QgIT0gNTEyXCIpO1xuXG4gIC8qIENvbnN0cnVjdCB0aGUgY29kZXMgb2YgdGhlIHN0YXRpYyBsaXRlcmFsIHRyZWUgKi9cbiAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgYmxfY291bnRbYml0c10gPSAwO1xuICB9XG5cbiAgbiA9IDA7XG4gIHdoaWxlIChuIDw9IDE0Mykge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA4O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs4XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI1NSkge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA5O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs5XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI3OSkge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA3O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs3XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI4Nykge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA4O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs4XSsrO1xuICB9XG4gIC8qIENvZGVzIDI4NiBhbmQgMjg3IGRvIG5vdCBleGlzdCwgYnV0IHdlIG11c3QgaW5jbHVkZSB0aGVtIGluIHRoZVxuICAgKiB0cmVlIGNvbnN0cnVjdGlvbiB0byBnZXQgYSBjYW5vbmljYWwgSHVmZm1hbiB0cmVlIChsb25nZXN0IGNvZGVcbiAgICogYWxsIG9uZXMpXG4gICAqL1xuICBnZW5fY29kZXMoc3RhdGljX2x0cmVlLCBMX0NPREVTICsgMSwgYmxfY291bnQpO1xuXG4gIC8qIFRoZSBzdGF0aWMgZGlzdGFuY2UgdHJlZSBpcyB0cml2aWFsOiAqL1xuICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgbisrKSB7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDU7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyXS8qLkNvZGUqLyA9IGJpX3JldmVyc2UobiwgNSk7XG4gIH1cblxuICAvLyBOb3cgZGF0YSByZWFkeSBhbmQgd2UgY2FuIGluaXQgc3RhdGljIHRyZWVzXG4gIHN0YXRpY19sX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2x0cmVlLCBleHRyYV9sYml0cywgTElURVJBTFMgKyAxLCBMX0NPREVTLCBNQVhfQklUUyk7XG4gIHN0YXRpY19kX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2R0cmVlLCBleHRyYV9kYml0cywgMCwgICAgICAgICAgRF9DT0RFUywgTUFYX0JJVFMpO1xuICBzdGF0aWNfYmxfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhuZXcgQXJyYXkoMCksIGV4dHJhX2JsYml0cywgMCwgICAgICAgICBCTF9DT0RFUywgTUFYX0JMX0JJVFMpO1xuXG4gIC8vc3RhdGljX2luaXRfZG9uZSA9IHRydWU7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIGEgbmV3IGJsb2NrLlxuICovXG5mdW5jdGlvbiBpbml0X2Jsb2NrKHMpIHtcbiAgdmFyIG47IC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIHRyZWVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDwgTF9DT0RFUzsgIG4rKykgeyBzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG4gIGZvciAobiA9IDA7IG4gPCBEX0NPREVTOyAgbisrKSB7IHMuZHluX2R0cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cbiAgZm9yIChuID0gMDsgbiA8IEJMX0NPREVTOyBuKyspIHsgcy5ibF90cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cblxuICBzLmR5bl9sdHJlZVtFTkRfQkxPQ0sgKiAyXS8qLkZyZXEqLyA9IDE7XG4gIHMub3B0X2xlbiA9IHMuc3RhdGljX2xlbiA9IDA7XG4gIHMubGFzdF9saXQgPSBzLm1hdGNoZXMgPSAwO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggdGhlIGJpdCBidWZmZXIgYW5kIGFsaWduIHRoZSBvdXRwdXQgb24gYSBieXRlIGJvdW5kYXJ5XG4gKi9cbmZ1bmN0aW9uIGJpX3dpbmR1cChzKVxue1xuICBpZiAocy5iaV92YWxpZCA+IDgpIHtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPiAwKSB7XG4gICAgLy9wdXRfYnl0ZShzLCAoQnl0ZSlzLT5iaV9idWYpO1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWY7XG4gIH1cbiAgcy5iaV9idWYgPSAwO1xuICBzLmJpX3ZhbGlkID0gMDtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5IGEgc3RvcmVkIGJsb2NrLCBzdG9yaW5nIGZpcnN0IHRoZSBsZW5ndGggYW5kIGl0c1xuICogb25lJ3MgY29tcGxlbWVudCBpZiByZXF1ZXN0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNvcHlfYmxvY2socywgYnVmLCBsZW4sIGhlYWRlcilcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAgICAqYnVmOyAgICAvKiB0aGUgaW5wdXQgZGF0YSAqL1xuLy91bnNpZ25lZCBsZW47ICAgICAvKiBpdHMgbGVuZ3RoICovXG4vL2ludCAgICAgIGhlYWRlcjsgIC8qIHRydWUgaWYgYmxvY2sgaGVhZGVyIG11c3QgYmUgd3JpdHRlbiAqL1xue1xuICBiaV93aW5kdXAocyk7ICAgICAgICAvKiBhbGlnbiBvbiBieXRlIGJvdW5kYXJ5ICovXG5cbiAgaWYgKGhlYWRlcikge1xuICAgIHB1dF9zaG9ydChzLCBsZW4pO1xuICAgIHB1dF9zaG9ydChzLCB+bGVuKTtcbiAgfVxuLy8gIHdoaWxlIChsZW4tLSkge1xuLy8gICAgcHV0X2J5dGUocywgKmJ1ZisrKTtcbi8vICB9XG4gIHV0aWxzLmFycmF5U2V0KHMucGVuZGluZ19idWYsIHMud2luZG93LCBidWYsIGxlbiwgcy5wZW5kaW5nKTtcbiAgcy5wZW5kaW5nICs9IGxlbjtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wYXJlcyB0byBzdWJ0cmVlcywgdXNpbmcgdGhlIHRyZWUgZGVwdGggYXMgdGllIGJyZWFrZXIgd2hlblxuICogdGhlIHN1YnRyZWVzIGhhdmUgZXF1YWwgZnJlcXVlbmN5LiBUaGlzIG1pbmltaXplcyB0aGUgd29yc3QgY2FzZSBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIHNtYWxsZXIodHJlZSwgbiwgbSwgZGVwdGgpIHtcbiAgdmFyIF9uMiA9IG4gKiAyO1xuICB2YXIgX20yID0gbSAqIDI7XG4gIHJldHVybiAodHJlZVtfbjJdLyouRnJlcSovIDwgdHJlZVtfbTJdLyouRnJlcSovIHx8XG4gICAgICAgICAodHJlZVtfbjJdLyouRnJlcSovID09PSB0cmVlW19tMl0vKi5GcmVxKi8gJiYgZGVwdGhbbl0gPD0gZGVwdGhbbV0pKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZXN0b3JlIHRoZSBoZWFwIHByb3BlcnR5IGJ5IG1vdmluZyBkb3duIHRoZSB0cmVlIHN0YXJ0aW5nIGF0IG5vZGUgayxcbiAqIGV4Y2hhbmdpbmcgYSBub2RlIHdpdGggdGhlIHNtYWxsZXN0IG9mIGl0cyB0d28gc29ucyBpZiBuZWNlc3NhcnksIHN0b3BwaW5nXG4gKiB3aGVuIHRoZSBoZWFwIHByb3BlcnR5IGlzIHJlLWVzdGFibGlzaGVkIChlYWNoIGZhdGhlciBzbWFsbGVyIHRoYW4gaXRzXG4gKiB0d28gc29ucykuXG4gKi9cbmZ1bmN0aW9uIHBxZG93bmhlYXAocywgdHJlZSwgaylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgLyogdGhlIHRyZWUgdG8gcmVzdG9yZSAqL1xuLy8gICAgaW50IGs7ICAgICAgICAgICAgICAgLyogbm9kZSB0byBtb3ZlIGRvd24gKi9cbntcbiAgdmFyIHYgPSBzLmhlYXBba107XG4gIHZhciBqID0gayA8PCAxOyAgLyogbGVmdCBzb24gb2YgayAqL1xuICB3aGlsZSAoaiA8PSBzLmhlYXBfbGVuKSB7XG4gICAgLyogU2V0IGogdG8gdGhlIHNtYWxsZXN0IG9mIHRoZSB0d28gc29uczogKi9cbiAgICBpZiAoaiA8IHMuaGVhcF9sZW4gJiZcbiAgICAgIHNtYWxsZXIodHJlZSwgcy5oZWFwW2ogKyAxXSwgcy5oZWFwW2pdLCBzLmRlcHRoKSkge1xuICAgICAgaisrO1xuICAgIH1cbiAgICAvKiBFeGl0IGlmIHYgaXMgc21hbGxlciB0aGFuIGJvdGggc29ucyAqL1xuICAgIGlmIChzbWFsbGVyKHRyZWUsIHYsIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHsgYnJlYWs7IH1cblxuICAgIC8qIEV4Y2hhbmdlIHYgd2l0aCB0aGUgc21hbGxlc3Qgc29uICovXG4gICAgcy5oZWFwW2tdID0gcy5oZWFwW2pdO1xuICAgIGsgPSBqO1xuXG4gICAgLyogQW5kIGNvbnRpbnVlIGRvd24gdGhlIHRyZWUsIHNldHRpbmcgaiB0byB0aGUgbGVmdCBzb24gb2YgayAqL1xuICAgIGogPDw9IDE7XG4gIH1cbiAgcy5oZWFwW2tdID0gdjtcbn1cblxuXG4vLyBpbmxpbmVkIG1hbnVhbGx5XG4vLyB2YXIgU01BTExFU1QgPSAxO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGJsb2NrIGRhdGEgY29tcHJlc3NlZCB1c2luZyB0aGUgZ2l2ZW4gSHVmZm1hbiB0cmVlc1xuICovXG5mdW5jdGlvbiBjb21wcmVzc19ibG9jayhzLCBsdHJlZSwgZHRyZWUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY29uc3QgY3RfZGF0YSAqbHRyZWU7IC8qIGxpdGVyYWwgdHJlZSAqL1xuLy8gICAgY29uc3QgY3RfZGF0YSAqZHRyZWU7IC8qIGRpc3RhbmNlIHRyZWUgKi9cbntcbiAgdmFyIGRpc3Q7ICAgICAgICAgICAvKiBkaXN0YW5jZSBvZiBtYXRjaGVkIHN0cmluZyAqL1xuICB2YXIgbGM7ICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdCA9PSAwKSAqL1xuICB2YXIgbHggPSAwOyAgICAgICAgIC8qIHJ1bm5pbmcgaW5kZXggaW4gbF9idWYgKi9cbiAgdmFyIGNvZGU7ICAgICAgICAgICAvKiB0aGUgY29kZSB0byBzZW5kICovXG4gIHZhciBleHRyYTsgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgdG8gc2VuZCAqL1xuXG4gIGlmIChzLmxhc3RfbGl0ICE9PSAwKSB7XG4gICAgZG8ge1xuICAgICAgZGlzdCA9IChzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDJdIDw8IDgpIHwgKHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4ICogMiArIDFdKTtcbiAgICAgIGxjID0gcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgbHhdO1xuICAgICAgbHgrKztcblxuICAgICAgaWYgKGRpc3QgPT09IDApIHtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGxjLCBsdHJlZSk7IC8qIHNlbmQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgICAgLy9UcmFjZWN2KGlzZ3JhcGgobGMpLCAoc3RkZXJyLFwiICclYycgXCIsIGxjKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIICovXG4gICAgICAgIGNvZGUgPSBfbGVuZ3RoX2NvZGVbbGNdO1xuICAgICAgICBzZW5kX2NvZGUocywgY29kZSArIExJVEVSQUxTICsgMSwgbHRyZWUpOyAvKiBzZW5kIHRoZSBsZW5ndGggY29kZSAqL1xuICAgICAgICBleHRyYSA9IGV4dHJhX2xiaXRzW2NvZGVdO1xuICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcbiAgICAgICAgICBsYyAtPSBiYXNlX2xlbmd0aFtjb2RlXTtcbiAgICAgICAgICBzZW5kX2JpdHMocywgbGMsIGV4dHJhKTsgICAgICAgLyogc2VuZCB0aGUgZXh0cmEgbGVuZ3RoIGJpdHMgKi9cbiAgICAgICAgfVxuICAgICAgICBkaXN0LS07IC8qIGRpc3QgaXMgbm93IHRoZSBtYXRjaCBkaXN0YW5jZSAtIDEgKi9cbiAgICAgICAgY29kZSA9IGRfY29kZShkaXN0KTtcbiAgICAgICAgLy9Bc3NlcnQgKGNvZGUgPCBEX0NPREVTLCBcImJhZCBkX2NvZGVcIik7XG5cbiAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUsIGR0cmVlKTsgICAgICAgLyogc2VuZCB0aGUgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICBleHRyYSA9IGV4dHJhX2RiaXRzW2NvZGVdO1xuICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcbiAgICAgICAgICBkaXN0IC09IGJhc2VfZGlzdFtjb2RlXTtcbiAgICAgICAgICBzZW5kX2JpdHMocywgZGlzdCwgZXh0cmEpOyAgIC8qIHNlbmQgdGhlIGV4dHJhIGRpc3RhbmNlIGJpdHMgKi9cbiAgICAgICAgfVxuICAgICAgfSAvKiBsaXRlcmFsIG9yIG1hdGNoIHBhaXIgPyAqL1xuXG4gICAgICAvKiBDaGVjayB0aGF0IHRoZSBvdmVybGF5IGJldHdlZW4gcGVuZGluZ19idWYgYW5kIGRfYnVmK2xfYnVmIGlzIG9rOiAqL1xuICAgICAgLy9Bc3NlcnQoKHVJbnQpKHMtPnBlbmRpbmcpIDwgcy0+bGl0X2J1ZnNpemUgKyAyKmx4LFxuICAgICAgLy8gICAgICAgXCJwZW5kaW5nQnVmIG92ZXJmbG93XCIpO1xuXG4gICAgfSB3aGlsZSAobHggPCBzLmxhc3RfbGl0KTtcbiAgfVxuXG4gIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIGx0cmVlKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0cnVjdCBvbmUgSHVmZm1hbiB0cmVlIGFuZCBhc3NpZ25zIHRoZSBjb2RlIGJpdCBzdHJpbmdzIGFuZCBsZW5ndGhzLlxuICogVXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoIGZvciB0aGUgY3VycmVudCBibG9jay5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkIGZyZXEgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cbiAqIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGRzIGxlbiBhbmQgY29kZSBhcmUgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhcbiAqICAgICBhbmQgY29ycmVzcG9uZGluZyBjb2RlLiBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpc1xuICogICAgIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpcyBub3QgbnVsbC4gVGhlIGZpZWxkIG1heF9jb2RlIGlzIHNldC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRfdHJlZShzLCBkZXNjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHRyZWVfZGVzYyAqZGVzYzsgLyogdGhlIHRyZWUgZGVzY3JpcHRvciAqL1xue1xuICB2YXIgdHJlZSAgICAgPSBkZXNjLmR5bl90cmVlO1xuICB2YXIgc3RyZWUgICAgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgdmFyIGhhc19zdHJlZSA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgdmFyIGVsZW1zICAgID0gZGVzYy5zdGF0X2Rlc2MuZWxlbXM7XG4gIHZhciBuLCBtOyAgICAgICAgICAvKiBpdGVyYXRlIG92ZXIgaGVhcCBlbGVtZW50cyAqL1xuICB2YXIgbWF4X2NvZGUgPSAtMTsgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIHZhciBub2RlOyAgICAgICAgICAvKiBuZXcgbm9kZSBiZWluZyBjcmVhdGVkICovXG5cbiAgLyogQ29uc3RydWN0IHRoZSBpbml0aWFsIGhlYXAsIHdpdGggbGVhc3QgZnJlcXVlbnQgZWxlbWVudCBpblxuICAgKiBoZWFwW1NNQUxMRVNUXS4gVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS5cbiAgICogaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICovXG4gIHMuaGVhcF9sZW4gPSAwO1xuICBzLmhlYXBfbWF4ID0gSEVBUF9TSVpFO1xuXG4gIGZvciAobiA9IDA7IG4gPCBlbGVtczsgbisrKSB7XG4gICAgaWYgKHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgICBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IG1heF9jb2RlID0gbjtcbiAgICAgIHMuZGVwdGhbbl0gPSAwO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gMDtcbiAgICB9XG4gIH1cblxuICAvKiBUaGUgcGt6aXAgZm9ybWF0IHJlcXVpcmVzIHRoYXQgYXQgbGVhc3Qgb25lIGRpc3RhbmNlIGNvZGUgZXhpc3RzLFxuICAgKiBhbmQgdGhhdCBhdCBsZWFzdCBvbmUgYml0IHNob3VsZCBiZSBzZW50IGV2ZW4gaWYgdGhlcmUgaXMgb25seSBvbmVcbiAgICogcG9zc2libGUgY29kZS4gU28gdG8gYXZvaWQgc3BlY2lhbCBjaGVja3MgbGF0ZXIgb24gd2UgZm9yY2UgYXQgbGVhc3RcbiAgICogdHdvIGNvZGVzIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeS5cbiAgICovXG4gIHdoaWxlIChzLmhlYXBfbGVuIDwgMikge1xuICAgIG5vZGUgPSBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IChtYXhfY29kZSA8IDIgPyArK21heF9jb2RlIDogMCk7XG4gICAgdHJlZVtub2RlICogMl0vKi5GcmVxKi8gPSAxO1xuICAgIHMuZGVwdGhbbm9kZV0gPSAwO1xuICAgIHMub3B0X2xlbi0tO1xuXG4gICAgaWYgKGhhc19zdHJlZSkge1xuICAgICAgcy5zdGF0aWNfbGVuIC09IHN0cmVlW25vZGUgKiAyICsgMV0vKi5MZW4qLztcbiAgICB9XG4gICAgLyogbm9kZSBpcyAwIG9yIDEgc28gaXQgZG9lcyBub3QgaGF2ZSBleHRyYSBiaXRzICovXG4gIH1cbiAgZGVzYy5tYXhfY29kZSA9IG1heF9jb2RlO1xuXG4gIC8qIFRoZSBlbGVtZW50cyBoZWFwW2hlYXBfbGVuLzIrMSAuLiBoZWFwX2xlbl0gYXJlIGxlYXZlcyBvZiB0aGUgdHJlZSxcbiAgICogZXN0YWJsaXNoIHN1Yi1oZWFwcyBvZiBpbmNyZWFzaW5nIGxlbmd0aHM6XG4gICAqL1xuICBmb3IgKG4gPSAocy5oZWFwX2xlbiA+PiAxLyppbnQgLzIqLyk7IG4gPj0gMTsgbi0tKSB7IHBxZG93bmhlYXAocywgdHJlZSwgbik7IH1cblxuICAvKiBDb25zdHJ1Y3QgdGhlIEh1ZmZtYW4gdHJlZSBieSByZXBlYXRlZGx5IGNvbWJpbmluZyB0aGUgbGVhc3QgdHdvXG4gICAqIGZyZXF1ZW50IG5vZGVzLlxuICAgKi9cbiAgbm9kZSA9IGVsZW1zOyAgICAgICAgICAgICAgLyogbmV4dCBpbnRlcm5hbCBub2RlIG9mIHRoZSB0cmVlICovXG4gIGRvIHtcbiAgICAvL3BxcmVtb3ZlKHMsIHRyZWUsIG4pOyAgLyogbiA9IG5vZGUgb2YgbGVhc3QgZnJlcXVlbmN5ICovXG4gICAgLyoqKiBwcXJlbW92ZSAqKiovXG4gICAgbiA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTtcbiAgICBzLmhlYXBbMS8qU01BTExFU1QqL10gPSBzLmhlYXBbcy5oZWFwX2xlbi0tXTtcbiAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEvKlNNQUxMRVNUKi8pO1xuICAgIC8qKiovXG5cbiAgICBtID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dOyAvKiBtID0gbm9kZSBvZiBuZXh0IGxlYXN0IGZyZXF1ZW5jeSAqL1xuXG4gICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBuOyAvKiBrZWVwIHRoZSBub2RlcyBzb3J0ZWQgYnkgZnJlcXVlbmN5ICovXG4gICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBtO1xuXG4gICAgLyogQ3JlYXRlIGEgbmV3IG5vZGUgZmF0aGVyIG9mIG4gYW5kIG0gKi9cbiAgICB0cmVlW25vZGUgKiAyXS8qLkZyZXEqLyA9IHRyZWVbbiAqIDJdLyouRnJlcSovICsgdHJlZVttICogMl0vKi5GcmVxKi87XG4gICAgcy5kZXB0aFtub2RlXSA9IChzLmRlcHRoW25dID49IHMuZGVwdGhbbV0gPyBzLmRlcHRoW25dIDogcy5kZXB0aFttXSkgKyAxO1xuICAgIHRyZWVbbiAqIDIgKyAxXS8qLkRhZCovID0gdHJlZVttICogMiArIDFdLyouRGFkKi8gPSBub2RlO1xuXG4gICAgLyogYW5kIGluc2VydCB0aGUgbmV3IG5vZGUgaW4gdGhlIGhlYXAgKi9cbiAgICBzLmhlYXBbMS8qU01BTExFU1QqL10gPSBub2RlKys7XG4gICAgcHFkb3duaGVhcChzLCB0cmVlLCAxLypTTUFMTEVTVCovKTtcblxuICB9IHdoaWxlIChzLmhlYXBfbGVuID49IDIpO1xuXG4gIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dO1xuXG4gIC8qIEF0IHRoaXMgcG9pbnQsIHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQuIFdlIGNhbiBub3dcbiAgICogZ2VuZXJhdGUgdGhlIGJpdCBsZW5ndGhzLlxuICAgKi9cbiAgZ2VuX2JpdGxlbihzLCBkZXNjKTtcblxuICAvKiBUaGUgZmllbGQgbGVuIGlzIG5vdyBzZXQsIHdlIGNhbiBnZW5lcmF0ZSB0aGUgYml0IGNvZGVzICovXG4gIGdlbl9jb2Rlcyh0cmVlLCBtYXhfY29kZSwgcy5ibF9jb3VudCk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTY2FuIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIHRvIGRldGVybWluZSB0aGUgZnJlcXVlbmNpZXMgb2YgdGhlIGNvZGVzXG4gKiBpbiB0aGUgYml0IGxlbmd0aCB0cmVlLlxuICovXG5mdW5jdGlvbiBzY2FuX3RyZWUocywgdHJlZSwgbWF4X2NvZGUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAvKiB0aGUgdHJlZSB0byBiZSBzY2FubmVkICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgIC8qIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xue1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIGFsbCB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBwcmV2bGVuID0gLTE7ICAgICAgICAgIC8qIGxhc3QgZW1pdHRlZCBsZW5ndGggKi9cbiAgdmFyIGN1cmxlbjsgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgY29kZSAqL1xuXG4gIHZhciBuZXh0bGVuID0gdHJlZVswICogMiArIDFdLyouTGVuKi87IC8qIGxlbmd0aCBvZiBuZXh0IGNvZGUgKi9cblxuICB2YXIgY291bnQgPSAwOyAgICAgICAgICAgICAvKiByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZSAqL1xuICB2YXIgbWF4X2NvdW50ID0gNzsgICAgICAgICAvKiBtYXggcmVwZWF0IGNvdW50ICovXG4gIHZhciBtaW5fY291bnQgPSA0OyAgICAgICAgIC8qIG1pbiByZXBlYXQgY291bnQgKi9cblxuICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgIG1heF9jb3VudCA9IDEzODtcbiAgICBtaW5fY291bnQgPSAzO1xuICB9XG4gIHRyZWVbKG1heF9jb2RlICsgMSkgKiAyICsgMV0vKi5MZW4qLyA9IDB4ZmZmZjsgLyogZ3VhcmQgKi9cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV0vKi5MZW4qLztcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBzLmJsX3RyZWVbY3VybGVuICogMl0vKi5GcmVxKi8gKz0gY291bnQ7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xuXG4gICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7IHMuYmxfdHJlZVtjdXJsZW4gKiAyXS8qLkZyZXEqLysrOyB9XG4gICAgICBzLmJsX3RyZWVbUkVQXzNfNiAqIDJdLyouRnJlcSovKys7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICBzLmJsX3RyZWVbUkVQWl8zXzEwICogMl0vKi5GcmVxKi8rKztcblxuICAgIH0gZWxzZSB7XG4gICAgICBzLmJsX3RyZWVbUkVQWl8xMV8xMzggKiAyXS8qLkZyZXEqLysrO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuXG4gICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgbWF4X2NvdW50ID0gNjtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4X2NvdW50ID0gNztcbiAgICAgIG1pbl9jb3VudCA9IDQ7XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIGluIGNvbXByZXNzZWQgZm9ybSwgdXNpbmcgdGhlIGNvZGVzIGluXG4gKiBibF90cmVlLlxuICovXG5mdW5jdGlvbiBzZW5kX3RyZWUocywgdHJlZSwgbWF4X2NvZGUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cbntcbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgcHJldmxlbiA9IC0xOyAgICAgICAgICAvKiBsYXN0IGVtaXR0ZWQgbGVuZ3RoICovXG4gIHZhciBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi9cblxuICB2YXIgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovXG5cbiAgdmFyIGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi9cbiAgdmFyIG1heF9jb3VudCA9IDc7ICAgICAgICAgLyogbWF4IHJlcGVhdCBjb3VudCAqL1xuICB2YXIgbWluX2NvdW50ID0gNDsgICAgICAgICAvKiBtaW4gcmVwZWF0IGNvdW50ICovXG5cbiAgLyogdHJlZVttYXhfY29kZSsxXS5MZW4gPSAtMTsgKi8gIC8qIGd1YXJkIGFscmVhZHkgc2V0ICovXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV0vKi5MZW4qLztcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBkbyB7IHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7IH0gd2hpbGUgKC0tY291bnQgIT09IDApO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcbiAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTtcbiAgICAgICAgY291bnQtLTtcbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KGNvdW50ID49IDMgJiYgY291bnQgPD0gNiwgXCIgM182P1wiKTtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBfM182LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMik7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICBzZW5kX2NvZGUocywgUkVQWl8zXzEwLCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfMTFfMTM4LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMTEsIDcpO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuICAgIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIG1heF9jb3VudCA9IDY7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG1heF9jb3VudCA9IDc7XG4gICAgICBtaW5fY291bnQgPSA0O1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgZm9yIHRoZSBiaXQgbGVuZ3RocyBhbmQgcmV0dXJuIHRoZSBpbmRleCBpblxuICogYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkX2JsX3RyZWUocykge1xuICB2YXIgbWF4X2JsaW5kZXg7ICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBiaXQgbGVuZ3RoIGZyZXF1ZW5jaWVzIGZvciBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICBzY2FuX3RyZWUocywgcy5keW5fbHRyZWUsIHMubF9kZXNjLm1heF9jb2RlKTtcbiAgc2Nhbl90cmVlKHMsIHMuZHluX2R0cmVlLCBzLmRfZGVzYy5tYXhfY29kZSk7XG5cbiAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZTogKi9cbiAgYnVpbGRfdHJlZShzLCBzLmJsX2Rlc2MpO1xuICAvKiBvcHRfbGVuIG5vdyBpbmNsdWRlcyB0aGUgbGVuZ3RoIG9mIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucywgZXhjZXB0XG4gICAqIHRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RocyBjb2RlcyBhbmQgdGhlIDUrNSs0IGJpdHMgZm9yIHRoZSBjb3VudHMuXG4gICAqL1xuXG4gIC8qIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGJpdCBsZW5ndGggY29kZXMgdG8gc2VuZC4gVGhlIHBremlwIGZvcm1hdFxuICAgKiByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IDQgYml0IGxlbmd0aCBjb2RlcyBiZSBzZW50LiAoYXBwbm90ZS50eHQgc2F5c1xuICAgKiAzIGJ1dCB0aGUgYWN0dWFsIHZhbHVlIHVzZWQgaXMgNC4pXG4gICAqL1xuICBmb3IgKG1heF9ibGluZGV4ID0gQkxfQ09ERVMgLSAxOyBtYXhfYmxpbmRleCA+PSAzOyBtYXhfYmxpbmRleC0tKSB7XG4gICAgaWYgKHMuYmxfdHJlZVtibF9vcmRlclttYXhfYmxpbmRleF0gKiAyICsgMV0vKi5MZW4qLyAhPT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIC8qIFVwZGF0ZSBvcHRfbGVuIHRvIGluY2x1ZGUgdGhlIGJpdCBsZW5ndGggdHJlZSBhbmQgY291bnRzICovXG4gIHMub3B0X2xlbiArPSAzICogKG1heF9ibGluZGV4ICsgMSkgKyA1ICsgNSArIDQ7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuZHluIHRyZWVzOiBkeW4gJWxkLCBzdGF0ICVsZFwiLFxuICAvLyAgICAgICAgcy0+b3B0X2xlbiwgcy0+c3RhdGljX2xlbikpO1xuXG4gIHJldHVybiBtYXhfYmxpbmRleDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGhlYWRlciBmb3IgYSBibG9jayB1c2luZyBkeW5hbWljIEh1ZmZtYW4gdHJlZXM6IHRoZSBjb3VudHMsIHRoZVxuICogbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcywgdGhlIGxpdGVyYWwgdHJlZSBhbmQgdGhlIGRpc3RhbmNlIHRyZWUuXG4gKiBJTiBhc3NlcnRpb246IGxjb2RlcyA+PSAyNTcsIGRjb2RlcyA+PSAxLCBibGNvZGVzID49IDQuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfYWxsX3RyZWVzKHMsIGxjb2RlcywgZGNvZGVzLCBibGNvZGVzKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGludCBsY29kZXMsIGRjb2RlcywgYmxjb2RlczsgLyogbnVtYmVyIG9mIGNvZGVzIGZvciBlYWNoIHRyZWUgKi9cbntcbiAgdmFyIHJhbms7ICAgICAgICAgICAgICAgICAgICAvKiBpbmRleCBpbiBibF9vcmRlciAqL1xuXG4gIC8vQXNzZXJ0IChsY29kZXMgPj0gMjU3ICYmIGRjb2RlcyA+PSAxICYmIGJsY29kZXMgPj0gNCwgXCJub3QgZW5vdWdoIGNvZGVzXCIpO1xuICAvL0Fzc2VydCAobGNvZGVzIDw9IExfQ09ERVMgJiYgZGNvZGVzIDw9IERfQ09ERVMgJiYgYmxjb2RlcyA8PSBCTF9DT0RFUyxcbiAgLy8gICAgICAgIFwidG9vIG1hbnkgY29kZXNcIik7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY291bnRzOiBcIikpO1xuICBzZW5kX2JpdHMocywgbGNvZGVzIC0gMjU3LCA1KTsgLyogbm90ICsyNTUgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0ICovXG4gIHNlbmRfYml0cyhzLCBkY29kZXMgLSAxLCAgIDUpO1xuICBzZW5kX2JpdHMocywgYmxjb2RlcyAtIDQsICA0KTsgLyogbm90IC0zIGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqL1xuICBmb3IgKHJhbmsgPSAwOyByYW5rIDwgYmxjb2RlczsgcmFuaysrKSB7XG4gICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCBjb2RlICUyZCBcIiwgYmxfb3JkZXJbcmFua10pKTtcbiAgICBzZW5kX2JpdHMocywgcy5ibF90cmVlW2JsX29yZGVyW3JhbmtdICogMiArIDFdLyouTGVuKi8sIDMpO1xuICB9XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG5cbiAgc2VuZF90cmVlKHMsIHMuZHluX2x0cmVlLCBsY29kZXMgLSAxKTsgLyogbGl0ZXJhbCB0cmVlICovXG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxubGl0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xuXG4gIHNlbmRfdHJlZShzLCBzLmR5bl9kdHJlZSwgZGNvZGVzIC0gMSk7IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ2hlY2sgaWYgdGhlIGRhdGEgdHlwZSBpcyBURVhUIG9yIEJJTkFSWSwgdXNpbmcgdGhlIGZvbGxvd2luZyBhbGdvcml0aG06XG4gKiAtIFRFWFQgaWYgdGhlIHR3byBjb25kaXRpb25zIGJlbG93IGFyZSBzYXRpc2ZpZWQ6XG4gKiAgICBhKSBUaGVyZSBhcmUgbm8gbm9uLXBvcnRhYmxlIGNvbnRyb2wgY2hhcmFjdGVycyBiZWxvbmdpbmcgdG8gdGhlXG4gKiAgICAgICBcImJsYWNrIGxpc3RcIiAoMC4uNiwgMTQuLjI1LCAyOC4uMzEpLlxuICogICAgYikgVGhlcmUgaXMgYXQgbGVhc3Qgb25lIHByaW50YWJsZSBjaGFyYWN0ZXIgYmVsb25naW5nIHRvIHRoZVxuICogICAgICAgXCJ3aGl0ZSBsaXN0XCIgKDkge1RBQn0sIDEwIHtMRn0sIDEzIHtDUn0sIDMyLi4yNTUpLlxuICogLSBCSU5BUlkgb3RoZXJ3aXNlLlxuICogLSBUaGUgZm9sbG93aW5nIHBhcnRpYWxseS1wb3J0YWJsZSBjb250cm9sIGNoYXJhY3RlcnMgZm9ybSBhXG4gKiAgIFwiZ3JheSBsaXN0XCIgdGhhdCBpcyBpZ25vcmVkIGluIHRoaXMgZGV0ZWN0aW9uIGFsZ29yaXRobTpcbiAqICAgKDcge0JFTH0sIDgge0JTfSwgMTEge1ZUfSwgMTIge0ZGfSwgMjYge1NVQn0sIDI3IHtFU0N9KS5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkcyBGcmVxIG9mIGR5bl9sdHJlZSBhcmUgc2V0LlxuICovXG5mdW5jdGlvbiBkZXRlY3RfZGF0YV90eXBlKHMpIHtcbiAgLyogYmxhY2tfbWFzayBpcyB0aGUgYml0IG1hc2sgb2YgYmxhY2stbGlzdGVkIGJ5dGVzXG4gICAqIHNldCBiaXRzIDAuLjYsIDE0Li4yNSwgYW5kIDI4Li4zMVxuICAgKiAweGYzZmZjMDdmID0gYmluYXJ5IDExMTEwMDExMTExMTExMTExMTAwMDAwMDAxMTExMTExXG4gICAqL1xuICB2YXIgYmxhY2tfbWFzayA9IDB4ZjNmZmMwN2Y7XG4gIHZhciBuO1xuXG4gIC8qIENoZWNrIGZvciBub24tdGV4dHVhbCAoXCJibGFjay1saXN0ZWRcIikgYnl0ZXMuICovXG4gIGZvciAobiA9IDA7IG4gPD0gMzE7IG4rKywgYmxhY2tfbWFzayA+Pj49IDEpIHtcbiAgICBpZiAoKGJsYWNrX21hc2sgJiAxKSAmJiAocy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSkge1xuICAgICAgcmV0dXJuIFpfQklOQVJZO1xuICAgIH1cbiAgfVxuXG4gIC8qIENoZWNrIGZvciB0ZXh0dWFsIChcIndoaXRlLWxpc3RlZFwiKSBieXRlcy4gKi9cbiAgaWYgKHMuZHluX2x0cmVlWzkgKiAyXS8qLkZyZXEqLyAhPT0gMCB8fCBzLmR5bl9sdHJlZVsxMCAqIDJdLyouRnJlcSovICE9PSAwIHx8XG4gICAgICBzLmR5bl9sdHJlZVsxMyAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgcmV0dXJuIFpfVEVYVDtcbiAgfVxuICBmb3IgKG4gPSAzMjsgbiA8IExJVEVSQUxTOyBuKyspIHtcbiAgICBpZiAocy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgICByZXR1cm4gWl9URVhUO1xuICAgIH1cbiAgfVxuXG4gIC8qIFRoZXJlIGFyZSBubyBcImJsYWNrLWxpc3RlZFwiIG9yIFwid2hpdGUtbGlzdGVkXCIgYnl0ZXM6XG4gICAqIHRoaXMgc3RyZWFtIGVpdGhlciBpcyBlbXB0eSBvciBoYXMgdG9sZXJhdGVkIChcImdyYXktbGlzdGVkXCIpIGJ5dGVzIG9ubHkuXG4gICAqL1xuICByZXR1cm4gWl9CSU5BUlk7XG59XG5cblxudmFyIHN0YXRpY19pbml0X2RvbmUgPSBmYWxzZTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSB0cmVlIGRhdGEgc3RydWN0dXJlcyBmb3IgYSBuZXcgemxpYiBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIF90cl9pbml0KHMpXG57XG5cbiAgaWYgKCFzdGF0aWNfaW5pdF9kb25lKSB7XG4gICAgdHJfc3RhdGljX2luaXQoKTtcbiAgICBzdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTtcbiAgfVxuXG4gIHMubF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9sdHJlZSwgc3RhdGljX2xfZGVzYyk7XG4gIHMuZF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9kdHJlZSwgc3RhdGljX2RfZGVzYyk7XG4gIHMuYmxfZGVzYyA9IG5ldyBUcmVlRGVzYyhzLmJsX3RyZWUsIHN0YXRpY19ibF9kZXNjKTtcblxuICBzLmJpX2J1ZiA9IDA7XG4gIHMuYmlfdmFsaWQgPSAwO1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIGZpcnN0IGJsb2NrIG9mIHRoZSBmaXJzdCBmaWxlOiAqL1xuICBpbml0X2Jsb2NrKHMpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIHN0b3JlZCBibG9ja1xuICovXG5mdW5jdGlvbiBfdHJfc3RvcmVkX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdClcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jayAqL1xuLy91bGcgc3RvcmVkX2xlbjsgICAvKiBsZW5ndGggb2YgaW5wdXQgYmxvY2sgKi9cbi8vaW50IGxhc3Q7ICAgICAgICAgLyogb25lIGlmIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgZm9yIGEgZmlsZSAqL1xue1xuICBzZW5kX2JpdHMocywgKFNUT1JFRF9CTE9DSyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTsgICAgLyogc2VuZCBibG9jayB0eXBlICovXG4gIGNvcHlfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCB0cnVlKTsgLyogd2l0aCBoZWFkZXIgKi9cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgb25lIGVtcHR5IHN0YXRpYyBibG9jayB0byBnaXZlIGVub3VnaCBsb29rYWhlYWQgZm9yIGluZmxhdGUuXG4gKiBUaGlzIHRha2VzIDEwIGJpdHMsIG9mIHdoaWNoIDcgbWF5IHJlbWFpbiBpbiB0aGUgYml0IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gX3RyX2FsaWduKHMpIHtcbiAgc2VuZF9iaXRzKHMsIFNUQVRJQ19UUkVFUyA8PCAxLCAzKTtcbiAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgc3RhdGljX2x0cmVlKTtcbiAgYmlfZmx1c2gocyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcgZm9yIHRoZSBjdXJyZW50IGJsb2NrOiBkeW5hbWljIHRyZWVzLCBzdGF0aWNcbiAqIHRyZWVzIG9yIHN0b3JlLCBhbmQgb3V0cHV0IHRoZSBlbmNvZGVkIGJsb2NrIHRvIHRoZSB6aXAgZmlsZS5cbiAqL1xuZnVuY3Rpb24gX3RyX2ZsdXNoX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdClcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jaywgb3IgTlVMTCBpZiB0b28gb2xkICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG57XG4gIHZhciBvcHRfbGVuYiwgc3RhdGljX2xlbmI7ICAvKiBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGluIGJ5dGVzICovXG4gIHZhciBtYXhfYmxpbmRleCA9IDA7ICAgICAgICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogQnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgdW5sZXNzIGEgc3RvcmVkIGJsb2NrIGlzIGZvcmNlZCAqL1xuICBpZiAocy5sZXZlbCA+IDApIHtcblxuICAgIC8qIENoZWNrIGlmIHRoZSBmaWxlIGlzIGJpbmFyeSBvciB0ZXh0ICovXG4gICAgaWYgKHMuc3RybS5kYXRhX3R5cGUgPT09IFpfVU5LTk9XTikge1xuICAgICAgcy5zdHJtLmRhdGFfdHlwZSA9IGRldGVjdF9kYXRhX3R5cGUocyk7XG4gICAgfVxuXG4gICAgLyogQ29uc3RydWN0IHRoZSBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICAgIGJ1aWxkX3RyZWUocywgcy5sX2Rlc2MpO1xuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbmxpdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZFwiLCBzLT5vcHRfbGVuLFxuICAgIC8vICAgICAgICBzLT5zdGF0aWNfbGVuKSk7XG5cbiAgICBidWlsZF90cmVlKHMsIHMuZF9kZXNjKTtcbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IGRhdGE6IGR5biAlbGQsIHN0YXQgJWxkXCIsIHMtPm9wdF9sZW4sXG4gICAgLy8gICAgICAgIHMtPnN0YXRpY19sZW4pKTtcbiAgICAvKiBBdCB0aGlzIHBvaW50LCBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGFyZSB0aGUgdG90YWwgYml0IGxlbmd0aHMgb2ZcbiAgICAgKiB0aGUgY29tcHJlc3NlZCBibG9jayBkYXRhLCBleGNsdWRpbmcgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLlxuICAgICAqL1xuXG4gICAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZSBmb3IgdGhlIGFib3ZlIHR3byB0cmVlcywgYW5kIGdldCB0aGUgaW5kZXhcbiAgICAgKiBpbiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cbiAgICAgKi9cbiAgICBtYXhfYmxpbmRleCA9IGJ1aWxkX2JsX3RyZWUocyk7XG5cbiAgICAvKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcuIENvbXB1dGUgdGhlIGJsb2NrIGxlbmd0aHMgaW4gYnl0ZXMuICovXG4gICAgb3B0X2xlbmIgPSAocy5vcHRfbGVuICsgMyArIDcpID4+PiAzO1xuICAgIHN0YXRpY19sZW5iID0gKHMuc3RhdGljX2xlbiArIDMgKyA3KSA+Pj4gMztcblxuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbm9wdCAlbHUoJWx1KSBzdGF0ICVsdSglbHUpIHN0b3JlZCAlbHUgbGl0ICV1IFwiLFxuICAgIC8vICAgICAgICBvcHRfbGVuYiwgcy0+b3B0X2xlbiwgc3RhdGljX2xlbmIsIHMtPnN0YXRpY19sZW4sIHN0b3JlZF9sZW4sXG4gICAgLy8gICAgICAgIHMtPmxhc3RfbGl0KSk7XG5cbiAgICBpZiAoc3RhdGljX2xlbmIgPD0gb3B0X2xlbmIpIHsgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYjsgfVxuXG4gIH0gZWxzZSB7XG4gICAgLy8gQXNzZXJ0KGJ1ZiAhPSAoY2hhciopMCwgXCJsb3N0IGJ1ZlwiKTtcbiAgICBvcHRfbGVuYiA9IHN0YXRpY19sZW5iID0gc3RvcmVkX2xlbiArIDU7IC8qIGZvcmNlIGEgc3RvcmVkIGJsb2NrICovXG4gIH1cblxuICBpZiAoKHN0b3JlZF9sZW4gKyA0IDw9IG9wdF9sZW5iKSAmJiAoYnVmICE9PSAtMSkpIHtcbiAgICAvKiA0OiB0d28gd29yZHMgZm9yIHRoZSBsZW5ndGhzICovXG5cbiAgICAvKiBUaGUgdGVzdCBidWYgIT0gTlVMTCBpcyBvbmx5IG5lY2Vzc2FyeSBpZiBMSVRfQlVGU0laRSA+IFdTSVpFLlxuICAgICAqIE90aGVyd2lzZSB3ZSBjYW4ndCBoYXZlIHByb2Nlc3NlZCBtb3JlIHRoYW4gV1NJWkUgaW5wdXQgYnl0ZXMgc2luY2VcbiAgICAgKiB0aGUgbGFzdCBibG9jayBmbHVzaCwgYmVjYXVzZSBjb21wcmVzc2lvbiB3b3VsZCBoYXZlIGJlZW5cbiAgICAgKiBzdWNjZXNzZnVsLiBJZiBMSVRfQlVGU0laRSA8PSBXU0laRSwgaXQgaXMgbmV2ZXIgdG9vIGxhdGUgdG9cbiAgICAgKiB0cmFuc2Zvcm0gYSBibG9jayBpbnRvIGEgc3RvcmVkIGJsb2NrLlxuICAgICAqL1xuICAgIF90cl9zdG9yZWRfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KTtcblxuICB9IGVsc2UgaWYgKHMuc3RyYXRlZ3kgPT09IFpfRklYRUQgfHwgc3RhdGljX2xlbmIgPT09IG9wdF9sZW5iKSB7XG5cbiAgICBzZW5kX2JpdHMocywgKFNUQVRJQ19UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzdGF0aWNfbHRyZWUsIHN0YXRpY19kdHJlZSk7XG5cbiAgfSBlbHNlIHtcbiAgICBzZW5kX2JpdHMocywgKERZTl9UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBzZW5kX2FsbF90cmVlcyhzLCBzLmxfZGVzYy5tYXhfY29kZSArIDEsIHMuZF9kZXNjLm1heF9jb2RlICsgMSwgbWF4X2JsaW5kZXggKyAxKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzLmR5bl9sdHJlZSwgcy5keW5fZHRyZWUpO1xuICB9XG4gIC8vIEFzc2VydCAocy0+Y29tcHJlc3NlZF9sZW4gPT0gcy0+Yml0c19zZW50LCBcImJhZCBjb21wcmVzc2VkIHNpemVcIik7XG4gIC8qIFRoZSBhYm92ZSBjaGVjayBpcyBtYWRlIG1vZCAyXjMyLCBmb3IgZmlsZXMgbGFyZ2VyIHRoYW4gNTEyIE1CXG4gICAqIGFuZCB1TG9uZyBpbXBsZW1lbnRlZCBvbiAzMiBiaXRzLlxuICAgKi9cbiAgaW5pdF9ibG9jayhzKTtcblxuICBpZiAobGFzdCkge1xuICAgIGJpX3dpbmR1cChzKTtcbiAgfVxuICAvLyBUcmFjZXYoKHN0ZGVycixcIlxcbmNvbXBybGVuICVsdSglbHUpIFwiLCBzLT5jb21wcmVzc2VkX2xlbj4+MyxcbiAgLy8gICAgICAgcy0+Y29tcHJlc3NlZF9sZW4tNypsYXN0KSk7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2F2ZSB0aGUgbWF0Y2ggaW5mbyBhbmQgdGFsbHkgdGhlIGZyZXF1ZW5jeSBjb3VudHMuIFJldHVybiB0cnVlIGlmXG4gKiB0aGUgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQuXG4gKi9cbmZ1bmN0aW9uIF90cl90YWxseShzLCBkaXN0LCBsYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB1bnNpZ25lZCBkaXN0OyAgLyogZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmcgKi9cbi8vICAgIHVuc2lnbmVkIGxjOyAgICAvKiBtYXRjaCBsZW5ndGgtTUlOX01BVENIIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0PT0wKSAqL1xue1xuICAvL3ZhciBvdXRfbGVuZ3RoLCBpbl9sZW5ndGgsIGRjb2RlO1xuXG4gIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyXSAgICAgPSAoZGlzdCA+Pj4gOCkgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMiArIDFdID0gZGlzdCAmIDB4ZmY7XG5cbiAgcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgcy5sYXN0X2xpdF0gPSBsYyAmIDB4ZmY7XG4gIHMubGFzdF9saXQrKztcblxuICBpZiAoZGlzdCA9PT0gMCkge1xuICAgIC8qIGxjIGlzIHRoZSB1bm1hdGNoZWQgY2hhciAqL1xuICAgIHMuZHluX2x0cmVlW2xjICogMl0vKi5GcmVxKi8rKztcbiAgfSBlbHNlIHtcbiAgICBzLm1hdGNoZXMrKztcbiAgICAvKiBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIICovXG4gICAgZGlzdC0tOyAgICAgICAgICAgICAvKiBkaXN0ID0gbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgLy9Bc3NlcnQoKHVzaClkaXN0IDwgKHVzaClNQVhfRElTVChzKSAmJlxuICAgIC8vICAgICAgICh1c2gpbGMgPD0gKHVzaCkoTUFYX01BVENILU1JTl9NQVRDSCkgJiZcbiAgICAvLyAgICAgICAodXNoKWRfY29kZShkaXN0KSA8ICh1c2gpRF9DT0RFUywgIFwiX3RyX3RhbGx5OiBiYWQgbWF0Y2hcIik7XG5cbiAgICBzLmR5bl9sdHJlZVsoX2xlbmd0aF9jb2RlW2xjXSArIExJVEVSQUxTICsgMSkgKiAyXS8qLkZyZXEqLysrO1xuICAgIHMuZHluX2R0cmVlW2RfY29kZShkaXN0KSAqIDJdLyouRnJlcSovKys7XG4gIH1cblxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcblxuLy8jaWZkZWYgVFJVTkNBVEVfQkxPQ0tcbi8vICAvKiBUcnkgdG8gZ3Vlc3MgaWYgaXQgaXMgcHJvZml0YWJsZSB0byBzdG9wIHRoZSBjdXJyZW50IGJsb2NrIGhlcmUgKi9cbi8vICBpZiAoKHMubGFzdF9saXQgJiAweDFmZmYpID09PSAwICYmIHMubGV2ZWwgPiAyKSB7XG4vLyAgICAvKiBDb21wdXRlIGFuIHVwcGVyIGJvdW5kIGZvciB0aGUgY29tcHJlc3NlZCBsZW5ndGggKi9cbi8vICAgIG91dF9sZW5ndGggPSBzLmxhc3RfbGl0Kjg7XG4vLyAgICBpbl9sZW5ndGggPSBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydDtcbi8vXG4vLyAgICBmb3IgKGRjb2RlID0gMDsgZGNvZGUgPCBEX0NPREVTOyBkY29kZSsrKSB7XG4vLyAgICAgIG91dF9sZW5ndGggKz0gcy5keW5fZHRyZWVbZGNvZGUqMl0vKi5GcmVxKi8gKiAoNSArIGV4dHJhX2RiaXRzW2Rjb2RlXSk7XG4vLyAgICB9XG4vLyAgICBvdXRfbGVuZ3RoID4+Pj0gMztcbi8vICAgIC8vVHJhY2V2KChzdGRlcnIsXCJcXG5sYXN0X2xpdCAldSwgaW4gJWxkLCBvdXQgfiVsZCglbGQlJSkgXCIsXG4vLyAgICAvLyAgICAgICBzLT5sYXN0X2xpdCwgaW5fbGVuZ3RoLCBvdXRfbGVuZ3RoLFxuLy8gICAgLy8gICAgICAgMTAwTCAtIG91dF9sZW5ndGgqMTAwTC9pbl9sZW5ndGgpKTtcbi8vICAgIGlmIChzLm1hdGNoZXMgPCAocy5sYXN0X2xpdD4+MSkvKmludCAvMiovICYmIG91dF9sZW5ndGggPCAoaW5fbGVuZ3RoPj4xKS8qaW50IC8yKi8pIHtcbi8vICAgICAgcmV0dXJuIHRydWU7XG4vLyAgICB9XG4vLyAgfVxuLy8jZW5kaWZcblxuICByZXR1cm4gKHMubGFzdF9saXQgPT09IHMubGl0X2J1ZnNpemUgLSAxKTtcbiAgLyogV2UgYXZvaWQgZXF1YWxpdHkgd2l0aCBsaXRfYnVmc2l6ZSBiZWNhdXNlIG9mIHdyYXBhcm91bmQgYXQgNjRLXG4gICAqIG9uIDE2IGJpdCBtYWNoaW5lcyBhbmQgYmVjYXVzZSBzdG9yZWQgYmxvY2tzIGFyZSByZXN0cmljdGVkIHRvXG4gICAqIDY0Sy0xIGJ5dGVzLlxuICAgKi9cbn1cblxuZXhwb3J0cy5fdHJfaW5pdCAgPSBfdHJfaW5pdDtcbmV4cG9ydHMuX3RyX3N0b3JlZF9ibG9jayA9IF90cl9zdG9yZWRfYmxvY2s7XG5leHBvcnRzLl90cl9mbHVzaF9ibG9jayAgPSBfdHJfZmx1c2hfYmxvY2s7XG5leHBvcnRzLl90cl90YWxseSA9IF90cl90YWxseTtcbmV4cG9ydHMuX3RyX2FsaWduID0gX3RyX2FsaWduO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/pako/lib/zlib/trees.js\n");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/zstream.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/zstream.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(" // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n\n  this.next_in = 0;\n  /* number of bytes available at input */\n\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n\n  this.total_in = 0;\n  /* next output byte should be put there */\n\n  this.output = null; // JS specific, because we have no pointers\n\n  this.next_out = 0;\n  /* remaining free space at output */\n\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n\n  this.msg = ''\n  /*Z_NULL*/\n  ;\n  /* not visible by applications */\n\n  this.state = null;\n  /* best guess about the data type: binary or text */\n\n  this.data_type = 2\n  /*Z_UNKNOWN*/\n  ;\n  /* adler32 value of the uncompressed data */\n\n  this.adler = 0;\n}\n\nmodule.exports = ZStream;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi96c3RyZWFtLmpzPzg5MzYiXSwibmFtZXMiOlsiWlN0cmVhbSIsImlucHV0IiwibmV4dF9pbiIsImF2YWlsX2luIiwidG90YWxfaW4iLCJvdXRwdXQiLCJuZXh0X291dCIsImF2YWlsX291dCIsInRvdGFsX291dCIsIm1zZyIsInN0YXRlIiwiZGF0YV90eXBlIiwiYWRsZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQ0FFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBU0EsT0FBVCxHQUFtQjtBQUNqQjtBQUNBLE9BQUtDLEtBQUwsR0FBYSxJQUFiLENBRmlCLENBRUU7O0FBQ25CLE9BQUtDLE9BQUwsR0FBZSxDQUFmO0FBQ0E7O0FBQ0EsT0FBS0MsUUFBTCxHQUFnQixDQUFoQjtBQUNBOztBQUNBLE9BQUtDLFFBQUwsR0FBZ0IsQ0FBaEI7QUFDQTs7QUFDQSxPQUFLQyxNQUFMLEdBQWMsSUFBZCxDQVRpQixDQVNHOztBQUNwQixPQUFLQyxRQUFMLEdBQWdCLENBQWhCO0FBQ0E7O0FBQ0EsT0FBS0MsU0FBTCxHQUFpQixDQUFqQjtBQUNBOztBQUNBLE9BQUtDLFNBQUwsR0FBaUIsQ0FBakI7QUFDQTs7QUFDQSxPQUFLQyxHQUFMLEdBQVc7QUFBRTtBQUFiO0FBQ0E7O0FBQ0EsT0FBS0MsS0FBTCxHQUFhLElBQWI7QUFDQTs7QUFDQSxPQUFLQyxTQUFMLEdBQWlCO0FBQUM7QUFBbEI7QUFDQTs7QUFDQSxPQUFLQyxLQUFMLEdBQWEsQ0FBYjtBQUNEOztBQUVEQyxNQUFNLENBQUNDLE9BQVAsR0FBaUJkLE9BQWpCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvenN0cmVhbS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5mdW5jdGlvbiBaU3RyZWFtKCkge1xuICAvKiBuZXh0IGlucHV0IGJ5dGUgKi9cbiAgdGhpcy5pbnB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcbiAgdGhpcy5uZXh0X2luID0gMDtcbiAgLyogbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSBhdCBpbnB1dCAqL1xuICB0aGlzLmF2YWlsX2luID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGlucHV0IGJ5dGVzIHJlYWQgc28gZmFyICovXG4gIHRoaXMudG90YWxfaW4gPSAwO1xuICAvKiBuZXh0IG91dHB1dCBieXRlIHNob3VsZCBiZSBwdXQgdGhlcmUgKi9cbiAgdGhpcy5vdXRwdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9vdXQgPSAwO1xuICAvKiByZW1haW5pbmcgZnJlZSBzcGFjZSBhdCBvdXRwdXQgKi9cbiAgdGhpcy5hdmFpbF9vdXQgPSAwO1xuICAvKiB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgb3V0cHV0IHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX291dCA9IDA7XG4gIC8qIGxhc3QgZXJyb3IgbWVzc2FnZSwgTlVMTCBpZiBubyBlcnJvciAqL1xuICB0aGlzLm1zZyA9ICcnLypaX05VTEwqLztcbiAgLyogbm90IHZpc2libGUgYnkgYXBwbGljYXRpb25zICovXG4gIHRoaXMuc3RhdGUgPSBudWxsO1xuICAvKiBiZXN0IGd1ZXNzIGFib3V0IHRoZSBkYXRhIHR5cGU6IGJpbmFyeSBvciB0ZXh0ICovXG4gIHRoaXMuZGF0YV90eXBlID0gMi8qWl9VTktOT1dOKi87XG4gIC8qIGFkbGVyMzIgdmFsdWUgb2YgdGhlIHVuY29tcHJlc3NlZCBkYXRhICovXG4gIHRoaXMuYWRsZXIgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFpTdHJlYW07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/pako/lib/zlib/zstream.js\n");

/***/ })

}]);